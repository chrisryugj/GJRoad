<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>진출로 – 출장길 도우미</title>
  <style>
    /* Modern CSS Reset & Base Styles */
    *, *::before, *::after {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0;
      padding: 0;
      min-height: 100vh;
      color: #333;
    }
    
    .app-container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      min-height: 100vh;
    }
    
    /* Header Styles */
    .app-header {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 30px;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }
    
    .app-title {
      font-size: 2rem;
      font-weight: 700;
      color: #1b3c82;
      margin-bottom: 5px;
      cursor: pointer;
      transition: color 0.3s ease;
    }
    
    .app-title:hover {
      color: #4facfe;
    }
    
    .app-subtitle {
      color: #666;
      font-size: 1.1rem;
      margin-bottom: 15px;
    }
    
    /* Banner Styles */
    .app-banner {
      border-radius: 15px;
      padding: 0;
      margin: 15px 0 20px 0;
      overflow: hidden;
      position: relative;
      background: transparent;
    }
    
    .banner-image {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 15px;
    }
    
    /* Animations */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Mode Selection Styles */
    .mode-selector {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }
    
    .mode-card {
      background: rgba(255, 255, 255, 0.9);
      border: 2px solid transparent;
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .mode-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    }
    
    .mode-card.active {
      border-color: #1b3c82;
      background: #1b3c82;
      color: white;
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(27, 60, 130, 0.3);
    }
    
    .mode-icon {
      font-size: 2.5rem;
      margin-bottom: 10px;
      display: block;
    }
    
    .mode-title {
      font-weight: 600;
      font-size: 1.1rem;
      margin-bottom: 5px;
    }
    
    .mode-desc {
      font-size: 0.9rem;
      opacity: 0.8;
    }
    
    /* Card Styles */
    .card {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 25px;
      margin-bottom: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s ease;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
    }
    
    .card-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 2px solid #f0f0f0;
    }
    
    .card-icon {
      font-size: 1.5rem;
      color: #1b3c82;
    }
    
    .card-title {
      font-size: 1.3rem;
      font-weight: 600;
      color: #333;
      margin: 0;
    }
    
    .card-content {
      line-height: 1.6;
    }
    
    /* Form Styles */
    .form-group {
      margin-bottom: 20px;
    }
    
    .form-label {
      display: block;
      font-weight: 600;
      margin-bottom: 8px;
      color: #333;
    }
    
    .form-input, .form-select, .form-textarea {
      width: 100%;
      padding: 15px;
      border: 2px solid #e1e5e9;
      border-radius: 12px;
      font-size: 1rem;
      transition: all 0.3s ease;
      background: rgba(255, 255, 255, 0.8);
    }
    
    .form-input:focus, .form-select:focus, .form-textarea:focus {
      outline: none;
      border-color: #1b3c82;
      box-shadow: 0 0 0 3px rgba(27, 60, 130, 0.1);
      background: white;
    }
    
    .form-textarea {
      resize: vertical;
      min-height: 100px;
    }
    
    /* Button Styles */
    .btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 15px 25px;
      border: none;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      justify-content: center;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
    }
    
    .btn-secondary {
      background: rgba(255, 255, 255, 0.9);
      color: #333;
      border: 2px solid #e1e5e9;
    }
    
    .btn-secondary:hover {
      background: white;
      border-color: #1b3c82;
    }
    
    .btn-success {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      color: white;
    }
    
    .btn-danger {
      background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
      color: white;
    }
    
    .btn-info {
      background: #17a2b8;
      color: white;
      border: none;
    }
    
    .btn-info:hover {
      background: #138496;
    }
    
    .btn-warning {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
    }
    
    .btn-warning:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(245, 87, 108, 0.4);
    }
    
    .btn-full {
      width: 100%;
    }
    
    /* Map Selection Buttons */
    .map-option {
      background: rgba(255, 255, 255, 0.9);
      border: 2px solid #e1e5e9;
      border-radius: 15px;
      padding: 20px 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      font-family: inherit;
    }
    
    .map-option:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      border-color: #1b3c82;
    }
    
    .map-option.selected {
      background: #1b3c82;
      color: white;
      border-color: #1b3c82;
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(27, 60, 130, 0.3);
      position: relative;
    }
    
    .map-option.selected::after {
      content: "✓";
      position: absolute;
      top: 8px;
      right: 8px;
      background: #27ae60;
      color: white;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
    }
    
    .map-icon {
      width: 50px;
      height: 50px;
      margin: 0 auto 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      overflow: hidden;
    }
    
    .map-icon img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .map-name {
      font-weight: 600;
      font-size: 0.95rem;
    }
    
    /* Step Indicator */
    .step-indicator {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      margin-bottom: 30px;
    }
    
    .step {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    
    .step.completed {
      background: #4facfe;
      color: white;
    }
    
    .step.active {
      background: #1b3c82;
      color: white;
      transform: scale(1.1);
    }
    
    .step.pending {
      background: #f0f0f0;
      color: #999;
    }
    
    .step-line {
      width: 30px;
      height: 2px;
      background: #f0f0f0;
    }
    
    .step-line.completed {
      background: #4facfe;
    }
    
    /* Address Card Styles */
    .address-card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 15px;
      border-left: 5px solid #e1e5e9;
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    .address-card:hover {
      transform: translateX(5px);
      border-left-color: #1b3c82;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
    }
    
    .address-card.completed {
      border-left-color: #4facfe;
      background: rgba(79, 172, 254, 0.05);
    }
    
    .address-card.pending {
      border-left-color: #fa709a;
      background: rgba(250, 112, 154, 0.05);
    }
    
    .address-title {
      font-weight: 600;
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .address-status {
      font-size: 0.9rem;
      padding: 5px 12px;
      border-radius: 20px;
      font-weight: 500;
    }
    
    .status-completed {
      background: rgba(79, 172, 254, 0.2);
      color: #1b3c82;
    }
    
    .status-pending {
      background: rgba(250, 112, 154, 0.2);
      color: #c62828;
    }
    
    .status-none {
      background: rgba(0, 0, 0, 0.1);
      color: #666;
    }
    
    /* Photo Grid */
    .photo-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 10px;
      margin-top: 15px;
    }
    
    .photo-preview {
      width: 100%;
      height: 80px;
      border-radius: 10px;
      object-fit: cover;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px solid rgba(255, 255, 255, 0.8);
    }
    
    .photo-preview:hover {
      transform: scale(1.05);
      border-color: #1b3c82;
    }
    
    /* Data Management Styles */
    .data-management {
      text-align: center;
      padding: 15px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      backdrop-filter: blur(5px);
    }
    
    .data-status {
      font-size: 1rem;
      color: rgba(27, 60, 130, 0.8);
      font-weight: 500;
    }
    
    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
      z-index: 9999;
      align-items: center;
      justify-content: center;
    }
    
    .modal.show {
      display: flex;
    }
    
    .modal-content {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    
    .modal-header {
      text-align: center;
      margin-bottom: 25px;
    }
    
    .modal-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: #1b3c82;
      margin-bottom: 10px;
    }
    
    .modal-subtitle {
      color: #666;
      font-size: 0.95rem;
    }
    
    .option-grid {
      display: grid;
      gap: 15px;
      margin-bottom: 25px;
    }
    
    .option-card {
      background: rgba(255, 255, 255, 0.8);
      border: 2px solid #e1e5e9;
      border-radius: 12px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }
    
    .option-card:hover {
      border-color: #1b3c82;
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
    }
    
    .option-card.danger:hover {
      border-color: #e74c3c;
      background: rgba(231, 76, 60, 0.05);
    }
    
    .option-card.warning:hover {
      border-color: #f39c12;
      background: rgba(243, 156, 18, 0.05);
    }
    
    .option-icon {
      font-size: 2rem;
      margin-bottom: 10px;
    }
    
    .option-title {
      font-weight: 600;
      margin-bottom: 5px;
    }
    
    .option-desc {
      font-size: 0.9rem;
      color: #666;
    }
    
    /* Hide sections by default */
    .mode-section {
      display: none;
    }
    
    .mode-section.active {
      display: block;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .app-container {
        padding: 15px;
      }
      
      .header-logo {
        max-width: 70px !important;
        height: auto !important;
        width: auto !important;
      }
      
      .mode-selector {
        grid-template-columns: 1fr 1fr 1fr 1fr;
        gap: 8px;
      }
      
      .mode-card {
        padding: 12px 8px;
        text-align: center;
      }
      
      .mode-icon {
        font-size: 1.8rem;
        margin-bottom: 5px;
      }
      
      .mode-title {
        font-size: 0.85rem;
        margin-bottom: 0;
      }
      
      .mode-desc {
        display: none;
      }
      
      .card {
        padding: 20px;
      }
      
      .app-title {
        font-size: 1.7rem;
      }
      
      .btn {
        padding: 12px 20px;
      }
      
      .card-header .btn {
        padding: 6px 10px !important;
        font-size: 0.8rem !important;
      }
      
      .map-button-selector {
        grid-template-columns: 1fr 1fr 1fr !important;
        gap: 10px !important;
      }
      
      .map-option {
        padding: 15px 10px !important;
      }
      
      .map-name {
        font-size: 0.85rem !important;
      }
      
      .modal-content {
        padding: 20px;
        max-height: 85vh;
        width: 95%;
      }
      
      .modal-title {
        font-size: 1.3rem;
      }
      
      .modal-subtitle {
        font-size: 0.9rem;
      }
    }
    
    @media (max-width: 480px) {
      .app-header img {
        height: 35px !important;
        width: 50% !important;
      }
      
      .app-title {
        font-size: 1.4rem !important;
      }
      
      .app-subtitle {
        font-size: 0.8rem !important;
      }
      
      .mode-selector {
        grid-template-columns: 1fr 1fr 1fr 1fr;
        gap: 6px;
      }
      
      .mode-card {
        padding: 10px 6px;
      }
      
      .mode-icon {
        font-size: 1.5rem;
        margin-bottom: 3px;
      }
      
      .mode-title {
        font-size: 0.75rem;
      }
      
      .step-indicator {
        gap: 10px;
      }
      
      .step {
        width: 35px;
      }
      
      .modal-content {
        padding: 15px;
        max-height: 90vh;
        width: 98%;
        margin: 5vh auto;
      }
      
      .modal-title {
        font-size: 1.2rem;
      }
      
      .modal-subtitle {
        font-size: 0.85rem;
      }
      
      .form-group {
        margin-bottom: 15px !important;
      }
      
      .form-input {
        padding: 12px !important;
        font-size: 16px !important; /* Prevents zoom on iOS */
      }
    }
    
    /* Legacy styles for compatibility */
    .dropdown-item.memo-marked::after {
      content: "\1F4DD";
      float: right;
      margin-left: 8px;
      font-size: 1rem;
    }
    
    #customDropdown {
      position: absolute;
      z-index: 1000;
      background-color: white;
      width: calc(100% - 22px);
      border-radius: 12px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }
    header {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 10px;
    }
    header > div {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
    }
    header img {
      height: 36px;
      cursor: pointer;
    }
    header span {
      color: #1b3c82;
    }
    header .sub {
      color: #555;
    }
    #bannerImage {
      width: 100%;
      max-width: 100%;
      display: none;
      margin-top: 8px;
      border-radius: 8px;
    }
  .tabs {
  display: flex;
  justify-content: center;
  flex-wrap: nowrap;
  overflow-x: auto;
  gap: 8px;
  margin-bottom: 10px;
}
.tabs button {
  flex: 0 1 auto; /* 줄어들거나 늘어나지 않도록 조정 */
  white-space: nowrap;
  padding: 8px 16px;
}
    .tabs button.active {
      background-color: #1b3c82;
      color: #fff;
    }
    .tab-content {
      display: none;
      background: white;
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .tab-content.active {
      display: block;
    }
    .card-ui {
      background-color: #fff;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
      padding: 15px;
      margin-bottom: 15px;

    }
    input[type="text"], input[type="file"], select, button, textarea {
      width: 100%;
      margin-bottom: 8px;
      padding: 10px;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-sizing: border-box;
    }
    #customStatusInput {
      background-color: #fff8dc;
      border-color: #f0c36d;
    }
    textarea {
      resize: vertical;
      height: 100px;
    }
    .dropdown-item {
      padding: 6px;
      font-size: 0.9rem;
      cursor: pointer;
    }
    .dropdown-item.viewed {
      background-color: #e0f7fa;
    }
    .status-marked {
      font-weight: bold;
    }
    canvas {
      width: 100%;
      max-width: 400px;
      height: auto;
      display: block;
      margin: 10px auto;
    }
    #chartTextOutput {
      margin-top: 10px;
      text-align: center;
      font-size: 0.9rem;
    }
tr.status-출장완료 { background-color: #e8f5e9; }
tr.status-미출장 { background-color: #ffebee; }
tr.status-미선택 { background-color: #eceff1; }

/* 기타 직접입력 상태 (커스텀) */
tr.status-직접입력 {
  background-color: #fff9c4; /* 연노랑 */
}
    footer {
      display: flex;
      justify-content: center;
      align-items: center;
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      padding: 12px;
      margin-top: 30px;
      font-size: 0.8rem;
      color: #888;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- App Header -->
    <div class="app-header">
      <div style="position: relative; text-align: center;">
        <img src="https://www.gwangjin.go.kr/editorUpload/images/000196/20221007110449234_IXETSNKL.png" alt="광진구 CI" class="header-logo" style="position: absolute; left: 0; top: 50%; transform: translateY(-50%); height: 50px; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));">
        <div class="app-title" onclick="goHome()">진출로 (進出路)</div>
        <div class="app-subtitle">광진구청 출장길 스마트 도우미</div>
      </div>
      
      <!-- Mode Selection -->
      <div class="mode-selector">
        <div class="mode-card active" data-mode="prepare" onclick="selectMode('prepare')">
          <span class="mode-icon">📋</span>
          <div class="mode-title">준비모드</div>
          <div class="mode-desc">출장 준비</div>
        </div>
        
        <div class="mode-card" data-mode="travel" onclick="selectMode('travel')">
          <span class="mode-icon">🚗</span>
          <div class="mode-title">출장모드</div>
          <div class="mode-desc">현장 이동</div>
        </div>
        
        <div class="mode-card" data-mode="record" onclick="selectMode('record')">
          <span class="mode-icon">📝</span>
          <div class="mode-title">기록모드</div>
          <div class="mode-desc">메모 작성</div>
        </div>
        
        <div class="mode-card" data-mode="summary" onclick="selectMode('summary')">
          <span class="mode-icon">📈</span>
          <div class="mode-title">정리모드</div>
          <div class="mode-desc">데이터 정리</div>
        </div>
      </div>
    </div>

    <!-- Prepare Mode -->
    <div id="mode-prepare" class="mode-section active">
      <!-- Step Indicator -->
      <div class="step-indicator">
        <div class="step active" data-step="1" onclick="goToStep(1)" style="cursor: pointer;" title="1단계: 지도 앱 선택">1</div>
        <div class="step-line"></div>
        <div class="step pending" data-step="2" onclick="goToStep(2)" style="cursor: pointer;" title="2단계: 출장지 입력">2</div>
        <div class="step-line"></div>
        <div class="step pending" data-step="3" onclick="goToStep(3)" style="cursor: pointer;" title="3단계: 출장지 확인">3</div>
      </div>
      
      <!-- Step 1: Map Selection -->
      <div class="card" id="step-map">
        <div class="card-header">
          <span class="card-icon">🗺️</span>
          <h3 class="card-title">1단계: 지도 앱 선택</h3>
        </div>
        <div class="card-content">
          <div class="form-group">
            <label class="form-label">사용할 지도 앱을 선택하세요</label>
            
            <!-- Map Selection Buttons -->
            <div class="map-selector map-button-selector" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin-bottom: 20px;">
              <button class="map-option" data-map="naver" onclick="selectMapApp('naver')">
                <div class="map-icon">
                  <img src="https://chrisryugj.github.io/GJRoad/images/nmap.jpg" alt="네이버지도">
                </div>
                <div class="map-name">네이버지도</div>
              </button>
              
              <button class="map-option" data-map="kakao" onclick="selectMapApp('kakao')">
                <div class="map-icon">
                  <img src="https://chrisryugj.github.io/GJRoad/images/kmap.jpg" alt="카카오맵">
                </div>
                <div class="map-name">카카오맵</div>
              </button>
              
              <button class="map-option" data-map="google" onclick="selectMapApp('google')">
                <div class="map-icon">
                  <img src="https://chrisryugj.github.io/GJRoad/images/gmap.jpg" alt="구글지도">
                </div>
                <div class="map-name">구글지도</div>
              </button>
            </div>
            
            <!-- Remember Choice Checkbox -->
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px;">
              <input type="checkbox" id="rememberMap" checked style="width: auto; transform: scale(1.2);">
              <label for="rememberMap" style="margin: 0; font-size: 0.95rem; color: #666;">
                선택한 지도 앱을 기억하기
              </label>
            </div>
            
            <!-- Continue Button -->
            <button id="continueStep2" class="btn btn-primary btn-full" onclick="nextStep(2)" style="display: none;">
              ➡️ 2단계로 계속
            </button>
            
            <!-- Hidden select for compatibility -->
            <select id="mapSelect" style="display: none;">
              <option value="naver">네이버지도</option>
              <option value="kakao">카카오맵</option>
              <option value="google">구글지도</option>
            </select>
          </div>
        </div>
      </div>
      
      <!-- Step 2: Address Input -->
      <div class="card" id="step-input" style="display: none;">
        <div class="card-header">
          <span class="card-icon">🏠</span>
          <h3 class="card-title">2단계: 출장지 입력</h3>
        </div>
        <div class="card-content">
          <!-- Default: Single Address Input -->
          <div class="form-group">
            <label class="form-label">개별 입력</label>
            <input type="text" id="singleAddress" class="form-input" placeholder="주소를 입력하세요">
            <button class="btn btn-success btn-full" onclick="addSingleAddress()" style="margin-top: 10px;">
              ➕ 출장지 추가
            </button>
          </div>
          <div id="added-addresses" class="form-group"></div>
          <button class="btn btn-primary btn-full" onclick="completeAddressInput()" style="display: none;" id="complete-btn">
            ✓ 입력 완료
          </button>
          
          <!-- Alternative Methods -->
          <div style="margin-top: 30px; border-top: 2px solid #f0f0f0; padding-top: 20px;">
            <div class="form-label" style="margin-bottom: 15px;">다른 입력 방법</div>
            <div style="display: grid; gap: 10px;">
              <button class="btn btn-secondary" onclick="toggleInputMethod('file')">
                📁 파일 업로드
              </button>
              <button class="btn btn-secondary" onclick="toggleInputMethod('bulk')">
                📋 일괄 붙여넣기
              </button>
            </div>
          </div>
          
          <!-- File Upload (Hidden by default) -->
          <div id="file-input-section" style="display: none; margin-top: 20px; padding: 20px; background: rgba(0,0,0,0.05); border-radius: 12px;">
            <div class="form-group">
              <label class="form-label">TXT 또는 CSV 파일을 선택하세요</label>
              <input type="file" id="fileUpload" class="form-input" accept=".txt,.csv" onchange="loadAddressFile(event)">
            </div>
          </div>
          
          <!-- Bulk Paste (Hidden by default) -->
          <div id="bulk-input-section" style="display: none; margin-top: 20px; padding: 20px; background: rgba(0,0,0,0.05); border-radius: 12px;">
            <div class="form-group">
              <label class="form-label">주소를 줄 단위로 붙여넣어 주세요</label>
              <textarea id="bulkPaste" class="form-textarea" placeholder="예:
서울시 광진구 구의동 123
서울시 광진구 자양동 456
..."></textarea>
              <button class="btn btn-success btn-full" onclick="addFromTextarea()" style="margin-top: 10px;">
                💾 출장지 저장
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Step 3: Address List Preview -->
      <div class="card" id="step-preview" style="display: none;">
        <div class="card-header">
          <span class="card-icon">📋</span>
          <h3 class="card-title">3단계: 출장지 목록 확인</h3>
        </div>
        <div class="card-content">
          <div id="address-preview-list"></div>
          <div style="margin-top: 20px;">
            <button class="btn btn-primary btn-full" onclick="selectMode('travel')">
              🚗 출장 시작
            </button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Travel Mode -->
    <div id="mode-travel" class="mode-section">
      <div class="card">
        <div class="card-header">
          <span class="card-icon">🚗</span>
          <h3 class="card-title">출장지 목록</h3>
          <button class="btn btn-warning" onclick="showOptimalRouteModal()" style="flex: 1; padding: 10px; margin-left: 10px; max-width: 140px;" title="AI가 최적 경로를 추천합니다">
            🎯 최적경로 추천
          </button>
        </div>
        <div class="card-content">
          <div id="travel-address-list"></div>
        </div>
      </div>
    </div>
    
    <!-- Record Mode -->
    <div id="mode-record" class="mode-section">
      <div class="card" id="record-card">
        <div class="card-header">
          <span class="card-icon">📝</span>
          <h3 class="card-title" id="record-title">기록 작성</h3>
        </div>
        <div class="card-content">
          <!-- Address selection for record mode -->
          <div id="record-address-selector" class="form-group" style="display: none;">
            <label class="form-label">기록할 출장지 선택</label>
            <select id="recordAddressSelect" class="form-select" onchange="selectRecordAddress()">
              <option value="" disabled selected>출장지를 선택하세요</option>
            </select>
            <div style="font-size: 0.85rem; color: #666; margin-top: 5px;">
              💡 기록을 작성할 출장지를 먼저 선택해주세요
            </div>
          </div>
          
          <div class="form-group">
            <label class="form-label">출장 상태 선택</label>
            <select id="recordStatusSelect" class="form-select" onchange="handleRecordStatusChange()">
              <option value="" disabled selected>상태 선택</option>
              <option value="출장완료">출장완료</option>
              <option value="미출장">미출장</option>
              <option value="직접입력">직접입력</option>
            </select>
            <input type="text" id="customRecordStatus" class="form-input" placeholder="상태 직접 입력" style="display: none; margin-top: 10px;">
          </div>
          
          <div class="form-group">
            <label class="form-label">현장 메모</label>
            <textarea id="recordMemo" class="form-textarea" placeholder="현장 특이사항이나 참고 메모를 남기세요"></textarea>
          </div>
          
          <div class="form-group">
            <label class="form-label">현장 사진 (최대 5장)</label>
            <input type="file" id="recordPhotoInput" class="form-input" accept="image/*" multiple onchange="saveRecordPhoto()">
            <div id="recordPhotoContainer" class="photo-grid"></div>
          </div>
          
          <button class="btn btn-success btn-full" onclick="saveRecord()">
            💾 기록 저장
          </button>
        </div>
      </div>
    </div>
    
    <!-- Summary Mode -->
    <div id="mode-summary" class="mode-section">
      <div class="card">
        <div class="card-header">
          <span class="card-icon">📈</span>
          <h3 class="card-title">출장 통계</h3>
        </div>
        <div class="card-content">
          <div id="statsCount" style="text-align: center; font-weight: bold; margin-bottom: 20px; font-size: 1.2rem;"></div>
          <canvas id="statusChart" width="400" height="300"></canvas>
          <div id="chartTextOutput" style="text-align: center; margin-top: 15px; font-size: 0.95rem;"></div>
        </div>
      </div>
      
      <div class="card">
        <div class="card-header">
          <span class="card-icon">📊</span>
          <h3 class="card-title">전체 목록</h3>
        </div>
        <div class="card-content">
          <div id="tableSummary" style="text-align: center; margin-bottom: 20px; font-weight: 600;"></div>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 20px;">
            <button class="btn btn-secondary" onclick="copyTable()">
              📄 복사하기
            </button>
            <button class="btn btn-secondary" onclick="exportText()">
              📁 텍스트 다운로드
            </button>
            <button class="btn btn-success" onclick="exportExcel()">
              📅 엑셀로 다운로드
            </button>
          </div>
          <div style="overflow-x: auto;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
              <thead>
                <tr style="background: rgba(27, 60, 130, 0.1); border-bottom: 2px solid #1b3c82;">
                  <th style="padding: 15px; text-align: center; font-weight: 600; width: 60px;">순서</th>
                  <th style="padding: 15px; text-align: left; font-weight: 600;">주소</th>
                  <th style="padding: 15px; text-align: left; font-weight: 600;">상태</th>
                  <th style="padding: 15px; text-align: left; font-weight: 600;">메모</th>
                  <th style="padding: 15px; text-align: left; font-weight: 600;">사진</th>
                </tr>
              </thead>
              <tbody id="tableBody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <!-- Data Management Section -->
    <div class="card">
      <div class="card-header">
        <span class="card-icon">🗂️</span>
        <h3 class="card-title">데이터 관리</h3>
      </div>
      <div class="card-content">
        <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(27, 60, 130, 0.1); border-radius: 10px;">
          <span style="font-size: 1.1rem; font-weight: 600; color: #1b3c82;">
            🗂️ <span id="total-addresses-bottom">0</span>개 출장지 등록됨
          </span>
        </div>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
          <button class="btn btn-warning" onclick="resetAddressList()">
            🗑️ 목록 초기화
          </button>
          <button class="btn btn-secondary" onclick="showDataOptions()">
            📊 데이터 현황
          </button>
        </div>
      </div>
    </div>

    <!-- Copyright Section -->
    <div style="text-align: center; margin-top: 30px; padding: 20px; border-top: 1px solid rgba(255,255,255,0.2); color: rgba(255,255,255,0.7); font-size: 0.9rem;">
      <p style="margin: 0;">© 2025 진출로 - 출장길 도우미</p>
      <p style="margin: 5px 0 0 0;">(c) 광진구청 가로경관과 개친절한 류주임</p>
    </div>
  </div>
  
  <!-- Hidden elements for compatibility -->
  <div style="display: none;">
    <!-- Legacy elements for compatibility -->
    <input id="addrInput" name="no_autofill" type="text" style="display: none;">
    <div id="memoSection" style="display: none;">
      <textarea id="memoInput"></textarea>
      <input type="file" id="photoInput" accept="image/*" multiple>
      <div id="photoContainer" class="photo-grid"></div>
    </div>
    <div id="customDropdown" style="display: none;"></div>
    <select id="statusSelect" style="display: none;">
      <option value="">선택</option>
      <option value="출장완료">출장완료</option>
      <option value="미출장">미출장</option>
      <option value="직접입력">직접입력</option>
    </select>
    <input id="customStatusInput" type="text" style="display: none;">
</div>

  
  <!-- Data Management Modal -->
  <div id="dataModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">📊 데이터 관리</div>
        <div class="modal-subtitle">출장 기록을 관리하거나 초기화할 수 있습니다</div>
      </div>
      
      <div class="option-grid">
        <div class="option-card" onclick="continueWithExistingData()">
          <div class="option-icon">✅</div>
          <div class="option-title">기존 데이터로 계속하기</div>
          <div class="option-desc">저장된 출장지와 기록을 유지합니다</div>
        </div>
        
        <div class="option-card warning" onclick="showResetOptions()">
          <div class="option-icon">🔄</div>
          <div class="option-title">데이터 초기화</div>
          <div class="option-desc">일부 또는 전체 데이터를 삭제합니다</div>
        </div>
      </div>
      
      <div style="text-align: center;">
        <button class="btn btn-secondary" onclick="closeModal()">
          취소
        </button>
      </div>
    </div>
  </div>
  
  <!-- Reset Options Modal -->
  <div id="resetModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">🔄 데이터 초기화 옵션</div>
        <div class="modal-subtitle">초기화할 데이터 범위를 선택하세요</div>
      </div>
      
      <div class="option-grid">
        <div class="option-card" onclick="showAddressSelector()">
          <div class="option-icon">🎯</div>
          <div class="option-title">선택 초기화</div>
          <div class="option-desc">특정 출장지의 기록만 삭제합니다</div>
        </div>
        
        <div class="option-card danger" onclick="confirmFullReset()">
          <div class="option-icon">💥</div>
          <div class="option-title">전체 초기화</div>
          <div class="option-desc">모든 출장지와 기록을 완전히 삭제합니다</div>
        </div>
      </div>
      
      <div style="display: flex; gap: 10px; justify-content: center;">
        <button class="btn btn-secondary" onclick="showResetOptions()">
          ← 뒤로
        </button>
        <button class="btn btn-secondary" onclick="closeModal()">
          취소
        </button>
      </div>
    </div>
  </div>
  
  <!-- Address Selector Modal -->
  <div id="addressSelectorModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">🎯 출장지 선택</div>
        <div class="modal-subtitle">초기화할 출장지를 선택하세요</div>
      </div>
      
      <div id="address-selector-list" style="max-height: 300px; overflow-y: auto; margin-bottom: 20px;">
        <!-- Address list will be populated here -->
      </div>
      
      <div style="display: flex; gap: 10px; justify-content: center;">
        <button class="btn btn-danger" onclick="resetSelectedAddresses()" id="reset-selected-btn" style="display: none;">
          🗑️ 선택된 항목 삭제
        </button>
        <button class="btn btn-secondary" onclick="showResetOptions()">
          ← 뒤로
        </button>
        <button class="btn btn-secondary" onclick="closeModal()">
          취소
        </button>
      </div>
    </div>
  </div>
  
  <!-- Optimal Route Modal -->
  <div id="optimalRouteModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">🗺️ 최적경로 추천</div>
        <div class="modal-subtitle">AI가 가장 효율적인 출장 경로를 추천해드립니다</div>
      </div>
      
      <div class="form-group" style="margin-bottom: 25px;">
        <label class="form-label">출발지 기준</label>
        <input type="text" id="startLocation" class="form-input" placeholder="출발지 주소를 입력하세요" value="아차산로 400">
        <div style="font-size: 0.85rem; color: #666; margin-top: 5px;">
          📍 현재 위치 또는 자주 출발하는 장소를 입력하세요
        </div>
      </div>
      
      <div style="background: rgba(79, 172, 254, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 25px;">
        <div style="font-size: 0.9rem; color: #1b3c82;">
          <strong>📋 분석할 출장지 (총 <span id="route-address-count">0</span>곳)</strong>
        </div>
        <div id="route-address-preview" style="margin-top: 10px; font-size: 0.85rem; color: #666;">
          <!-- Address list preview will be shown here -->
        </div>
      </div>
      
      <!-- API Key Section for Route Calculation -->
      <div id="route-api-key-section" style="background: #f8f9fa; padding: 15px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #e74c3c;">
        <div style="display: flex; align-items: center; margin-bottom: 10px;">
          <span style="color: #e74c3c; font-weight: bold; margin-right: 10px;">🔐 Gemini API 키</span>
          <span id="route-api-status" style="font-size: 12px; padding: 4px 8px; border-radius: 4px;"></span>
        </div>
        <div style="display: flex; gap: 10px; margin-bottom: 8px;">
          <input type="password" id="route-api-key-input" placeholder="Gemini API 키를 입력하세요" 
                 style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
          <button onclick="saveRouteApiKey()" style="background: #27ae60; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">저장</button>
          <button onclick="testRouteApiKey()" style="background: #3498db; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">테스트</button>
        </div>
        <div style="font-size: 11px; color: #666;">
          • <a href="https://console.cloud.google.com/apis/credentials" target="_blank" style="color: #3498db;">Google Cloud Console</a>에서 무료 발급 • 로컬 저장되며 외부 전송 안됨
        </div>
      </div>
      
      <div style="display: flex; gap: 15px; justify-content: center;">
        <button class="btn btn-success btn-full" onclick="calculateOptimalRoute()" id="calculate-route-btn">
          🎯 고급 경로 최적화 (TSP + AI)
        </button>
      </div>
      
      <div style="text-align: center; margin: 10px 0; font-size: 12px; color: #666;">
        📊 좌표 변환 → 거리 계산 → 군집 분석 → TSP 알고리즘 → AI 검증
      </div>
      
      <div style="display: flex; gap: 10px; justify-content: center; margin-top: 10px;">
        <button class="btn btn-secondary" onclick="compareRouteAlgorithms()" style="font-size: 0.85rem;">
          🔍 알고리즘 비교
        </button>
        <button class="btn btn-secondary" onclick="showManualRouteEditor()" style="font-size: 0.85rem;">
          ✏️ 수동 편집
        </button>
      </div>
      
      <div style="display: flex; gap: 10px; justify-content: center; margin-top: 15px;">
        <button class="btn btn-secondary" onclick="clearCoordinateCache()" style="font-size: 0.85rem;">
          🗑️ 좌표 초기화
        </button>
        <button class="btn btn-secondary" onclick="downloadDebugLogs()" style="font-size: 0.85rem;">
          📋 로그 다운로드
        </button>
        <button class="btn btn-secondary" onclick="closeModal()">
          취소
        </button>
      </div>
      
      <!-- Loading indicator -->
      <div id="route-loading" style="display: none; text-align: center; margin-top: 20px;">
        <div style="font-size: 2rem; animation: spin 1s linear infinite;">⚙️</div>
        <div style="margin-top: 10px; color: #666;">AI가 최적경로를 계산중입니다...</div>
      </div>
    </div>
  </div>
  
  <footer style="text-align: center; padding: 20px; color: rgba(255, 255, 255, 0.7); font-size: 0.9rem;">
    © 2025 광진구청 가로경관과 · 진출로 v2.0
  </footer>
  
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script>
// App State Management
const AppState = {
  currentMode: 'prepare',
  currentStep: 1,
  currentAddress: null,
  inputMethod: null
};

// Data Storage
const originalPhotoMap = {};
let preferredMap = localStorage.getItem("preferredMap") || "naver";
let statusMap = JSON.parse(localStorage.getItem("statusMap")) || {};
let memoMap = JSON.parse(localStorage.getItem("memoMap")) || {};
let photoMap = JSON.parse(localStorage.getItem("photoMap")) || {};
let 주소목록 = JSON.parse(localStorage.getItem("addressList")) || [];
let viewedAddresses = new Set(JSON.parse(localStorage.getItem("viewedAddresses")) || []);

// Route optimization data
let coordinatesCache = JSON.parse(localStorage.getItem("coordinatesCache")) || {};
let optimizedRoute = [];

// Route Optimization Functions
// Haversine formula to calculate distance between two points
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Earth's radius in kilometers
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// Geocode address using multiple services
async function geocodeAddress(address) {
  // Check cache first
  if (coordinatesCache[address]) {
    // Validate cached coordinates
    const cached = coordinatesCache[address];
    if (cached && cached.lat && cached.lng && 
        cached.lat >= 37.4 && cached.lat <= 37.7 && 
        cached.lng >= 126.8 && cached.lng <= 127.3) {
      return cached;
    }
    // Invalid cache, remove it
    delete coordinatesCache[address];
  }

  const cleanAddress = address.replace(/\s*\([^)]*\)\s*$/, '').trim();
  addDebugLog('주소 좌표 변환 시작', { original: address, clean: cleanAddress });
  
  try {
    // Try Kakao Maps API first (most accurate for Korean addresses)
    const kakaoResult = await geocodeWithKakao(cleanAddress);
    if (kakaoResult) {
      coordinatesCache[address] = kakaoResult;
      localStorage.setItem("coordinatesCache", JSON.stringify(coordinatesCache));
      addDebugLog('카카오 API 좌표 변환 성공', { address, coordinates: kakaoResult });
      return kakaoResult;
    }

    // Fallback to OpenStreetMap Nominatim (free, no API key required)
    const nominatimResult = await geocodeWithNominatim(cleanAddress + ' 서울');
    if (nominatimResult) {
      coordinatesCache[address] = nominatimResult;
      localStorage.setItem("coordinatesCache", JSON.stringify(coordinatesCache));
      addDebugLog('Nominatim API 좌표 변환 성공', { address, coordinates: nominatimResult });
      return nominatimResult;
    }
  } catch (error) {
    addDebugLog('API 좌표 변환 실패', { error: error.message });
  }

  // Enhanced address-specific coordinate mapping
  const addressCoords = {
    // 아차산로 권역
    '아차산로': { lat: 37.5385, lng: 127.0823 },
    '아차산로17가길': { lat: 37.5395, lng: 127.0853 },  
    '아차산로32길': { lat: 37.5375, lng: 127.0803 },
    
    // 동일로 권역 (구리 방향)
    '동일로': { lat: 37.5420, lng: 127.0950 },
    '동일로322': { lat: 37.5430, lng: 127.0980 },
    
    // 구의강변 권역
    '구의강변로': { lat: 37.5350, lng: 127.0750 },
    '구의강변로5길': { lat: 37.5340, lng: 127.0740 },
    
    // 뚝섬로 권역
    '뚝섬로': { lat: 37.5300, lng: 127.0700 },
    '뚝섬로62길': { lat: 37.5290, lng: 127.0690 },
    
    // 용마산로 권역 (용마산 쪽)
    '용마산로': { lat: 37.5450, lng: 127.0850 },
    '용마산로21길': { lat: 37.5460, lng: 127.0860 },
    
    // 능동로 권역 (건국대 근처)
    '능동로': { lat: 37.5410, lng: 127.0750 },
    '능동로3다길': { lat: 37.5400, lng: 127.0740 },
    '능동로32길': { lat: 37.5420, lng: 127.0760 }
  };

  // Find best matching coordinate
  let bestMatch = null;
  let bestScore = 0;

  for (const [pattern, coord] of Object.entries(addressCoords)) {
    if (cleanAddress.includes(pattern)) {
      const score = pattern.length; // Longer match = better
      if (score > bestScore) {
        bestMatch = coord;
        bestScore = score;
      }
    }
  }

  if (bestMatch) {
    // Add deterministic offset based on address hash to avoid identical coordinates
    const hash = address.split('').reduce((a, b) => { a = ((a << 5) - a) + b.charCodeAt(0); return a & a }, 0);
    const offset = {
      lat: bestMatch.lat + ((hash % 1000) / 100000) - 0.005,
      lng: bestMatch.lng + (((hash * 17) % 1000) / 100000) - 0.005
    };
    coordinatesCache[address] = offset;
    localStorage.setItem("coordinatesCache", JSON.stringify(coordinatesCache));
    addDebugLog('로컬 매핑으로 좌표 추정', { address, coordinates: offset });
    return offset;
  }

  // Final fallback to Gwangjin District Office with deterministic offset
  const hash = address.split('').reduce((a, b) => { a = ((a << 5) - a) + b.charCodeAt(0); return a & a }, 0);
  const defaultCoord = { 
    lat: 37.5385 + ((hash % 2000) / 100000) - 0.01,
    lng: 127.0823 + (((hash * 13) % 2000) / 100000) - 0.01
  };
  coordinatesCache[address] = defaultCoord;
  localStorage.setItem("coordinatesCache", JSON.stringify(coordinatesCache));
  addDebugLog('기본 좌표로 폴백', { address, coordinates: defaultCoord });
  return defaultCoord;
}

// Kakao Maps API geocoding
async function geocodeWithKakao(address) {
  try {
    // Kakao API key for geocoding
    const KAKAO_API_KEY = '2a882357d1de5851b77f3eaf014862dd';
    
    if (KAKAO_API_KEY === 'YOUR_KAKAO_API_KEY') {
      addDebugLog('카카오 API 키 미설정 - 건너뜀');
      return null;
    }
    
    const response = await fetch(`https://dapi.kakao.com/v2/local/search/address.json?query=${encodeURIComponent(address)}`, {
      headers: { 'Authorization': `KakaoAK ${KAKAO_API_KEY}` }
    });
    
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    
    const data = await response.json();
    if (data.documents && data.documents.length > 0) {
      const result = data.documents[0];
      return {
        lat: parseFloat(result.y || result.address?.y),
        lng: parseFloat(result.x || result.address?.x)
      };
    }
  } catch (error) {
    addDebugLog('카카오 API 오류', { error: error.message });
  }
  return null;
}

// OpenStreetMap Nominatim geocoding (free, no API key required)
async function geocodeWithNominatim(address) {
  try {
    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`, {
      headers: { 'User-Agent': 'Jinculro/1.0' }
    });
    
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    
    const data = await response.json();
    if (data && data.length > 0) {
      return {
        lat: parseFloat(data[0].lat),
        lng: parseFloat(data[0].lon)
      };
    }
  } catch (error) {
    addDebugLog('Nominatim API 오류', { error: error.message });
  }
  return null;
}

// Improved Nearest neighbor with validation and error handling
function optimizeRouteNearestNeighbor(addresses, startAddress) {
  if (!addresses || addresses.length <= 1) {
    addDebugLog('NN 최적화: 주소가 부족함', { addresses });
    return addresses || [];
  }

  // Validate coordinates exist
  const validAddresses = addresses.filter(addr => {
    const coord = coordinatesCache[addr];
    return coord && coord.lat && coord.lng;
  });

  if (validAddresses.length === 0) {
    addDebugLog('NN 최적화: 유효한 좌표 없음');
    return addresses;
  }

  addDebugLog('NN 최적화 시작', { 
    total: addresses.length, 
    valid: validAddresses.length,
    start: startAddress 
  });

  const unvisited = [...validAddresses];
  const route = [];
  let current = startAddress;

  // Remove start from unvisited if it exists
  const startIndex = unvisited.indexOf(startAddress);
  if (startIndex !== -1) {
    unvisited.splice(startIndex, 1);
  }

  let iterations = 0;
  const maxIterations = validAddresses.length * 2; // Safety limit

  while (unvisited.length > 0 && iterations < maxIterations) {
    iterations++;
    let nearestIndex = -1;
    let shortestDistance = Infinity;

    const currentCoord = coordinatesCache[current];
    if (!currentCoord) {
      addDebugLog('NN 최적화: 현재 위치 좌표 없음', { current });
      // Use first unvisited as fallback
      current = unvisited[0];
      continue;
    }

    for (let i = 0; i < unvisited.length; i++) {
      const nextCoord = coordinatesCache[unvisited[i]];
      if (!nextCoord) continue;

      const distance = calculateDistance(
        currentCoord.lat, currentCoord.lng,
        nextCoord.lat, nextCoord.lng
      );

      if (distance < shortestDistance) {
        shortestDistance = distance;
        nearestIndex = i;
      }
    }

    if (nearestIndex === -1) {
      addDebugLog('NN 최적화: 다음 위치를 찾을 수 없음');
      // Add remaining addresses in original order
      route.push(...unvisited);
      break;
    }

    current = unvisited[nearestIndex];
    route.push(current);
    unvisited.splice(nearestIndex, 1);
  }

  addDebugLog('NN 최적화 완료', { 
    originalLength: addresses.length,
    optimizedLength: route.length,
    iterations
  });

  return route;
}

// Calculate total route distance
function calculateTotalDistance(route) {
  if (route.length < 2) return 0;

  let total = 0;
  for (let i = 0; i < route.length - 1; i++) {
    const coord1 = coordinatesCache[route[i]];
    const coord2 = coordinatesCache[route[i + 1]];
    if (coord1 && coord2) {
      total += calculateDistance(coord1.lat, coord1.lng, coord2.lat, coord2.lng);
    }
  }
  return total;
}

// Advanced Route Optimization Algorithms

// Enhanced 2-opt optimization with better performance
function optimize2Opt(route, maxIterations = 200) {
  if (!route || route.length < 4) {
    addDebugLog('2-opt: 루트가 너무 짧음', { length: route?.length });
    return route || [];
  }
  
  addDebugLog('2-opt 최적화 시작', { 
    routeLength: route.length, 
    maxIterations 
  });
  
  let bestRoute = [...route];
  let bestDistance = calculateTotalDistance(bestRoute);
  
  if (bestDistance === 0) {
    addDebugLog('2-opt: 초기 거리 계산 실패');
    return route;
  }
  let improved = true;
  let iteration = 0;
  let improvementsCount = 0;
  const initialDistance = bestDistance;
  
  while (improved && iteration < maxIterations) {
    improved = false;
    
    // Early termination if no significant improvement
    if (iteration > 50 && improvementsCount === 0) break;
    
    for (let i = 1; i < bestRoute.length - 2; i++) {
      for (let j = i + 1; j < bestRoute.length - 1; j++) {
        // Calculate current segment distances
        const currentDist = calculateSegmentDistance(bestRoute, i-1, i, j, j+1);
        
        // Calculate reversed segment distances  
        const reversedDist = calculateReversedSegmentDistance(bestRoute, i-1, i, j, j+1);
        
        if (reversedDist < currentDist) {
          // Apply 2-opt swap
          const newRoute = [...bestRoute];
          const segment = newRoute.slice(i, j + 1).reverse();
          newRoute.splice(i, j - i + 1, ...segment);
          
          bestRoute = newRoute;
          bestDistance = calculateTotalDistance(bestRoute);
          improved = true;
          improvementsCount++;
        }
      }
    }
    iteration++;
  }
  
  const improvement = ((initialDistance - bestDistance) / initialDistance * 100).toFixed(1);
  addDebugLog('2-opt 최적화 완료', { 
    iterations: iteration,
    improvements: improvementsCount,
    initialDistance: initialDistance.toFixed(2) + 'km',
    finalDistance: bestDistance.toFixed(2) + 'km',
    improvement: improvement + '%'
  });
  
  return bestRoute;
}

// Helper function for 2-opt segment distance calculation
function calculateSegmentDistance(route, a, b, c, d) {
  const coords = [route[a], route[b], route[c], route[d]].map(addr => coordinatesCache[addr]);
  if (coords.some(coord => !coord)) return Infinity;
  
  return calculateDistance(coords[0].lat, coords[0].lng, coords[1].lat, coords[1].lng) +
         calculateDistance(coords[2].lat, coords[2].lng, coords[3].lat, coords[3].lng);
}

function calculateReversedSegmentDistance(route, a, b, c, d) {
  const coords = [route[a], route[c], route[b], route[d]].map(addr => coordinatesCache[addr]);
  if (coords.some(coord => !coord)) return Infinity;
  
  return calculateDistance(coords[0].lat, coords[0].lng, coords[1].lat, coords[1].lng) +
         calculateDistance(coords[2].lat, coords[2].lng, coords[3].lat, coords[3].lng);
}

// K-means clustering for grouping nearby addresses
function clusterAddresses(addresses, k = 3) {
  if (addresses.length <= k) return addresses.map((addr, i) => ({address: addr, cluster: i}));
  
  // Initialize centroids randomly
  const coords = addresses.map(addr => coordinatesCache[addr]).filter(c => c);
  if (coords.length === 0) return addresses.map((addr, i) => ({address: addr, cluster: 0}));
  
  let centroids = [];
  for (let i = 0; i < k; i++) {
    const randomIndex = Math.floor(Math.random() * coords.length);
    centroids.push({...coords[randomIndex]});
  }
  
  let assignments = new Array(addresses.length);
  let changed = true;
  let iterations = 0;
  
  while (changed && iterations < 50) {
    changed = false;
    
    // Assign each address to nearest centroid
    for (let i = 0; i < addresses.length; i++) {
      const coord = coordinatesCache[addresses[i]];
      if (!coord) continue;
      
      let minDist = Infinity;
      let bestCluster = 0;
      
      for (let c = 0; c < k; c++) {
        const dist = calculateDistance(coord.lat, coord.lng, centroids[c].lat, centroids[c].lng);
        if (dist < minDist) {
          minDist = dist;
          bestCluster = c;
        }
      }
      
      if (assignments[i] !== bestCluster) {
        assignments[i] = bestCluster;
        changed = true;
      }
    }
    
    // Update centroids
    for (let c = 0; c < k; c++) {
      const clusterAddresses = addresses.filter((_, i) => assignments[i] === c);
      if (clusterAddresses.length > 0) {
        const clusterCoords = clusterAddresses.map(addr => coordinatesCache[addr]).filter(coord => coord);
        if (clusterCoords.length > 0) {
          centroids[c] = {
            lat: clusterCoords.reduce((sum, coord) => sum + coord.lat, 0) / clusterCoords.length,
            lng: clusterCoords.reduce((sum, coord) => sum + coord.lng, 0) / clusterCoords.length
          };
        }
      }
    }
    
    iterations++;
  }
  
  return addresses.map((addr, i) => ({
    address: addr,
    cluster: assignments[i] || 0
  }));
}

// Cluster-first route-second strategy
function optimizeClusterFirstRouteSecond(addresses, startAddress) {
  if (addresses.length <= 2) return addresses;
  
  // Step 1: Cluster addresses
  const k = Math.min(3, Math.ceil(addresses.length / 3));
  const clustered = clusterAddresses(addresses, k);
  
  // Step 2: Find order of clusters based on distance from start
  const startCoord = coordinatesCache[startAddress];
  if (!startCoord) return addresses;
  
  const clusters = {};
  clustered.forEach(item => {
    if (!clusters[item.cluster]) clusters[item.cluster] = [];
    clusters[item.cluster].push(item.address);
  });
  
  // Sort clusters by distance from start
  const clusterKeys = Object.keys(clusters);
  const clusterDistances = clusterKeys.map(key => {
    const clusterAddrs = clusters[key];
    const avgDist = clusterAddrs.reduce((sum, addr) => {
      const coord = coordinatesCache[addr];
      return coord ? sum + calculateDistance(startCoord.lat, startCoord.lng, coord.lat, coord.lng) : sum;
    }, 0) / clusterAddrs.length;
    return {cluster: key, distance: avgDist};
  });
  
  clusterDistances.sort((a, b) => a.distance - b.distance);
  
  // Step 3: Optimize route within each cluster and combine
  let optimizedRoute = [];
  clusterDistances.forEach(({cluster}) => {
    const clusterAddresses = clusters[cluster];
    if (clusterAddresses.length === 1) {
      optimizedRoute.push(...clusterAddresses);
    } else {
      // Use nearest neighbor within cluster
      const clusterRoute = optimizeRouteNearestNeighbor(clusterAddresses, optimizedRoute.length > 0 ? optimizedRoute[optimizedRoute.length - 1] : startAddress);
      optimizedRoute.push(...clusterRoute);
    }
  });
  
  return optimizedRoute;
}

// Genetic Algorithm for TSP (simplified version)
function optimizeRouteGenetic(addresses, startAddress, populationSize = 50, generations = 100) {
  if (addresses.length <= 3) return addresses;
  
  // Create initial population
  let population = [];
  for (let i = 0; i < populationSize; i++) {
    const route = [...addresses];
    // Shuffle array
    for (let j = route.length - 1; j > 0; j--) {
      const k = Math.floor(Math.random() * (j + 1));
      [route[j], route[k]] = [route[k], route[j]];
    }
    population.push(route);
  }
  
  // Evolution loop
  for (let gen = 0; gen < generations; gen++) {
    // Calculate fitness (inverse of distance)
    const fitness = population.map(route => {
      const fullRoute = [startAddress, ...route, startAddress];
      const distance = calculateTotalDistance(fullRoute);
      return distance > 0 ? 1 / distance : 1000;
    });
    
    // Selection and crossover
    const newPopulation = [];
    for (let i = 0; i < populationSize; i++) {
      // Tournament selection
      const parent1 = tournamentSelection(population, fitness);
      const parent2 = tournamentSelection(population, fitness);
      const child = crossover(parent1, parent2);
      mutate(child, 0.02); // 2% mutation rate
      newPopulation.push(child);
    }
    
    population = newPopulation;
  }
  
  // Return best route
  const fitness = population.map(route => {
    const fullRoute = [startAddress, ...route, startAddress];
    const distance = calculateTotalDistance(fullRoute);
    return distance > 0 ? 1 / distance : 1000;
  });
  
  const bestIndex = fitness.indexOf(Math.max(...fitness));
  return population[bestIndex];
}

function tournamentSelection(population, fitness, tournamentSize = 3) {
  let best = Math.floor(Math.random() * population.length);
  for (let i = 1; i < tournamentSize; i++) {
    const competitor = Math.floor(Math.random() * population.length);
    if (fitness[competitor] > fitness[best]) {
      best = competitor;
    }
  }
  return population[best];
}

function crossover(parent1, parent2) {
  const start = Math.floor(Math.random() * parent1.length);
  const end = Math.floor(Math.random() * (parent1.length - start)) + start;
  
  const child = new Array(parent1.length);
  const segment = parent1.slice(start, end + 1);
  
  // Copy segment from parent1
  for (let i = start; i <= end; i++) {
    child[i] = parent1[i];
  }
  
  // Fill remaining positions with parent2 order
  let p2Index = 0;
  for (let i = 0; i < parent1.length; i++) {
    if (child[i] === undefined) {
      while (segment.includes(parent2[p2Index])) {
        p2Index++;
      }
      child[i] = parent2[p2Index];
      p2Index++;
    }
  }
  
  return child;
}

function mutate(route, mutationRate) {
  for (let i = 0; i < route.length; i++) {
    if (Math.random() < mutationRate) {
      const j = Math.floor(Math.random() * route.length);
      [route[i], route[j]] = [route[j], route[i]];
    }
  }
}

// Real-world practical route optimizer for Gwangjin District
function optimizeRouteMultiAlgorithm(addresses, startAddress) {
  if (!addresses || addresses.length <= 1) {
    addDebugLog('다중알고리즘: 주소 부족', { addresses });
    return { method: '주소 부족', route: addresses || [], distance: 0 };
  }

  addDebugLog('다중 알고리즘 최적화 시작', {
    addressCount: addresses.length,
    startAddress,
    hasValidCoords: addresses.filter(addr => coordinatesCache[addr]).length
  });

  const results = [];
  
  try {
    // Algorithm 1: Enhanced Nearest Neighbor
    const nnResult = optimizeRouteNearestNeighbor(addresses, startAddress);
    const nnOptimized = optimize2Opt(nnResult); // Apply 2-opt improvement
    const nnDistance = calculateTotalDistance([startAddress, ...nnOptimized, startAddress]);
    
    if (nnDistance > 0) {
      results.push({
        method: '개선된 Nearest Neighbor + 2-opt',
        route: nnOptimized,
        distance: nnDistance
      });
    }

    // Algorithm 2: Geography-aware Seoul routing  
    const geoResult = optimizeRouteGeographyAware(addresses, startAddress);
    const geoDistance = calculateTotalDistance([startAddress, ...geoResult, startAddress]);
    
    if (geoDistance > 0) {
      results.push({
        method: '지리 기반 최적화 (서울 특화)',
        route: geoResult,
        distance: geoDistance
      });
    }
    
    // Algorithm 3: Sector-based routing
    const sectorResult = optimizeRouteSectorBased(addresses, startAddress);
    const sectorDistance = calculateTotalDistance([startAddress, ...sectorResult, startAddress]);
    
    if (sectorDistance > 0) {
      results.push({
        method: '구역별 순회 (택배 방식)',
        route: sectorResult,
        distance: sectorDistance
      });
    }

    // Algorithm 4: Traffic-aware routing
    if (addresses.length <= 15) { // Only for smaller sets due to complexity
      const trafficResult = optimizeRouteTrafficAware(addresses, startAddress);
      const trafficDistance = calculateTotalDistance([startAddress, ...trafficResult, startAddress]);
      
      if (trafficDistance > 0) {
        results.push({
          method: '교통 고려 최적화',
          route: trafficResult,
          distance: trafficDistance
        });
      }
    }

  } catch (error) {
    addDebugLog('알고리즘 실행 오류', { error: error.message });
  }

  // Filter out invalid results and ensure we have at least one result
  const validResults = results.filter(r => r.distance > 0 && r.route.length > 0);
  
  if (validResults.length === 0) {
    addDebugLog('유효한 최적화 결과 없음 - 원본 순서 반환');
    return {
      method: '최적화 실패 (원본 순서)', 
      route: addresses, 
      distance: calculateTotalDistance([startAddress, ...addresses, startAddress])
    };
  }

  // Return best result
  validResults.sort((a, b) => a.distance - b.distance);
  const bestResult = validResults[0];

  addDebugLog('다중 알고리즘 최적화 결과', {
    totalAlgorithms: results.length,
    validResults: validResults.length,
    bestMethod: bestResult.method,
    bestDistance: bestResult.distance.toFixed(2) + 'km',
    improvement: validResults.length > 1 ? 
      ((validResults[validResults.length-1].distance - bestResult.distance) / validResults[validResults.length-1].distance * 100).toFixed(1) + '%' : 
      'N/A'
  });

  return bestResult;
}

// Geography-aware routing for Seoul metropolitan area
function optimizeRouteGeographyAware(addresses, startAddress) {
  if (addresses.length <= 1) return addresses;
  
  // Seoul geographic sectors based on real geography
  const seoulSectors = {
    // 강북 (Han River North)
    gangbuk: {
      priority: 1,
      keywords: ['종로구', '중구', '용산구', '성동구', '광진구', '동대문구', '중랑구', '성북구', '강북구', '도봉구', '노원구', '은평구', '서대문구', '마포구'],
      center: { lat: 37.5665, lng: 126.9780 }
    },
    // 강남 (Han River South) 
    gangnam: {
      priority: 2,
      keywords: ['강남구', '서초구', '송파구', '강동구'],
      center: { lat: 37.4979, lng: 127.0276 }
    },
    // 강서 (Western Seoul)
    gangseo: {
      priority: 3, 
      keywords: ['양천구', '강서구', '구로구', '금천구', '영등포구', '동작구', '관악구'],
      center: { lat: 37.5172, lng: 126.8506 }
    }
  };
  
  // Categorize addresses by sector
  const sectorizedAddresses = addresses.map(addr => {
    let sector = 'gangbuk'; // Default to gangbuk for Gwangjin area
    let priority = 1;
    
    for (const [sectorName, sectorInfo] of Object.entries(seoulSectors)) {
      if (sectorInfo.keywords.some(keyword => addr.includes(keyword))) {
        sector = sectorName;
        priority = sectorInfo.priority;
        break;
      }
    }
    
    return { address: addr, sector, priority };
  });
  
  // Sort by sector priority, then by distance within sector
  const startCoord = coordinatesCache[startAddress];
  if (!startCoord) return addresses;
  
  sectorizedAddresses.sort((a, b) => {
    // First by sector priority
    if (a.priority !== b.priority) {
      return a.priority - b.priority;
    }
    
    // Then by distance from start within same sector
    const coordA = coordinatesCache[a.address];
    const coordB = coordinatesCache[b.address];
    
    if (!coordA || !coordB) return 0;
    
    const distA = calculateDistance(startCoord.lat, startCoord.lng, coordA.lat, coordA.lng);
    const distB = calculateDistance(startCoord.lat, startCoord.lng, coordB.lat, coordB.lng);
    
    return distA - distB;
  });
  
  return sectorizedAddresses.map(item => item.address);
}

// Sector-based routing like delivery services
function optimizeRouteSectorBased(addresses, startAddress) {
  if (addresses.length <= 1) return addresses;
  
  // Define Gwangjin district micro-sectors
  const microSectors = {
    // 구의권 (Gui area)
    gui: {
      keywords: ['구의', '광장동', '자양동'],
      priority: 1,
      description: '한강변 지역'
    },
    // 능동권 (Neungdong area) 
    neungdong: {
      keywords: ['능동', '화양동'],
      priority: 2,
      description: '건국대 주변'
    },
    // 중곡권 (Junggok area)
    junggok: {
      keywords: ['중곡동', '용마산'],
      priority: 3,
      description: '용마산 일대'
    }
  };
  
  // Group addresses by micro-sector
  const sectorGroups = { gui: [], neungdong: [], junggok: [], others: [] };
  
  addresses.forEach(addr => {
    let assigned = false;
    for (const [sector, info] of Object.entries(microSectors)) {
      if (info.keywords.some(keyword => addr.includes(keyword))) {
        sectorGroups[sector].push(addr);
        assigned = true;
        break;
      }
    }
    if (!assigned) {
      sectorGroups.others.push(addr);
    }
  });
  
  // Optimize within each sector, then combine
  let optimizedRoute = [];
  const sectorOrder = ['gui', 'neungdong', 'junggok', 'others'];
  
  sectorOrder.forEach(sector => {
    if (sectorGroups[sector].length > 0) {
      if (sectorGroups[sector].length === 1) {
        optimizedRoute.push(...sectorGroups[sector]);
      } else {
        const lastPoint = optimizedRoute.length > 0 ? optimizedRoute[optimizedRoute.length - 1] : startAddress;
        const sectorOptimized = optimizeRouteNearestNeighbor(sectorGroups[sector], lastPoint);
        optimizedRoute.push(...sectorOptimized);
      }
    }
  });
  
  return optimizedRoute;
}

// Traffic-aware routing considering Seoul traffic patterns
function optimizeRouteTrafficAware(addresses, startAddress) {
  if (addresses.length <= 1) return addresses;
  
  // Seoul traffic flow patterns
  const trafficPenalties = {
    // Major arterial roads (higher penalty during rush hours)
    arterial: ['동일로', '천호대로', '광나루로', '강변북로'],
    // Secondary roads (medium penalty)  
    secondary: ['아차산로', '뚝섬로'],
    // Local roads (low penalty)
    local: ['능동로', '구의강변로', '용마산로']
  };
  
  // Calculate traffic penalty for each address
  const addressesWithPenalty = addresses.map(addr => {
    let penalty = 1.0; // Base penalty
    
    if (trafficPenalties.arterial.some(road => addr.includes(road))) {
      penalty = 1.5; // 50% penalty for arterial roads
    } else if (trafficPenalties.secondary.some(road => addr.includes(road))) {
      penalty = 1.2; // 20% penalty for secondary roads
    } else if (trafficPenalties.local.some(road => addr.includes(road))) {
      penalty = 1.1; // 10% penalty for local roads
    }
    
    return { address: addr, penalty };
  });
  
  // Sort by traffic penalty (prefer low-penalty roads first)
  const startCoord = coordinatesCache[startAddress];
  if (!startCoord) return addresses.map(item => typeof item === 'object' ? item.address : item);
  
  addressesWithPenalty.sort((a, b) => {
    const coordA = coordinatesCache[a.address];
    const coordB = coordinatesCache[b.address];
    
    if (!coordA || !coordB) return 0;
    
    const distA = calculateDistance(startCoord.lat, startCoord.lng, coordA.lat, coordA.lng) * a.penalty;
    const distB = calculateDistance(startCoord.lat, startCoord.lng, coordB.lat, coordB.lng) * b.penalty;
    
    return distA - distB;
  });
  
  return addressesWithPenalty.map(item => item.address);
}

// Hierarchical routing following road hierarchy (arterial -> collector -> local)
function optimizeRouteHierarchical(addresses, startAddress) {
  if (addresses.length <= 1) return addresses;
  
  // Road hierarchy classification
  const roadHierarchy = {
    arterial: {
      roads: ['동일로', '천호대로', '광나루로', '강변북로'],
      priority: 1,
      description: '간선도로'
    },
    collector: {
      roads: ['아차산로', '뚝섬로', '구의강변로'],
      priority: 2, 
      description: '집산도로'
    },
    local: {
      roads: ['능동로', '용마산로', '자양', '구의', '중곡'],
      priority: 3,
      description: '국지도로'
    }
  };
  
  // Classify addresses by road hierarchy
  const hierarchicalGroups = { arterial: [], collector: [], local: [] };
  
  addresses.forEach(addr => {
    let assigned = false;
    for (const [category, info] of Object.entries(roadHierarchy)) {
      if (info.roads.some(road => addr.includes(road))) {
        hierarchicalGroups[category].push(addr);
        assigned = true;
        break;
      }
    }
    if (!assigned) {
      hierarchicalGroups.local.push(addr); // Default to local
    }
  });
  
  // Route in hierarchical order: arterial -> collector -> local
  let hierarchicalRoute = [];
  const hierarchyOrder = ['arterial', 'collector', 'local'];
  
  hierarchyOrder.forEach(level => {
    if (hierarchicalGroups[level].length > 0) {
      const lastPoint = hierarchicalRoute.length > 0 ? hierarchicalRoute[hierarchicalRoute.length - 1] : startAddress;
      
      if (hierarchicalGroups[level].length === 1) {
        hierarchicalRoute.push(...hierarchicalGroups[level]);
      } else {
        const levelOptimized = optimizeRouteNearestNeighbor(hierarchicalGroups[level], lastPoint);
        hierarchicalRoute.push(...levelOptimized);
      }
    }
  });
  
  return hierarchicalRoute;
}

// Mode Management Functions
function selectMode(mode) {
  try {
    console.log('selectMode 호출됨:', mode);
    
    // Update UI
    document.querySelectorAll('.mode-card').forEach(card => {
      card.classList.remove('active');
    });
    
    const modeCard = document.querySelector(`[data-mode="${mode}"]`);
    if (modeCard) {
      modeCard.classList.add('active');
    } else {
      console.error('모드 카드를 찾을 수 없음:', mode);
    }
    
    // Show/Hide sections
    document.querySelectorAll('.mode-section').forEach(section => {
      section.classList.remove('active');
    });
    
    const modeSection = document.getElementById(`mode-${mode}`);
    if (modeSection) {
      modeSection.classList.add('active');
    } else {
      console.error('모드 섹션을 찾을 수 없음:', `mode-${mode}`);
    }
    
    AppState.currentMode = mode;
  } catch (error) {
    console.error('selectMode 오류:', error);
    alert('모드 변경 중 오류가 발생했습니다: ' + error.message);
  }
  
  // Initialize mode-specific content
  if (mode === 'travel') {
    updateTravelMode();
  } else if (mode === 'summary') {
    // Add small delay to ensure DOM is ready
    setTimeout(() => {
      updateSummaryMode();
    }, 100);
  } else if (mode === 'prepare') {
    // Show selected map app if exists
    updateMapSelection();
  } else if (mode === 'record') {
    initializeRecordMode();
  }
}

function goHome() {
  try {
    console.log('goHome 호출됨');
    
    // Reset to initial prepare mode state
    AppState.currentStep = 1;
    AppState.currentAddress = null;
    
    selectMode('prepare');
    
    // Reset step indicator
    updateStepIndicator();
    
    // Show step 1, hide others
    const stepMap = document.getElementById('step-map');
    const stepInput = document.getElementById('step-input');
    const stepPreview = document.getElementById('step-preview');
    
    if (stepMap) stepMap.style.display = 'block';
    if (stepInput) stepInput.style.display = 'none';
    if (stepPreview) stepPreview.style.display = 'none';
    
    // Hide input sections safely
    const fileSection = document.getElementById('file-input-section');
    const bulkSection = document.getElementById('bulk-input-section');
    if (fileSection) fileSection.style.display = 'none';
    if (bulkSection) bulkSection.style.display = 'none';
    
    console.log('홈으로 이동 완료');
  } catch (error) {
    console.error('goHome 오류:', error);
    alert('홈으로 이동 중 오류가 발생했습니다: ' + error.message);
  }
}

// Map Selection Functions
function selectMapApp(mapType) {
  try {
    console.log('selectMapApp 호출됨:', mapType);
    
    preferredMap = mapType;
    
    // Update UI with clear feedback
    document.querySelectorAll('.map-option').forEach(btn => {
      btn.classList.remove('selected');
    });
    
    const selectedBtn = document.querySelector(`[data-map="${mapType}"]`);
    if (selectedBtn) {
      selectedBtn.classList.add('selected');
      
      // Visual feedback with animation
      selectedBtn.style.transform = 'scale(0.95)';
      setTimeout(() => {
        selectedBtn.style.transform = 'translateY(-3px)';
      }, 100);
    } else {
      console.error('지도 버튼을 찾을 수 없음:', mapType);
    }
    
    // Update hidden select for compatibility
    const mapSelect = document.getElementById('mapSelect');
    if (mapSelect) {
      mapSelect.value = mapType;
    }
    
    // Show continue button with animation
    const continueBtn = document.getElementById('continueStep2');
    if (continueBtn) {
      continueBtn.style.display = 'block';
      continueBtn.style.opacity = '0';
      continueBtn.style.transform = 'translateY(10px)';
      
      setTimeout(() => {
        continueBtn.style.transition = 'all 0.3s ease';
        continueBtn.style.opacity = '1';
        continueBtn.style.transform = 'translateY(0)';
      }, 50);
    } else {
      console.error('계속하기 버튼을 찾을 수 없음');
    }
    
    // Save preference if checkbox is checked
    const rememberCheckbox = document.getElementById('rememberMap');
    if (rememberCheckbox && rememberCheckbox.checked) {
      localStorage.setItem('preferredMap', preferredMap);
    }
  } catch (error) {
    console.error('selectMapApp 오류:', error);
    alert('지도 앱 선택 중 오류가 발생했습니다: ' + error.message);
  }
  
  console.log(`지도 앱 선택됨: ${mapType}`); // 디버깅용
}

function updateMapSelection() {
  // Restore selected map
  if (preferredMap) {
    document.querySelectorAll('.map-option').forEach(btn => {
      btn.classList.remove('selected');
    });
    const selectedBtn = document.querySelector(`[data-map="${preferredMap}"]`);
    if (selectedBtn) {
      selectedBtn.classList.add('selected');
      
      // Show continue button if map is already selected
      const continueBtn = document.getElementById('continueStep2');
      if (continueBtn) {
        continueBtn.style.display = 'block';
      }
    }
  }
}

// Step Management for Prepare Mode
function goToStep(step) {
  // 단계별 클릭으로 이동
  nextStep(step);
}

function nextStep(step) {
  try {
    console.log('nextStep 호출됨:', step);
    
    AppState.currentStep = step;
    updateStepIndicator();
    
    // 모든 단계 숨기기
    const stepMap = document.getElementById('step-map');
    const stepInput = document.getElementById('step-input');
    const stepPreview = document.getElementById('step-preview');
    
    if (stepMap) stepMap.style.display = 'none';
    if (stepInput) stepInput.style.display = 'none';
    if (stepPreview) stepPreview.style.display = 'none';
    
    // 2단계 내부 섹션들도 숨기기
    const fileSection = document.getElementById('file-input-section');
    const bulkSection = document.getElementById('bulk-input-section');
    if (fileSection) fileSection.style.display = 'none';
    if (bulkSection) bulkSection.style.display = 'none';
    
    if (step === 1 && stepMap) {
      stepMap.style.display = 'block';
    } else if (step === 2 && stepInput) {
      stepInput.style.display = 'block';
    } else if (step === 3 && stepPreview) {
      stepPreview.style.display = 'block';
      updateAddressPreview();
    }
  } catch (error) {
    console.error('nextStep 오류:', error);
    alert('단계 이동 중 오류가 발생했습니다: ' + error.message);
  }
}

function updateStepIndicator() {
  document.querySelectorAll('.step').forEach((step, index) => {
    const stepNum = index + 1;
    if (stepNum < AppState.currentStep) {
      step.className = 'step completed';
    } else if (stepNum === AppState.currentStep) {
      step.className = 'step active';
    } else {
      step.className = 'step pending';
    }
  });
  
  document.querySelectorAll('.step-line').forEach((line, index) => {
    if (index + 1 < AppState.currentStep) {
      line.classList.add('completed');
    } else {
      line.classList.remove('completed');
    }
  });
}

// Address Input Methods
function toggleInputMethod(method) {
  const fileSection = document.getElementById('file-input-section');
  const bulkSection = document.getElementById('bulk-input-section');
  
  // Hide all sections first
  fileSection.style.display = 'none';
  bulkSection.style.display = 'none';
  
  // Show selected section
  if (method === 'file') {
    fileSection.style.display = 'block';
  } else if (method === 'bulk') {
    bulkSection.style.display = 'block';
  }
}

function addSingleAddress() {
  try {
    console.log('addSingleAddress 호출됨');
    
    const input = document.getElementById('singleAddress');
    if (!input) {
      console.error('singleAddress 입력 필드를 찾을 수 없음');
      alert('주소 입력 필드를 찾을 수 없습니다.');
      return;
    }
    
    const address = input.value.trim();
    
    if (!address) {
      alert('주소를 입력해주세요.');
      return;
    }
    
    if (주소목록.includes(address)) {
      alert('이미 추가된 주소입니다.');
      return;
    }
    
    주소목록.push(address);
    saveAddressList();
    updateDataStatus();
    
    // Update UI
    updateAddedAddresses();
    input.value = '';
    
    // Show complete button
    document.getElementById('complete-btn').style.display = 'block';
    
    console.log('주소 추가 완료:', address);
  } catch (error) {
    console.error('addSingleAddress 오류:', error);
    alert('주소 추가 중 오류가 발생했습니다: ' + error.message);
  }
}

function updateAddedAddresses() {
  const container = document.getElementById('added-addresses');
  if (!container) return;
  
  container.innerHTML = 주소목록.map((addr, index) => `
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: rgba(79, 172, 254, 0.1); border-radius: 8px; margin-bottom: 5px;">
      <span>${addr}</span>
      <button onclick="removeAddress(${index})" style="background: #fa709a; color: white; border: none; border-radius: 5px; padding: 5px 10px; cursor: pointer;">삭제</button>
    </div>
  `).join('');
}

function removeAddress(index) {
  주소목록.splice(index, 1);
  saveAddressList();
  updateDataStatus();
  updateAddedAddresses();
  
  if (주소목록.length === 0) {
    document.getElementById('complete-btn').style.display = 'none';
  }
}

function completeAddressInput() {
  if (주소목록.length === 0) {
    alert('최소 하나의 주소를 입력해주세요.');
    return;
  }
  nextStep(3);
}

function updateAddressPreview() {
  const container = document.getElementById('address-preview-list');
  if (!container) return;
  
  if (주소목록.length === 0) {
    container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">등록된 출장지가 없습니다.</p>';
    return;
  }
  
  container.innerHTML = 주소목록.map((addr, index) => {
    const status = statusMap[addr] || '미선택';
    const statusClass = status === '출장완료' ? 'completed' : status === '미출장' ? 'pending' : 'none';
    
    return `
      <div class="address-card ${status === '출장완료' ? 'completed' : status === '미출장' ? 'pending' : ''}">
        <div class="address-title">
          <span>
            <span style="display: inline-block; width: 25px; height: 25px; background: #1b3c82; color: white; border-radius: 50%; text-align: center; line-height: 25px; font-weight: bold; margin-right: 10px; font-size: 0.8rem;">
              ${index + 1}
            </span>
            ${addr}
          </span>
          <span class="address-status status-${statusClass}">${status}</span>
        </div>
      </div>
    `;
  }).join('');
}

// Travel Mode Functions
function updateTravelMode() {
  const container = document.getElementById('travel-address-list');
  if (!container) return;
  
  if (주소목록.length === 0) {
    container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">먼저 준비모드에서 출장지를 등록해주세요.</p>';
    return;
  }

  // Use optimized route if available, otherwise use original order
  const displayOrder = optimizedRoute.length > 0 ? optimizedRoute : 주소목록;
  const isOptimized = optimizedRoute.length > 0;

  let html = '';
  
  // Show optimization status
  if (isOptimized) {
    html += `
      <div style="background: rgba(79, 172, 254, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #4facfe;">
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
          <span style="font-size: 1.1rem;">🎯</span>
          <span style="font-weight: bold; color: #1b3c82;">최적화된 방문 순서</span>
          <button onclick="clearOptimizedRoute()" style="background: none; border: 1px solid #ccc; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; cursor: pointer;">원래 순서로</button>
        </div>
        <div style="font-size: 0.9rem; color: #666;">
          효율적인 경로로 재정렬되었습니다. 번호 순서대로 방문하세요.
        </div>
      </div>
    `;
  }
  
  html += displayOrder.map((addr, index) => {
    const status = statusMap[addr] || '미선택';
    const statusClass = status === '출장완료' ? 'completed' : status === '미출장' ? 'pending' : 'none';
    const originalIndex = 주소목록.indexOf(addr);
    
    // Show route optimization indicator
    const orderIndicator = isOptimized ? 
      `<div style="position: absolute; top: -8px; right: -8px; background: #4facfe; color: white; border-radius: 50%; width: 20px; height: 20px; font-size: 0.7rem; display: flex; align-items: center; justify-content: center; font-weight: bold;">
        ${originalIndex + 1}
      </div>` : '';
    
    return `
      <div class="address-card ${status === '출장완료' ? 'completed' : status === '미출장' ? 'pending' : ''}" onclick="openAddressActions('${addr}')" style="position: relative;">
        ${orderIndicator}
        <div class="address-title">
          <span style="font-size: 1.1rem;">
            <span style="display: inline-block; width: 30px; height: 30px; background: ${isOptimized ? '#4facfe' : '#1b3c82'}; color: white; border-radius: 50%; text-align: center; line-height: 30px; font-weight: bold; margin-right: 10px; font-size: 0.9rem;">
              ${index + 1}
            </span>
            ${addr}
          </span>
          <span class="address-status status-${statusClass}">${status}</span>
        </div>
        <div style="margin-top: 10px; display: flex; gap: 10px;">
          <button class="btn btn-primary" onclick="event.stopPropagation(); openMapForAddress('${addr}')" style="flex: 1; padding: 10px;">
            🗺️ 지도 열기
          </button>
          <button class="btn btn-secondary" onclick="event.stopPropagation(); openRecordMode('${addr}')" style="flex: 1; padding: 10px;">
            📝 기록하기
          </button>
        </div>
      </div>
    `;
  }).join('');

  container.innerHTML = html;
}

// Clear optimized route and return to original order
function clearOptimizedRoute() {
  optimizedRoute = [];
  updateTravelMode();
}

// Clear coordinate cache to force re-geocoding
function clearCoordinateCache() {
  coordinatesCache = {};
  localStorage.removeItem("coordinatesCache");
  alert('좌표 캐시가 초기화되었습니다. 다음 최적화 시 새로운 좌표로 계산됩니다.');
}

function openMapForAddress(address) {
  const baseAddr = address.replace(/\s*\([^)]*\)\s*$/, '').trim();
  const encodedAddr = encodeURIComponent(baseAddr);
  
  // Mobile device detection
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  const isAndroid = /Android/i.test(navigator.userAgent);
  const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
  
  if (isMobile) {
    // Mobile: Use preferred map directly
    tryOpenPreferredMap(baseAddr, encodedAddr, preferredMap, isAndroid, isIOS);
  } else {
    // Desktop: Direct web link
    openWebMap(baseAddr, encodedAddr);
  }
  
  // Mark as viewed
  viewedAddresses.add(address);
  saveViewedAddresses();
}

function tryOpenPreferredMap(baseAddr, encodedAddr, preferredMap, isAndroid, isIOS) {
  let appUrl = '';
  let webUrl = '';
  
  // Default to naver if no preferred map is set
  const mapToUse = preferredMap || 'naver';
  
  if (mapToUse === 'naver') {
    if (isAndroid) {
      appUrl = `intent://search?query=${encodedAddr}#Intent;scheme=nmap;action=android.intent.action.VIEW;category=android.intent.category.BROWSABLE;package=com.nhn.android.nmap;end`;
    } else if (isIOS) {
      appUrl = `nmap://search?query=${encodedAddr}`;
    }
    webUrl = `https://map.naver.com/v5/search/${encodedAddr}`;
  } else if (mapToUse === 'kakao') {
    if (isAndroid) {
      appUrl = `intent://search?q=${encodedAddr}#Intent;scheme=kakaomap;action=android.intent.action.VIEW;category=android.intent.category.BROWSABLE;package=net.daum.android.map;end`;
    } else if (isIOS) {
      appUrl = `kakaomap://search?q=${encodedAddr}`;
    }
    webUrl = `https://map.kakao.com/?q=${encodedAddr}`;
  } else if (mapToUse === 'google') {
    if (isAndroid) {
      appUrl = `geo:0,0?q=${encodedAddr}`;
    } else if (isIOS) {
      appUrl = `comgooglemaps://?q=${encodedAddr}`;
    }
    webUrl = `https://www.google.com/maps/search/?api=1&query=${encodedAddr}`;
  }

  if (appUrl) {
    tryOpenMapApp(appUrl, webUrl, '');
  } else {
    window.open(webUrl, '_blank');
  }
}

function showMapAppModal(address, baseAddr, encodedAddr, isAndroid, isIOS) {
  const modalHtml = `
    <div id="mapAppModal" class="modal show">
      <div class="modal-content" style="max-width: 400px;">
        <div class="modal-header">
          <div class="modal-title">🗺️ 지도 앱 선택</div>
          <div class="modal-subtitle">${baseAddr}</div>
        </div>
        
        <div style="display: grid; gap: 12px; margin-bottom: 20px;">
          ${createMapAppButton('naver', '네이버 지도', '#00C73C', baseAddr, encodedAddr, isAndroid, isIOS)}
          ${createMapAppButton('kakao', '카카오맵', '#FEE500', baseAddr, encodedAddr, isAndroid, isIOS)}
          ${createMapAppButton('google', '구글 지도', '#4285F4', baseAddr, encodedAddr, isAndroid, isIOS)}
          
          <button onclick="openWebMap('${baseAddr}', '${encodedAddr}'); closeMapAppModal();" 
                  style="background: #666; color: white; border: none; padding: 12px; border-radius: 8px; cursor: pointer; font-size: 0.9rem;">
            🌐 웹에서 열기 (기본: ${preferredMap === 'naver' ? '네이버' : preferredMap === 'kakao' ? '카카오' : preferredMap === 'google' ? '구글' : '네이버'})
          </button>
        </div>
        
        <div style="background: rgba(255,193,7,0.1); padding: 12px; border-radius: 6px; font-size: 0.8rem; color: #856404; margin-bottom: 15px;">
          💡 앱이 설치되지 않은 경우 자동으로 웹으로 연결됩니다.
        </div>
        
        <div style="text-align: center;">
          <button class="btn btn-secondary" onclick="closeMapAppModal()">
            취소
          </button>
        </div>
      </div>
    </div>
  `;

  // Remove existing modal if any
  const existingModal = document.getElementById('mapAppModal');
  if (existingModal) {
    document.body.removeChild(existingModal);
  }

  // Add new modal to body
  document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function createMapAppButton(mapType, mapName, color, baseAddr, encodedAddr, isAndroid, isIOS) {
  let appUrl = '';
  let webUrl = '';
  let storeUrl = '';
  
  if (mapType === 'naver') {
    // 네이버 지도 앱 URL 개선
    if (isAndroid) {
      appUrl = `intent://search?query=${encodedAddr}#Intent;scheme=nmap;action=android.intent.action.VIEW;category=android.intent.category.BROWSABLE;package=com.nhn.android.nmap;end`;
      storeUrl = 'https://play.google.com/store/apps/details?id=com.nhn.android.nmap';
    } else if (isIOS) {
      appUrl = `nmap://search?query=${encodedAddr}`;
      storeUrl = 'https://apps.apple.com/kr/app/naver-map-navigation/id311867728';
    }
    webUrl = `https://map.naver.com/v5/search/${encodedAddr}`;
  } else if (mapType === 'kakao') {
    if (isAndroid) {
      appUrl = `intent://search?q=${encodedAddr}#Intent;scheme=kakaomap;action=android.intent.action.VIEW;category=android.intent.category.BROWSABLE;package=net.daum.android.map;end`;
      storeUrl = 'https://play.google.com/store/apps/details?id=net.daum.android.map';
    } else if (isIOS) {
      appUrl = `kakaomap://search?q=${encodedAddr}`;
      storeUrl = 'https://apps.apple.com/kr/app/kakao-map/id304608425';
    }
    webUrl = `https://map.kakao.com/?q=${encodedAddr}`;
  } else if (mapType === 'google') {
    if (isAndroid) {
      appUrl = `geo:0,0?q=${encodedAddr}`;
      storeUrl = 'https://play.google.com/store/apps/details?id=com.google.android.apps.maps';
    } else if (isIOS) {
      appUrl = `comgooglemaps://?q=${encodedAddr}`;
      storeUrl = 'https://apps.apple.com/us/app/google-maps/id585027354';
    }
    webUrl = `https://www.google.com/maps/search/?api=1&query=${encodedAddr}`;
  }

  return `
    <button onclick="tryOpenMapApp('${appUrl}', '${webUrl}', '${storeUrl}'); closeMapAppModal();" 
            style="background: ${color}; color: ${mapType === 'kakao' ? 'black' : 'white'}; border: none; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 0.9rem;">
      📱 ${mapName} 앱으로 열기
    </button>
  `;
}

function tryOpenMapApp(appUrl, webUrl, storeUrl) {
  if (!appUrl) {
    window.open(webUrl, '_blank');
    return;
  }

  // Try to open app
  const startTime = Date.now();
  const timeout = 2000;
  
  // Create a hidden iframe to trigger app
  const iframe = document.createElement('iframe');
  iframe.style.display = 'none';
  iframe.src = appUrl;
  document.body.appendChild(iframe);
  
  // Set up fallback timer
  const timer = setTimeout(() => {
    document.body.removeChild(iframe);
    // App didn't open, fallback to web
    window.open(webUrl, '_blank');
  }, timeout);
  
  // Check if user switched to app (page becomes hidden)
  const handleVisibilityChange = () => {
    if (document.hidden) {
      clearTimeout(timer);
      document.body.removeChild(iframe);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    }
  };
  
  document.addEventListener('visibilitychange', handleVisibilityChange);
  
  // For iOS, also try window.location as fallback
  if (appUrl.startsWith('nmap://') || appUrl.startsWith('kakaomap://') || appUrl.startsWith('comgooglemaps://')) {
    setTimeout(() => {
      try {
        window.location.href = appUrl;
      } catch (e) {
        // Silent fail
      }
    }, 500);
  }
}

function openWebMap(baseAddr, encodedAddr) {
  let webUrl = '';
  
  if (preferredMap === 'naver' || !preferredMap) {
    webUrl = `https://map.naver.com/v5/search/${encodedAddr}`;
  } else if (preferredMap === 'kakao') {
    webUrl = `https://map.kakao.com/?q=${encodedAddr}`;
  } else if (preferredMap === 'google') {
    webUrl = `https://www.google.com/maps/search/?api=1&query=${encodedAddr}`;
  }
  
  window.open(webUrl, '_blank');
}

function closeMapAppModal() {
  const modal = document.getElementById('mapAppModal');
  if (modal) {
    document.body.removeChild(modal);
  }
}

function openRecordMode(address) {
  AppState.currentAddress = address;
  selectMode('record');
  
  // Hide address selector when coming from specific address
  document.getElementById('record-address-selector').style.display = 'none';
  
  // Pre-fill record form
  document.getElementById('record-title').textContent = `${address} - 기록 작성`;
  document.getElementById('recordStatusSelect').value = statusMap[address] || '';
  document.getElementById('recordMemo').value = memoMap[address] || '';
  
  // Handle custom status
  const status = statusMap[address] || '';
  if (!['출장완료', '미출장', ''].includes(status)) {
    document.getElementById('recordStatusSelect').value = '직접입력';
    document.getElementById('customRecordStatus').style.display = 'block';
    document.getElementById('customRecordStatus').value = status;
  }
  
  renderRecordPhotos();
}

// Initialize record mode when accessed directly
function initializeRecordMode() {
  // Check if we have a current address
  if (!AppState.currentAddress) {
    // Show address selector
    document.getElementById('record-address-selector').style.display = 'block';
    document.getElementById('record-title').textContent = '기록 작성';
    
    // Populate address dropdown
    const addressSelect = document.getElementById('recordAddressSelect');
    addressSelect.innerHTML = '<option value="" disabled selected>출장지를 선택하세요</option>';
    
    주소목록.forEach(address => {
      const option = document.createElement('option');
      option.value = address;
      option.textContent = address;
      addressSelect.appendChild(option);
    });
    
    // Clear form
    document.getElementById('recordStatusSelect').value = '';
    document.getElementById('recordMemo').value = '';
    document.getElementById('customRecordStatus').style.display = 'none';
    document.getElementById('recordPhotoContainer').innerHTML = '';
  } else {
    // Address already selected, hide selector
    document.getElementById('record-address-selector').style.display = 'none';
  }
}

// Handle address selection in record mode
function selectRecordAddress() {
  const selectedAddress = document.getElementById('recordAddressSelect').value;
  if (selectedAddress) {
    AppState.currentAddress = selectedAddress;
    
    // Hide address selector
    document.getElementById('record-address-selector').style.display = 'none';
    
    // Update title and pre-fill form
    document.getElementById('record-title').textContent = `${selectedAddress} - 기록 작성`;
    document.getElementById('recordStatusSelect').value = statusMap[selectedAddress] || '';
    document.getElementById('recordMemo').value = memoMap[selectedAddress] || '';
    
    // Handle custom status
    const status = statusMap[selectedAddress] || '';
    if (!['출장완료', '미출장', ''].includes(status)) {
      document.getElementById('recordStatusSelect').value = '직접입력';
      document.getElementById('customRecordStatus').style.display = 'block';
      document.getElementById('customRecordStatus').value = status;
    } else {
      document.getElementById('customRecordStatus').style.display = 'none';
    }
    
    renderRecordPhotos();
  }
}

// Record Mode Functions
function handleRecordStatusChange() {
  const select = document.getElementById('recordStatusSelect');
  const customInput = document.getElementById('customRecordStatus');
  
  if (select.value === '직접입력') {
    customInput.style.display = 'block';
  } else {
    customInput.style.display = 'none';
  }
}

function saveRecord() {
  if (!AppState.currentAddress) return;
  
  const statusSelect = document.getElementById('recordStatusSelect');
  const customStatus = document.getElementById('customRecordStatus');
  const memo = document.getElementById('recordMemo').value.trim();
  
  let status = statusSelect.value;
  if (status === '직접입력') {
    status = customStatus.value.trim().substring(0, 100);
  }
  
  // Save status
  if (status) {
    statusMap[AppState.currentAddress] = status;
  } else {
    delete statusMap[AppState.currentAddress];
  }
  
  // Save memo with timestamp
  if (memo) {
    const now = new Date();
    const datePrefix = now.toISOString().slice(0, 10);
    const timePrefix = now.toTimeString().slice(0, 5);
    memoMap[AppState.currentAddress] = `${datePrefix} ${timePrefix} - ${memo}`;
  } else {
    delete memoMap[AppState.currentAddress];
  }
  
  // Save to localStorage
  localStorage.setItem('statusMap', JSON.stringify(statusMap));
  localStorage.setItem('memoMap', JSON.stringify(memoMap));
  localStorage.setItem('photoMap', JSON.stringify(photoMap));
  
  alert('기록이 저장되었습니다!');
  
  // Return to travel mode
  selectMode('travel');
}

// Photo handling for record mode
function saveRecordPhoto() {
  const input = document.getElementById('recordPhotoInput');
  const files = input.files;
  if (!files || !AppState.currentAddress) return;
  
  if (!Array.isArray(photoMap[AppState.currentAddress])) {
    photoMap[AppState.currentAddress] = [];
  }
  if (!Array.isArray(originalPhotoMap[AppState.currentAddress])) {
    originalPhotoMap[AppState.currentAddress] = [];
  }
  
  const urls = photoMap[AppState.currentAddress];
  if (urls.length >= 5) {
    alert('사진은 최대 5장까지 등록할 수 있습니다.');
    return;
  }
  
  Array.from(files).forEach(file => {
    if (!file.type.startsWith('image/')) return;
    const reader = new FileReader();
    reader.onload = async e => {
      const img = new Image();
      img.onload = async () => {
        const canvas = document.createElement('canvas');
        const maxW = 800;
        const scale = maxW / img.width;
        canvas.width = maxW;
        canvas.height = img.height * scale;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        const resized = canvas.toDataURL('image/jpeg', 0.8);
        
        try {
          const uploaded = await uploadToImgur(resized);
          if (uploaded) {
            photoMap[AppState.currentAddress].push(uploaded);
            originalPhotoMap[AppState.currentAddress].push(uploaded);
            localStorage.setItem('photoMap', JSON.stringify(photoMap));
            renderRecordPhotos();
          }
        } catch (error) {
          alert('사진 업로드 중 오류가 발생했습니다.');
        }
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });
  
  setTimeout(() => {
    input.value = '';
  }, 500);
}

function renderRecordPhotos() {
  const container = document.getElementById('recordPhotoContainer');
  if (!container || !AppState.currentAddress) return;
  
  container.innerHTML = '';
  const photos = Array.isArray(photoMap[AppState.currentAddress]) ? photoMap[AppState.currentAddress] : [];
  
  photos.forEach((url, i) => {
    const img = document.createElement('img');
    img.src = url;
    img.className = 'photo-preview';
    img.onclick = () => handleRecordPhotoClick(i);
    container.appendChild(img);
  });
}

function handleRecordPhotoClick(index) {
  const imgUrl = originalPhotoMap[AppState.currentAddress]?.[index];
  if (!imgUrl) return;
  
  const dialog = document.createElement('div');
  dialog.style.cssText = `
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: white; padding: 20px; border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3); z-index: 9999;
  `;
  dialog.innerHTML = `
    <p style="margin-bottom: 15px; text-align: center; font-weight: 600;">사진 옵션을 선택하세요</p>
    <div style="display: flex; gap: 10px; justify-content: center;">
      <button id="viewBtn" class="btn btn-primary">📷 크게 보기</button>
      <button id="deleteBtn" class="btn btn-danger">❌ 삭제</button>
      <button id="cancelBtn" class="btn btn-secondary">취소</button>
    </div>
  `;
  document.body.appendChild(dialog);
  
  document.getElementById('viewBtn').onclick = () => {
    const popup = window.open('', '_blank');
    popup.document.write(`<img src='${imgUrl}' style='max-width:100%; height:auto;'>`);
    document.body.removeChild(dialog);
  };
  document.getElementById('deleteBtn').onclick = () => {
    deleteRecordPhoto(index);
    document.body.removeChild(dialog);
  };
  document.getElementById('cancelBtn').onclick = () => {
    document.body.removeChild(dialog);
  };
}

function deleteRecordPhoto(index) {
  if (!AppState.currentAddress || !photoMap[AppState.currentAddress]) return;
  photoMap[AppState.currentAddress].splice(index, 1);
  localStorage.setItem('photoMap', JSON.stringify(photoMap));
  renderRecordPhotos();
}
  
// Summary Mode Functions
function updateSummaryMode() {
  updateTable();
  drawChart();
}

function updateTable() {
  const tbody = document.getElementById('tableBody');
  if (!tbody) return;
  
  tbody.innerHTML = '';
  주소목록.forEach((addr, index) => {
    const rawStatus = statusMap[addr] || '미선택';
    const classStatus = ['출장완료', '미출장', '미선택'].includes(rawStatus) ? rawStatus : '직접입력';
    const memo = memoMap[addr] || '-';
    const photos = Array.isArray(photoMap[addr]) ? photoMap[addr] : [];
    const photoCount = photos.length > 0 ? (photos.length + '장') : '-';
    
    const row = document.createElement('tr');
    row.style.cssText = getStatusRowStyle(classStatus);
    row.innerHTML = `
      <td style="padding: 15px; border-bottom: 1px solid #e1e5e9; text-align: center;">
        <span style="display: inline-block; width: 25px; height: 25px; background: #1b3c82; color: white; border-radius: 50%; text-align: center; line-height: 25px; font-weight: bold; font-size: 0.8rem;">
          ${index + 1}
        </span>
      </td>
      <td style="padding: 15px; border-bottom: 1px solid #e1e5e9;">${addr}</td>
      <td style="padding: 15px; border-bottom: 1px solid #e1e5e9;">${rawStatus}</td>
      <td style="padding: 15px; border-bottom: 1px solid #e1e5e9; max-width: 200px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${memo}">${memo}</td>
      <td style="padding: 15px; border-bottom: 1px solid #e1e5e9;">${photoCount}</td>
    `;
    tbody.appendChild(row);
  });
  
  // Update summary
  const summary = document.getElementById('tableSummary');
  if (summary) {
    summary.textContent = `총 ${주소목록.length}건`;
  }
}

function getStatusRowStyle(status) {
  switch(status) {
    case '출장완료': return 'background-color: rgba(76, 175, 80, 0.1);';
    case '미출장': return 'background-color: rgba(244, 67, 54, 0.1);';
    case '미선택': return 'background-color: rgba(158, 158, 158, 0.1);';
    default: return 'background-color: rgba(255, 193, 7, 0.1);';
  }
}

function drawChart() {
  const ctx = document.getElementById('statusChart');
  if (!ctx) return;
  
  const count = { 출장완료: 0, 미출장: 0, 미선택: 0, 직접입력: 0 };
  주소목록.forEach(addr => {
    const status = statusMap[addr] || '미선택';
    const key = ['출장완료', '미출장', '미선택'].includes(status) ? status : '직접입력';
    count[key]++;
  });
  
  const data = {
    labels: Object.keys(count),
    datasets: [{
      label: '상태별 개수',
      data: Object.values(count),
      backgroundColor: ['#4caf50', '#f44336', '#90a4ae', '#ffcc80'],
      borderRadius: 8,
      borderWidth: 0
    }]
  };
  
  if (window.myChart) window.myChart.destroy();
  window.myChart = new Chart(ctx.getContext('2d'), {
    type: 'bar',
    data: data,
    options: { 
      responsive: true, 
      plugins: { 
        legend: { display: false },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          titleColor: 'white',
          bodyColor: 'white',
          borderColor: 'rgba(255, 255, 255, 0.2)',
          borderWidth: 1,
          cornerRadius: 8
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          grid: {
            color: 'rgba(0, 0, 0, 0.1)'
          }
        },
        x: {
          grid: {
            display: false
          }
        }
      }
    }
  });
  
  const total = Object.values(count).reduce((a, b) => a + b, 0);
  const statsCount = document.getElementById('statsCount');
  const chartText = document.getElementById('chartTextOutput');
  
  if (statsCount) {
    statsCount.textContent = `총 항목 수: ${total}건`;
  }
  if (chartText) {
    chartText.textContent = Object.entries(count).map(([k,v]) => `${k}: ${v}건`).join(' / ');
  }
}

function copyTable() {
  let text = '순서\t주소\t상태\t메모\t사진개수\n';
  주소목록.forEach((addr, index) => {
    const status = statusMap[addr] || '미선택';
    const memo = (memoMap[addr] || '').replace(/\n/g, ' ');
    const photoCount = Array.isArray(photoMap[addr]) ? photoMap[addr].length : 0;
    text += (index + 1) + '\t' + addr + '\t' + status + '\t' + memo + '\t' + photoCount + '\n';
  });
  navigator.clipboard.writeText(text).then(() => alert('복사 완료'));
}

function exportText() {
  let content = '출장 기록 - 텍스트 버전\n';
  content += '='.repeat(50) + '\n\n';
  
  주소목록.forEach((addr, index) => {
    const status = statusMap[addr] || '미선택';
    const memo = memoMap[addr] || '기록 없음';
    const photoCount = Array.isArray(photoMap[addr]) ? photoMap[addr].length : 0;
    
    content += `${index + 1}. ${addr}\n`;
    content += `   상태: ${status}\n`;
    content += `   메모: ${memo}\n`;
    content += `   사진: ${photoCount}장\n`;
    content += '-'.repeat(30) + '\n';
  });
  
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = '출장기록.txt';
  link.click();
}

function exportExcel() {
  const wb = XLSX.utils.book_new();
  const data = [['순서', '주소', '상태', '메모', '사진1', '사진2', '사진3', '사진4', '사진5']];
  주소목록.forEach((addr, index) => {
    const status = statusMap[addr] || '미선택';
    const memo = memoMap[addr] || '';
    const photos = Array.isArray(photoMap[addr]) ? photoMap[addr] : [];
    const limitedMemo = memo.length > 10000 ? memo.slice(0, 10000) + '...' : memo;
    const row = [index + 1, addr, status, limitedMemo, ...photos.slice(0, 5)];
    while (row.length < 9) row.push('');
    data.push(row);
  });
  const ws = XLSX.utils.aoa_to_sheet(data);
  
  // 사진 링크 셀에 하이퍼링크 추가
  data.forEach((row, rowIndex) => {
    if (rowIndex === 0) return;
    for (let i = 4; i <= 8; i++) {
      const cellAddr = XLSX.utils.encode_cell({ r: rowIndex, c: i });
      const val = row[i];
      if (val && typeof val === 'string') {
        ws[cellAddr].l = { Target: val };
      }
    }
  });
  
  XLSX.utils.book_append_sheet(wb, ws, '출장기록');
  XLSX.writeFile(wb, '출장기록.xlsx');
}

  
  // Utility Functions
function saveMapPreference() {
  preferredMap = document.getElementById('mapSelect').value;
  if (document.getElementById('rememberMap') && document.getElementById('rememberMap').checked) {
    localStorage.setItem('preferredMap', preferredMap);
  }
}

function saveAddressList() {
  localStorage.setItem('addressList', JSON.stringify(주소목록));
}

function loadAddressList() {
  const saved = localStorage.getItem('addressList');
  if (saved) {
    주소목록 = JSON.parse(saved);
  }
}

function loadStatusData() {
  const saved = localStorage.getItem('statusMap');
  if (saved) {
    statusMap = JSON.parse(saved);
  }
}

function loadMemoData() {
  const saved = localStorage.getItem('memoMap');
  if (saved) {
    memoMap = JSON.parse(saved);
  }
}

function loadPhotoData() {
  const saved = localStorage.getItem('photoMap');
  if (saved) {
    photoMap = JSON.parse(saved);
  }
}

function loadViewedAddresses() {
  const saved = localStorage.getItem('viewedAddresses');
  if (saved) {
    const viewedArray = JSON.parse(saved);
    viewedAddresses = new Set(viewedArray);
  }
}

function saveViewedAddresses() {
  localStorage.setItem('viewedAddresses', JSON.stringify([...viewedAddresses]));
}

function resetAddressList() {
  if (!confirm('모든 주소 목록을 삭제하시겠습니까?')) return;
  
  주소목록 = [];
  AppState.currentAddress = null;
  saveAddressList();
  updateAddressPreview();
  updateTravelMode();
  alert('주소 목록이 초기화되었습니다.');
}

function resetStatusMap() {
  if (!confirm('모든 상태 정보를 삭제하시겠습니까?')) return;
  
  statusMap = {};
  localStorage.removeItem('statusMap');
  alert('상태 정보가 초기화되었습니다.');
}

// File handling functions
function loadAddressFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const lines = e.target.result.split(/\r?\n/).filter(line => line.trim());
    const newList = [];
    let added = 0;
    
    lines.forEach(line => {
      const [addr, status] = line.split('\t');
      const trimmedAddr = addr?.trim();
      if (trimmedAddr && !주소목록.includes(trimmedAddr)) {
        newList.push(trimmedAddr);
        if (status) statusMap[trimmedAddr] = status.trim();
        added++;
      } else if (trimmedAddr && status) {
        statusMap[trimmedAddr] = status.trim();
      }
    });
    
    주소목록 = [...주소목록, ...newList];
    alert(`주소 파일 업로드 완료: ${lines.length}건 중 ${added}건 추가됨 (총 ${주소목록.length}건)`);
    
    saveAddressList();
    localStorage.setItem('statusMap', JSON.stringify(statusMap));
    nextStep(3);
  };
  
  reader.readAsText(file, 'UTF-8');
}

function addFromTextarea() {
  const input = document.getElementById('bulkPaste').value;
  if (!input) {
    alert('주소를 입력해주세요.');
    return;
  }
  
  const lines = input.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  const newList = lines.filter(l => !주소목록.includes(l));
  주소목록 = [...주소목록, ...newList];
  saveAddressList();
  
  alert(`${newList.length}개의 주소가 추가되었습니다.`);
  document.getElementById('bulkPaste').value = '';
  nextStep(3);
}

// Imgur upload function
function uploadToImgur(base64Image) {
  return fetch('https://api.imgur.com/3/image', {
    method: 'POST',
    headers: {
      Authorization: 'Client-ID a0058fd0a6e3657',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      image: base64Image.split(',')[1],
      type: 'base64'
    })
  })
  .then(res => res.json())
  .then(data => {
    if (data.success && data.data && data.data.link) {
      return data.data.link;
    } else {
      throw new Error('Imgur 업로드 실패');
    }
  });
}

// Optimal Route Variables
// API 키는 사용자가 직접 입력하여 사용 (보안상 하드코딩 금지)
let GEMINI_API_KEY = localStorage.getItem('gemini-api-key') || '';
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent';

// Debug Log System
let debugLogs = [];
function addDebugLog(message, data = null) {
  const timestamp = new Date().toISOString();
  const logEntry = {
    timestamp,
    message,
    data: data ? JSON.stringify(data, null, 2) : null
  };
  debugLogs.push(logEntry);
  console.log(`[DEBUG ${timestamp}] ${message}`, data);
  
  // Keep only last 100 logs
  if (debugLogs.length > 100) {
    debugLogs = debugLogs.slice(-100);
  }
}

function downloadDebugLogs() {
  const logContent = debugLogs.map(log => {
    let entry = `[${log.timestamp}] ${log.message}`;
    if (log.data) {
      entry += `\n${log.data}`;
    }
    return entry;
  }).join('\n\n' + '='.repeat(50) + '\n\n');
  
  const blob = new Blob([logContent], { type: 'text/plain;charset=utf-8' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = `debug_log_${new Date().toISOString().slice(0,19).replace(/[:.]/g, '-')}.txt`;
  link.click();
}

// Optimal Route Functions
function showOptimalRouteModal() {
  if (주소목록.length < 2) {
    alert('최적경로 추천을 위해서는 최소 2곳 이상의 출장지가 필요합니다.');
    return;
  }
  
  // Update address count and preview
  document.getElementById('route-address-count').textContent = 주소목록.length;
  const preview = document.getElementById('route-address-preview');
  preview.innerHTML = 주소목록.slice(0, 5).map(addr => `• ${addr}`).join('<br>') + 
    (주소목록.length > 5 ? `<br>• ... 외 ${주소목록.length - 5}곳` : '');
  
  document.getElementById('optimalRouteModal').classList.add('show');
  
  // Initialize route API key status
  initializeRouteApiKey();
}

// Route Modal API Key Management Functions
function saveRouteApiKey() {
  const apiKeyInput = document.getElementById('route-api-key-input');
  const newKey = apiKeyInput.value.trim();
  
  if (!newKey) {
    updateRouteApiStatus('API 키를 입력해주세요', 'error');
    return;
  }
  
  if (!newKey.startsWith('AIzaSy') || newKey.length < 30) {
    updateRouteApiStatus('올바른 Gemini API 키 형식이 아닙니다', 'error');
    return;
  }
  
  GEMINI_API_KEY = newKey;
  localStorage.setItem('gemini-api-key', newKey);
  updateRouteApiStatus('저장완료', 'success');
  
  // 1단계의 API 키 입력창도 동기화
  const mainApiInput = document.getElementById('api-key-input');
  if (mainApiInput) {
    mainApiInput.value = newKey;
    updateApiStatus('저장된 API 키 로드됨', 'success');
  }
}

async function testRouteApiKey() {
  const apiKeyInput = document.getElementById('route-api-key-input');
  const testKey = apiKeyInput.value.trim();
  
  if (!testKey) {
    updateRouteApiStatus('API 키를 입력해주세요', 'error');
    return;
  }
  
  updateRouteApiStatus('테스트중...', 'loading');
  
  try {
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${testKey}`);
    
    if (response.ok) {
      updateRouteApiStatus('정상작동', 'success');
    } else {
      updateRouteApiStatus('키 무효', 'error');
    }
  } catch (error) {
    updateRouteApiStatus('네트워크 오류', 'error');
  }
}

function updateRouteApiStatus(message, type) {
  const statusEl = document.getElementById('route-api-status');
  statusEl.textContent = message;
  
  const styles = {
    success: 'background: #d4edda; color: #155724;',
    error: 'background: #f8d7da; color: #721c24;',
    loading: 'background: #d1ecf1; color: #0c5460;'
  };
  
  statusEl.style.cssText = styles[type] || '';
}

function initializeRouteApiKey() {
  const apiKeyInput = document.getElementById('route-api-key-input');
  if (apiKeyInput) {
    apiKeyInput.value = GEMINI_API_KEY || '';
    if (GEMINI_API_KEY) {
      updateRouteApiStatus('로드됨', 'success');
    } else {
      updateRouteApiStatus('API 키 필요', 'error');
    }
  }
}

async function calculateOptimalRoute() {
  addDebugLog('=== 최적경로 계산 시작 ===');
  
  const startLocation = document.getElementById('startLocation').value.trim() || '아차산로 400';
  addDebugLog('출발지 입력값', { startLocation });
  addDebugLog('현재 주소목록', { addresses: 주소목록, count: 주소목록.length });
  
  // 다중 최적화 전략 실행
  document.getElementById('calculate-route-btn').disabled = true;
  document.getElementById('calculate-route-btn').textContent = '🧠 고급 분석 중...';
  
  try {
    // 1. 고급 분석 시도 (좌표 기반 TSP)
    addDebugLog('1단계: 고급 분석 시도');
    const advancedResult = await performAdvancedOptimization(startLocation, 주소목록);
    
    let primaryResult = null;
    let fallbackResult = null;
    
    if (advancedResult.success) {
      primaryResult = {
        order: advancedResult.addresses, // Use the actual optimized addresses
        method: advancedResult.method || '고급 TSP 알고리즘',
        distance: advancedResult.totalDistance,
        coordinates: advancedResult.coordinates
      };
      addDebugLog('고급 분석 성공', primaryResult);
    }
    
    // 2. Gemini AI 분석 시도 (API 키가 있는 경우)
    if (GEMINI_API_KEY && GEMINI_API_KEY.startsWith('AIzaSy')) {
      addDebugLog('2단계: Gemini AI 분석 시도');
      document.getElementById('calculate-route-btn').textContent = '🤖 AI 분석 중...';
      
      try {
        const geminiOrder = await getOptimalRouteFromGemini(startLocation, 주소목록);
        // Convert Gemini indices to addresses
        const geminiAddresses = geminiOrder.map(index => 주소목록[index]).filter(addr => addr);
        const geminiResult = {
          order: geminiAddresses,
          method: 'Gemini AI 추론',
          distance: null // Gemini는 거리 계산 안함
        };
        
        // 고급 분석 결과가 있으면 보조로, 없으면 주 결과로 사용
        if (primaryResult) {
          fallbackResult = geminiResult;
        } else {
          primaryResult = geminiResult;
        }
        addDebugLog('Gemini AI 분석 성공', geminiResult);
      } catch (geminiError) {
        addDebugLog('Gemini AI 분석 실패', { error: geminiError.message });
      }
    }
    
    // 3. 지역 기반 백업 알고리즘
    if (!primaryResult) {
      addDebugLog('3단계: 백업 알고리즘 실행');
      const backupOrder = getSimpleFallbackOrder(주소목록);
      primaryResult = {
        order: backupOrder,
        method: '지역 기반 알고리즘',
        distance: null
      };
      addDebugLog('백업 알고리즘 완료', primaryResult);
    }
    
    // 결과 적용
    reorderAddressList(primaryResult.order);
    
    // 성공 메시지 구성
    let successMessage = '경로 최적화 완료!\n\n사용된 분석 방법: ' + primaryResult.method;
    
    if (primaryResult.distance) {
      const distance = typeof primaryResult.distance === 'string' ? 
        parseFloat(primaryResult.distance) : primaryResult.distance;
      if (!isNaN(distance)) {
        successMessage += '\n예상 총 거리: ' + distance + 'km';
      }
    }
    
    if (primaryResult.coordinates) {
      successMessage += '\n실제 좌표 기반 분석 완료';
    }
    
    if (primaryResult.clusters) {
      const clusterCount = Object.keys(primaryResult.clusters).length;
      successMessage += `\n🎯 ${clusterCount}개 지역 군집 분석 완료`;
    }
    
    if (fallbackResult) {
      successMessage += `\n\n💡 추가로 ${fallbackResult.method} 결과도 확인되었습니다.`;
    }
    
    alert(successMessage);
    addDebugLog('=== 최적경로 계산 성공 완료 ===');
    
    // Close modal and switch to travel mode
    closeModal();
    selectMode('travel');
    
  } catch (error) {
    addDebugLog('최적경로 계산 중 오류 발생', { 
      error: error.message,
      stack: error.stack,
      addresses: 주소목록
    });
    
    // 최종 백업: 단순 순서 유지
    alert('⚠️ 모든 최적화 알고리즘이 실패했습니다. 기본 순서를 유지합니다.\n콘솔(F12)에서 자세한 오류 정보를 확인할 수 있습니다.');
    
  } finally {
    // UI 복구
    document.getElementById('calculate-route-btn').disabled = false;
    document.getElementById('calculate-route-btn').textContent = '🎯 고급 경로 최적화 (TSP + AI)';
  }
}

// 주소 목록 재정렬 함수
function reorderAddressList(newOrderAddresses) {
  if (!newOrderAddresses || newOrderAddresses.length === 0) {
    addDebugLog('재정렬할 순서가 없음');
    return;
  }
  
  addDebugLog('주소 목록 재정렬 시작', { 
    originalOrder: 주소목록, 
    newOrderAddresses 
  });
  
  // Store optimized route for display purposes (don't modify original 주소목록)
  optimizedRoute = [...newOrderAddresses];
  
  addDebugLog('최적화된 경로 저장 완료', { optimizedRoute });
  
  // Update only Travel mode UI to show optimized order
  if (AppState.currentMode === 'travel') {
    updateTravelMode();
  }
  
  addDebugLog('주소목록 재정렬 완료');
}

async function getOptimalRouteFromGemini(startLocation, destinations) {
  addDebugLog('Gemini API 함수 시작', { startLocation, destinations });
  
  // API 키 보안 체크
  if (!GEMINI_API_KEY || !GEMINI_API_KEY.startsWith('AIzaSy')) {
    addDebugLog('API 키 없음 - fallback 사용');
    throw new Error('API 키가 설정되지 않았습니다. 1단계에서 API 키를 설정해주세요.');
  }
  
  const prompt = `경로 최적화 - 숫자만 응답

출발: ${startLocation}
목적지: ${destinations.map((addr, i) => `${i}.${addr}`).join(' / ')}

규칙: 거리순→권역묶음→간선도로→좌회전최소→복귀효율

응답형식: [0,1,2,3,4,5,6]
주의: 설명금지, 숫자배열만 출력`;

  addDebugLog('생성된 프롬프트', { prompt });

  const requestBody = {
    contents: [{
      parts: [{
        text: prompt
      }]
    }]
  };

  addDebugLog('API 요청 바디', { requestBody });

  try {
    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    addDebugLog('API 응답 상태', { 
      status: response.status, 
      statusText: response.statusText 
    });

    if (!response.ok) {
      const errorText = await response.text();
      addDebugLog('API 오류 응답', { errorText });
      throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
    }

    const data = await response.json();
    addDebugLog('원본 API 응답', { data });

    if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
      throw new Error('API 응답에 유효한 content가 없습니다.');
    }

    const text = data.candidates[0].content.parts[0].text;
    addDebugLog('추출된 텍스트', { text });

    return parseOptimalOrderResponse(text);

  } catch (error) {
    addDebugLog('Gemini API 호출 실패', { error: error.message });
    throw error;
  }
}

// Gemini 응답 파싱 함수
function parseOptimalOrderResponse(text) {
  try {
    // 응답에서 설명 텍스트 제거하고 숫자 배열만 추출
    let cleanText = text
      .replace(/```json\n?/g, '')
      .replace(/```\n?/g, '')
      .replace(/\*\*.*?\*\*/g, '')  // **굵은 텍스트** 제거
      .replace(/주어진.*?때문입니다\./gs, '')  // 불필요한 설명 제거
      .replace(/하지만.*?제시해.*?보겠습니다\./gs, '')  // 불필요한 설명 제거
      .replace(/추정.*?과정.*?설명입니다\./gs, '')  // 불필요한 설명 제거
      .replace(/정확한.*?바랍니다\./gs, '')  // 불필요한 설명 제거
      .trim();
    
    addDebugLog('정리된 텍스트', { cleanText });
    
    // 숫자 배열 패턴 찾기 (더 유연한 패턴)
    const arrayPatterns = [
      /\[[\d,\s]+\]/,           // 기본 패턴: [0,1,2,3]
      /\[[\d\s,]+\]/,           // 공백 포함: [0, 1, 2, 3]
      /\[[\d\s,\n]+\]/,         // 줄바꿈 포함
      /\[\s*\d+(?:\s*,\s*\d+)*\s*\]/  // 더 유연한 패턴
    ];
    
    let match = null;
    for (const pattern of arrayPatterns) {
      match = cleanText.match(pattern);
      if (match) break;
    }
    
    addDebugLog('정규식 매칭 결과', { match, originalText: text.substring(0, 200) + '...', cleanText });
    
    if (match) {
      const optimalOrder = JSON.parse(match[0]);
      addDebugLog('파싱된 최적 순서', { optimalOrder });
      
      // Validate the result
      if (!Array.isArray(optimalOrder)) {
        throw new Error('Result is not an array');
      }
      
      if (optimalOrder.length === 0) {
        throw new Error('Empty result array');
      }
      
      // Validate each index
      const validOrder = optimalOrder.filter(index => 
        typeof index === 'number' && index >= 0
      );
      
      addDebugLog('검증된 순서', { validOrder });
      return validOrder;
      
    } else {
      addDebugLog('배열 패턴을 찾을 수 없음');
      throw new Error('Could not find valid array pattern in response');
    }
    
  } catch (error) {
    addDebugLog('응답 파싱 오류', { error: error.message, text });
    throw new Error(`Failed to parse optimal order: ${error.message}`);
  }
}


// ===== 고급 경로 최적화 시스템 =====

// 2단계: 거리 매트릭스 계산
function calculateDistanceMatrix(coordinates) {
  addDebugLog('2단계: 거리 매트릭스 계산 시작');
  
  const addresses = Object.keys(coordinates);
  const size = addresses.length;
  const matrix = Array(size).fill().map(() => Array(size).fill(0));
  
  for (let i = 0; i < size; i++) {
    for (let j = i; j < size; j++) {
      const dist = haversineDistance(
        coordinates[addresses[i]],
        coordinates[addresses[j]]
      );
      matrix[i][j] = matrix[j][i] = Math.round(dist * 100) / 100; // 소수점 2자리
    }
  }
  
  addDebugLog('거리 매트릭스 완료', { matrix, addresses });
  return { matrix, addresses };
}

// Haversine 공식으로 두 좌표 간 거리 계산 (km)
function haversineDistance(coord1, coord2) {
  const R = 6371; // 지구 반지름 (km)
  const dLat = toRad(coord2.lat - coord1.lat);
  const dLng = toRad(coord2.lng - coord1.lng);
  
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(toRad(coord1.lat)) * Math.cos(toRad(coord2.lat)) *
    Math.sin(dLng/2) * Math.sin(dLng/2);
  
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

function toRad(deg) {
  return deg * (Math.PI / 180);
}

// 3단계: K-means 군집 분석
function performClustering(coordinates, numClusters = 3) {
  addDebugLog('3단계: 군집 분석 시작', { numClusters });
  
  const addresses = Object.keys(coordinates);
  const points = addresses.map(addr => [coordinates[addr].lat, coordinates[addr].lng]);
  
  if (points.length <= numClusters) {
    // 지점이 적으면 각각을 별도 군집으로
    const clusters = addresses.reduce((acc, addr, i) => {
      acc[addr] = i;
      return acc;
    }, {});
    addDebugLog('군집 분석 완료 (개별 군집)', { clusters });
    return clusters;
  }
  
  // 간단한 K-means 구현
  const clusters = simpleKMeans(points, numClusters);
  const clusterMap = addresses.reduce((acc, addr, i) => {
    acc[addr] = clusters[i];
    return acc;
  }, {});
  
  addDebugLog('군집 분석 완료', { clusterMap });
  return clusterMap;
}

// 간단한 K-means 알고리즘 구현
function simpleKMeans(points, k, maxIterations = 10) {
  // 초기 중심점 랜덤 선택
  let centroids = [];
  for (let i = 0; i < k; i++) {
    centroids.push([...points[Math.floor(Math.random() * points.length)]]);
  }
  
  let clusters = new Array(points.length);
  
  for (let iter = 0; iter < maxIterations; iter++) {
    // 각 점을 가장 가까운 중심점에 할당
    for (let i = 0; i < points.length; i++) {
      let minDist = Infinity;
      let minCluster = 0;
      
      for (let j = 0; j < k; j++) {
        const dist = Math.sqrt(
          Math.pow(points[i][0] - centroids[j][0], 2) +
          Math.pow(points[i][1] - centroids[j][1], 2)
        );
        if (dist < minDist) {
          minDist = dist;
          minCluster = j;
        }
      }
      clusters[i] = minCluster;
    }
    
    // 새로운 중심점 계산
    const newCentroids = Array(k).fill().map(() => [0, 0]);
    const counts = Array(k).fill(0);
    
    for (let i = 0; i < points.length; i++) {
      const cluster = clusters[i];
      newCentroids[cluster][0] += points[i][0];
      newCentroids[cluster][1] += points[i][1];
      counts[cluster]++;
    }
    
    for (let j = 0; j < k; j++) {
      if (counts[j] > 0) {
        newCentroids[j][0] /= counts[j];
        newCentroids[j][1] /= counts[j];
      }
    }
    
    centroids = newCentroids;
  }
  
  return clusters;
}

// 4단계: TSP 최적화 (작은 규모용)
function solveTSP(distanceMatrix, startIndex = 0) {
  addDebugLog('4단계: TSP 최적화 시작');
  
  const n = distanceMatrix.length;
  if (n <= 1) return [0];
  if (n === 2) return [0, 1];
  
  // 작은 규모(<=8)면 완전 탐색, 큰 규모면 휴리스틱
  if (n <= 8) {
    return bruteForceTSP(distanceMatrix, startIndex);
  } else {
    return nearestNeighborTSP(distanceMatrix, startIndex);
  }
}

// 완전 탐색 TSP (작은 규모용)
function bruteForceTSP(matrix, start) {
  const n = matrix.length;
  const others = [];
  for (let i = 0; i < n; i++) {
    if (i !== start) others.push(i);
  }
  
  let bestPath = null;
  let bestDistance = Infinity;
  
  const permutations = getPermutations(others);
  
  for (const perm of permutations) {
    const path = [start, ...perm];
    const distance = calculatePathDistance(matrix, path, true); // 복귀 포함
    
    if (distance < bestDistance) {
      bestDistance = distance;
      bestPath = [...path];
    }
  }
  
  addDebugLog('완전 탐색 TSP 완료', { bestPath, bestDistance });
  return bestPath;
}

// 최근접 이웃 TSP (큰 규모용)
function nearestNeighborTSP(matrix, start) {
  const n = matrix.length;
  const visited = new Array(n).fill(false);
  const path = [start];
  visited[start] = true;
  
  let current = start;
  
  for (let i = 1; i < n; i++) {
    let nearest = -1;
    let minDist = Infinity;
    
    for (let j = 0; j < n; j++) {
      if (!visited[j] && matrix[current][j] < minDist) {
        minDist = matrix[current][j];
        nearest = j;
      }
    }
    
    if (nearest !== -1) {
      path.push(nearest);
      visited[nearest] = true;
      current = nearest;
    }
  }
  
  const totalDistance = calculatePathDistance(matrix, path, true);
  addDebugLog('최근접 이웃 TSP 완료', { path, totalDistance });
  return path;
}

// 경로의 총 거리 계산
function calculatePathDistance(matrix, path, includeReturn = false) {
  let total = 0;
  for (let i = 0; i < path.length - 1; i++) {
    total += matrix[path[i]][path[i + 1]];
  }
  if (includeReturn && path.length > 1) {
    total += matrix[path[path.length - 1]][path[0]]; // 출발지로 복귀
  }
  return total;
}

// 순열 생성 (완전 탐색용)
function getPermutations(arr) {
  if (arr.length <= 1) return [arr];
  
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];
    const perms = getPermutations(rest);
    for (const perm of perms) {
      result.push([arr[i], ...perm]);
    }
  }
  return result;
}

// 통합 고급 경로 최적화 함수
async function performAdvancedOptimization(startAddress, destinations) {
  try {
    addDebugLog('=== 고급 경로 최적화 시작 ===');
    
    // 1단계: 좌표 변환 - 모든 주소를 병렬로 처리
    const allAddresses = [startAddress, ...destinations];
    addDebugLog('좌표 변환 시작', { addresses: allAddresses });
    
    // Force clear cache if all coordinates are identical (old cache issue)
    const existingCoords = Object.values(coordinatesCache);
    if (existingCoords.length > 1) {
      const firstCoord = existingCoords[0];
      const allSame = existingCoords.every(coord => 
        coord && firstCoord && 
        Math.abs(coord.lat - firstCoord.lat) < 0.0001 && 
        Math.abs(coord.lng - firstCoord.lng) < 0.0001
      );
      if (allSame) {
        addDebugLog('동일 좌표 감지 - 캐시 강제 초기화');
        coordinatesCache = {};
        localStorage.removeItem("coordinatesCache");
      }
    }
    
    for (const address of allAddresses) {
      await geocodeAddress(address);
    }
    
    addDebugLog('좌표 캐시 상태', { coordinatesCache });
    
    // 2단계: 최적화 전 좌표 검증
    const validCoordCount = allAddresses.filter(addr => {
      const coord = coordinatesCache[addr];
      return coord && coord.lat && coord.lng;
    }).length;

    if (validCoordCount < allAddresses.length) {
      addDebugLog('좌표 변환 불완전', { 
        total: allAddresses.length, 
        valid: validCoordCount 
      });
      
      // fallback 전략 실행
      if (validCoordCount === 0) {
        addDebugLog('모든 좌표 변환 실패 - 지리적 fallback 사용');
        return getGeographicFallback(destinations, startAddress);
      }
    }

    // 3단계: 다중 알고리즘 최적 경로 계산
    const optimizationResult = optimizeRouteMultiAlgorithm(destinations, startAddress);
    
    if (!optimizationResult || !optimizationResult.route) {
      addDebugLog('다중 알고리즘 실패 - 지리적 fallback 사용');
      return getGeographicFallback(destinations, startAddress);
    }
    
    addDebugLog('다중 알고리즘 TSP 최적화 완료', {
      originalOrder: destinations,
      bestMethod: optimizationResult.method,
      optimizedRoute: optimizationResult.route,
      totalDistance: `${optimizationResult.distance.toFixed(2)}km`,
      coordinatesFilled: validCoordCount + '/' + allAddresses.length
    });
    
    // 4단계: 결과 검증
    const optimizationQuality = validateOptimization(destinations, optimizationResult.route, startAddress);
    
    // 결과 반환
    return {
      success: true,
      coordinates: coordinatesCache,
      optimalOrder: optimizationResult.route,
      totalDistance: optimizationResult.distance.toFixed(2),
      addresses: optimizationResult.route,
      method: optimizationResult.method,
      quality: optimizationQuality,
      coordsAvailable: validCoordCount + '/' + allAddresses.length
    };
    
  } catch (error) {
    addDebugLog('고급 최적화 오류', { error: error.message });
    
    // Complete fallback
    try {
      return getGeographicFallback(destinations, startAddress);
    } catch (fallbackError) {
      addDebugLog('Fallback 실패', { error: fallbackError.message });
      return { 
        success: false, 
        error: error.message,
        fallbackError: fallbackError.message,
        route: destinations // Return original order as last resort
      };
    }
  }
}

// Geographic fallback strategy when APIs fail
function getGeographicFallback(destinations, startAddress) {
  addDebugLog('지리적 fallback 전략 실행');
  
  if (!destinations || destinations.length === 0) {
    return { 
      success: false, 
      error: 'No destinations provided',
      route: []
    };
  }

  // Simple geographic sorting based on address patterns
  const sortedDest = [...destinations].sort((a, b) => {
    const aScore = getGeographicScore(a);
    const bScore = getGeographicScore(b);
    return aScore - bScore;
  });

  const fallbackDistance = calculateApproximateDistance(sortedDest);

  return {
    success: true,
    coordinates: {},
    optimalOrder: sortedDest,
    totalDistance: fallbackDistance.toFixed(2),
    addresses: sortedDest,
    method: '지리적 Fallback (API 없음)',
    quality: 'Estimated'
  };
}

function getGeographicScore(address) {
  // Priority scoring based on typical Seoul/Gwangjin geography
  const scores = {
    '구의강변로': 1,
    '능동로': 2, 
    '뚝섬로': 3,
    '아차산로': 4,
    '용마산로': 5,
    '동일로': 6
  };

  for (const [pattern, score] of Object.entries(scores)) {
    if (address.includes(pattern)) return score;
  }
  return 50; // Default middle score
}

function calculateApproximateDistance(addresses) {
  // Rough estimation based on address count and patterns
  return addresses.length * 1.2; // ~1.2km average between locations
}

// Validate optimization quality
function validateOptimization(original, optimized, startAddress) {
  if (!optimized || optimized.length !== original.length) {
    return 'Invalid - length mismatch';
  }

  const originalSet = new Set(original);
  const optimizedSet = new Set(optimized);
  
  if (originalSet.size !== optimizedSet.size) {
    return 'Invalid - address mismatch';
  }

  for (const addr of original) {
    if (!optimizedSet.has(addr)) {
      return 'Invalid - missing address';
    }
  }

  return 'Valid';
}

// Simple fallback route optimization algorithm
function getSimpleFallbackOrder(destinations) {
  addDebugLog('간단한 fallback 알고리즘 시작', { destinations });
  
  if (!destinations || destinations.length === 0) {
    return [];
  }
  
  if (destinations.length === 1) {
    return [0];
  }
  
  // 아차산로 400 기준 실제 지리적 최적화 전략
  const result = [];
  
  // 강변(구의강변로) → 중간지역 → 외곽(동일로) 순서로 최적화
  const priorities = {
    '구의강변로': 1,     // 강변 우선 방문
    '능동로3다길': 2,    // 중간 지역
    '능동로32길': 3,     // 중간 지역  
    '뚝섬로': 4,         // 중간 지역
    '아차산로17가길': 5, // 산기슭
    '동일로322': 6       // 가장 외곽, 마지막 방문
  };
  
  const sortedIndices = destinations
    .map((addr, index) => ({ 
      address: addr, 
      index, 
      priority: getPriority(addr) 
    }))
    .sort((a, b) => a.priority - b.priority)
    .map(item => item.index);
    
  function getPriority(address) {
    for (const [key, priority] of Object.entries(priorities)) {
      if (address.includes(key)) return priority;
    }
    return 999; // 기본값
  }
  
  addDebugLog('Fallback 알고리즘 완료', { sortedIndices });
  
  return sortedIndices;
}

function calculateAddressSimilarity(addr1, addr2) {
  // Enhanced similarity for Gwangjin-gu addresses
  const words1 = addr1.replace(/\d+/g, '').split(/\s+/).filter(w => w.length > 0);
  const words2 = addr2.replace(/\d+/g, '').split(/\s+/).filter(w => w.length > 0);
  
  let commonWords = 0;
  let regionScore = 0;
  let roadScore = 0;
  
  // Basic word matching
  for (const word1 of words1) {
    if (words2.some(word2 => word2.includes(word1) || word1.includes(word2))) {
      commonWords++;
    }
  }
  
  // 광진구 지역별 클러스터링 (아차산로 400 기준)
  const regions = {
    western: ['구의', '자양', '동일로'],     // 서측 (아차산로 400과 가까움)
    northern: ['능동로', '중곡'],           // 북측 능동로 권역
    riverside: ['뚝섬로', '한강', '강변'],  // 한강변
    central: ['아차산로', '용마산로']       // 중앙 아차산로 권역
  };
  
  const getRegion = (addr) => {
    for (const [region, keywords] of Object.entries(regions)) {
      if (keywords.some(keyword => addr.includes(keyword))) {
        return region;
      }
    }
    return 'unknown';
  };
  
  const region1 = getRegion(addr1);
  const region2 = getRegion(addr2);
  
  // 같은 지역이면 높은 점수
  if (region1 === region2 && region1 !== 'unknown') {
    regionScore = 3;
  } else if (region1 !== 'unknown' && region2 !== 'unknown') {
    // 인접 지역들은 중간 점수
    const adjacency = {
      western: ['northern', 'central'],     // 서측-북측, 서측-중앙 연결
      northern: ['western', 'central'],     // 북측-서측, 북측-중앙 연결  
      riverside: ['western', 'central'],    // 한강변-서측, 한강변-중앙 연결
      central: ['western', 'northern', 'riverside'] // 중앙은 모든 지역과 연결
    };
    if (adjacency[region1]?.includes(region2)) {
      regionScore = 1.5;
    }
  }
  
  // 도로명 유사성 추가 점수
  const roads1 = ['능동로', '뚝섬로', '동일로', '아차산로', '용마산로'].filter(road => addr1.includes(road));
  const roads2 = ['능동로', '뚝섬로', '동일로', '아차산로', '용마산로'].filter(road => addr2.includes(road));
  
  if (roads1.length > 0 && roads2.length > 0) {
    if (roads1.some(r1 => roads2.includes(r1))) {
      roadScore = 2; // 같은 도로면 높은 점수
    }
  }
  
  // 아차산로 400(출발지) 기준으로 서측 지역 우선순위 부여
  let proximityScore = 0;
  if (addr1.includes('동일로') || addr1.includes('구의') || addr1.includes('자양')) {
    proximityScore += 1;
  }
  if (addr2.includes('동일로') || addr2.includes('구의') || addr2.includes('자양')) {
    proximityScore += 1;
  }
  
  const totalScore = (commonWords + regionScore + roadScore + proximityScore);
  const maxPossible = Math.max(words1.length, words2.length, 5);
  
  return totalScore / maxPossible;
}

// Route Algorithm Comparison
async function compareRouteAlgorithms() {
  if (주소목록.length < 2) {
    alert('경로 비교를 위해서는 최소 2곳 이상의 출장지가 필요합니다.');
    return;
  }

  const startLocation = document.getElementById('startLocation').value.trim() || '아차산로 400';
  
  addDebugLog('=== 알고리즘 비교 시작 ===', { startLocation, addresses: 주소목록 });

  // Show loading
  document.getElementById('route-loading').style.display = 'block';
  
  // Ensure coordinates are cached
  for (const address of [startLocation, ...주소목록]) {
    await geocodeAddress(address);
  }
  
  const results = [];
  
  try {
    // 1. Original order
    const originalDistance = calculateTotalDistance([startLocation, ...주소목록, startLocation]);
    results.push({
      method: '원래 순서',
      route: 주소목록,
      distance: originalDistance,
      color: '#999'
    });

    // 2. Geography-aware Seoul routing
    const geoRoute = optimizeRouteGeographyAware(주소목록, startLocation);
    const geoDistance = calculateTotalDistance([startLocation, ...geoRoute, startLocation]);
    results.push({
      method: '지리 기반 최적화 (서울 특화)',
      route: geoRoute,
      distance: geoDistance,
      color: '#2ecc71'
    });

    // 3. Sector-based routing
    const sectorRoute = optimizeRouteSectorBased(주소목록, startLocation);
    const sectorDistance = calculateTotalDistance([startLocation, ...sectorRoute, startLocation]);
    results.push({
      method: '구역별 순회 (택배 방식)',
      route: sectorRoute,
      distance: sectorDistance,
      color: '#3498db'
    });

    // 4. Traffic-aware routing
    const trafficRoute = optimizeRouteTrafficAware(주소목록, startLocation);
    const trafficDistance = calculateTotalDistance([startLocation, ...trafficRoute, startLocation]);
    results.push({
      method: '교통 고려 최적화',
      route: trafficRoute,
      distance: trafficDistance,
      color: '#e74c3c'
    });

    // 5. Hierarchical road routing
    const hierarchicalRoute = optimizeRouteHierarchical(주소목록, startLocation);
    const hierarchicalDistance = calculateTotalDistance([startLocation, ...hierarchicalRoute, startLocation]);
    results.push({
      method: '도로 위계 기반 (간선→지선)',
      route: hierarchicalRoute,
      distance: hierarchicalDistance,
      color: '#9b59b6'
    });

    // 6. Traditional Nearest Neighbor for comparison
    const nnRoute = optimizeRouteNearestNeighbor(주소목록, startLocation);
    const nnDistance = calculateTotalDistance([startLocation, ...nnRoute, startLocation]);
    results.push({
      method: 'Nearest Neighbor (기존)',
      route: nnRoute,
      distance: nnDistance,
      color: '#95a5a6'
    });

    // 6. AI 최적화 결과 (if available)
    if (GEMINI_API_KEY && GEMINI_API_KEY.startsWith('AIzaSy')) {
      try {
        const aiIndices = await getOptimalRouteFromGemini(startLocation, 주소목록);
        const aiRoute = aiIndices.map(index => 주소목록[index]).filter(addr => addr);
        const aiDistance = calculateTotalDistance([startLocation, ...aiRoute, startLocation]);
        results.push({
          method: 'Gemini AI',
          route: aiRoute,
          distance: aiDistance,
          color: '#f39c12'
        });
      } catch (error) {
        addDebugLog('AI 알고리즘 실패', { error: error.message });
      }
    }

    // Sort by distance (best first)
    results.sort((a, b) => a.distance - b.distance);

    // 결과 표시
    showRouteComparison(results, startLocation);

  } catch (error) {
    addDebugLog('알고리즘 비교 중 오류', { error: error.message });
    alert('알고리즘 비교 중 오류가 발생했습니다.');
  } finally {
    document.getElementById('route-loading').style.display = 'none';
  }
}

function showRouteComparison(results, startLocation) {
  // Create modal HTML
  const modalHtml = `
    <div id="comparisonModal" class="modal show">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <div class="modal-header">
          <div class="modal-title">🔍 알고리즘 성능 비교</div>
          <div class="modal-subtitle">출발지: ${startLocation}</div>
        </div>
        
        <div style="margin-bottom: 20px;">
          <h4 style="color: #1b3c82; margin-bottom: 15px;">📊 성능 순위</h4>
          ${results.map((result, index) => `
            <div style="background: ${index === 0 ? 'rgba(46, 204, 113, 0.1)' : 'rgba(255,255,255,0.8)'}; 
                        border: 1px solid ${result.color}; border-radius: 8px; padding: 12px; margin-bottom: 10px;
                        ${index === 0 ? 'border-left: 4px solid #27ae60;' : ''}">
              <div style="display: flex; justify-content: between; align-items: center;">
                <div>
                  <strong style="color: ${result.color};">
                    ${index + 1}. ${result.method}
                    ${index === 0 ? ' 🏆' : ''}
                  </strong>
                  <div style="font-size: 0.9rem; color: #666; margin-top: 5px;">
                    총 거리: <strong>${result.distance.toFixed(2)}km</strong>
                    ${index > 0 ? `(+${(result.distance - results[0].distance).toFixed(2)}km)` : ''}
                  </div>
                </div>
                <button onclick="applyRoute('${result.method}', ${JSON.stringify(result.route).replace(/"/g, '&quot;')})" 
                        style="background: ${result.color}; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                  적용
                </button>
              </div>
              <div style="font-size: 0.8rem; color: #888; margin-top: 8px; line-height: 1.4;">
                ${result.route.slice(0, 3).join(' → ')}${result.route.length > 3 ? ` → ... (${result.route.length}곳)` : ''}
              </div>
            </div>
          `).join('')}
        </div>

        <div style="background: rgba(79, 172, 254, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
          <h4 style="color: #1b3c82; margin-bottom: 10px;">💡 실용적 경로 최적화 알고리즘</h4>
          <div style="font-size: 0.85rem; line-height: 1.5;">
            • <strong>지리 기반 최적화</strong>: 서울 지역 특성 반영, 강북/강남/강서 우선순위<br>
            • <strong>구역별 순회</strong>: 택배/배달 방식, 광진구 미세권역 그룹화<br>
            • <strong>교통 고려</strong>: 간선도로 혼잡도 반영, 지선도로 우선<br>
            • <strong>도로 위계 기반</strong>: 간선→집산→국지도로 순서<br>
            • <strong>Gemini AI</strong>: 지리적 지식 기반 추론<br>
            • <strong>기존 방식</strong>: Nearest Neighbor (비교용)
          </div>
        </div>
        
        <div style="text-align: center;">
          <button class="btn btn-primary" onclick="applyBestRoute(${JSON.stringify(results[0].route).replace(/"/g, '&quot;')})">
            🏆 최적 경로 적용
          </button>
          <button class="btn btn-secondary" onclick="closeComparisonModal()" style="margin-left: 10px;">
            닫기
          </button>
        </div>
      </div>
    </div>
  `;

  // Remove existing modal if any
  const existingModal = document.getElementById('comparisonModal');
  if (existingModal) {
    document.body.removeChild(existingModal);
  }

  // Add new modal to body
  document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function applyRoute(method, route) {
  optimizedRoute = route;
  alert(`${method} 경로가 적용되었습니다!`);
  closeComparisonModal();
  closeModal(); // Close main route modal
  selectMode('travel');
}

function applyBestRoute(route) {
  optimizedRoute = route;
  alert('최적 경로가 적용되었습니다!');
  closeComparisonModal();
  closeModal(); // Close main route modal
  selectMode('travel');
}

function closeComparisonModal() {
  const modal = document.getElementById('comparisonModal');
  if (modal) {
    document.body.removeChild(modal);
  }
}

// ===== 고급 경로 최적화 알고리즘 완료 =====

// Data Management Functions
let selectedAddressesForReset = new Set();

function updateDataStatus() {
  const totalAddresses = document.getElementById('total-addresses');
  const totalAddressesBottom = document.getElementById('total-addresses-bottom');
  
  if (totalAddresses) {
    totalAddresses.textContent = 주소목록.length;
  }
  if (totalAddressesBottom) {
    totalAddressesBottom.textContent = 주소목록.length;
  }
}

function showDataOptions() {
  document.getElementById('dataModal').classList.add('show');
}

// ===== 메인 앱 초기화 =====
// 페이지 로드시 초기화
document.addEventListener('DOMContentLoaded', function() {
  try {
    console.log('DOM 로드 완료 - 초기화 시작');
    
    loadAddressList();
    loadStatusData();
    loadMemoData(); 
    loadPhotoData();
    loadViewedAddresses();
    updateDataStatus();
    updateAddressPreview();
    updateTravelMode();
    
    // Initialize map selection UI
    updateMapSelection();
    
    console.log('초기화 완료');
  } catch (error) {
    console.error('초기화 오류:', error);
    alert('앱 초기화 중 오류가 발생했습니다: ' + error.message);
  }
});

// Legacy compatibility functions (empty implementations)
function showTab() {} // No longer used
function saveMemo() {} // Replaced by saveRecord
function showDropdown() {} // No longer used
function handleStatusChange() {} // Replaced by handleRecordStatusChange
function saveStatus() {} // Replaced by saveRecord
function openMapInNewTab() {} // Replaced by openMapForAddress

function resetSelectedAddresses() {
  if (selectedAddressesForReset.size === 0) return;
  
  const confirmMsg = '선택된 ' + selectedAddressesForReset.size + '개 출장지의 모든 데이터를 삭제하시겠습니까?\n\n삭제될 항목:\n' + Array.from(selectedAddressesForReset).join('\n') + '\n\n이 작업은 취소할 수 없습니다.';
  
  if (!confirm(confirmMsg)) return;
  
  // Remove selected addresses from all data structures
  selectedAddressesForReset.forEach(addr => {
    const index = 주소목록.indexOf(addr);
    if (index > -1) {
      주소목록.splice(index, 1);
    }
    delete statusMap[addr];
    delete memoMap[addr];
    delete photoMap[addr];
    delete originalPhotoMap[addr];
    viewedAddresses.delete(addr);
  });
  
  // Save to localStorage
  saveAddressList();
  localStorage.setItem('statusMap', JSON.stringify(statusMap));
  localStorage.setItem('memoMap', JSON.stringify(memoMap));
  localStorage.setItem('photoMap', JSON.stringify(photoMap));
  saveViewedAddresses();
  
  // Reset selection
  selectedAddressesForReset.clear();
  
  // Update UI
  updateDataStatus();
  updateAddressPreview();
  updateTravelMode();
  
  alert('선택된 출장지 데이터가 삭제되었습니다.');
  closeModal();
}

function confirmFullReset() {
  const confirmMsg = '모든 출장지와 기록을 완전히 삭제하시겠습니까?\n\n다음 데이터가 모두 삭제됩니다:\n- 모든 출장지 목록\n- 모든 출장 상태\n- 모든 메모\n- 모든 사진\n\n이 작업은 취소할 수 없습니다.';
  
  if (!confirm(confirmMsg)) return;
  
  // Clear all data
  주소목록 = [];
  statusMap = {};
  memoMap = {};
  photoMap = {};
  viewedAddresses.clear();
  AppState.currentAddress = null;
  
  // Clear localStorage
  localStorage.removeItem('addressList');
  localStorage.removeItem('statusMap');
  localStorage.removeItem('memoMap');
  localStorage.removeItem('photoMap');
  localStorage.removeItem('viewedAddresses');
  
  // Update UI
  updateDataStatus();
  updateAddressPreview();
  updateTravelMode();
  
  alert('모든 데이터가 삭제되었습니다.');
  closeModal();
}

function continueWithExistingData() {
  closeModal();
}

function closeModal() {
  document.querySelectorAll('.modal').forEach(modal => {
    modal.classList.remove('show');
  });
}


</script>
</body>
</html>

