<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ì§„ì¶œë¡œ â€“ ì¶œì¥ê¸¸ ë„ìš°ë¯¸</title>
  <style>
    /* Modern CSS Reset & Base Styles */
    *, *::before, *::after {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0;
      padding: 0;
      min-height: 100vh;
      color: #333;
    }
    
    .app-container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      min-height: 100vh;
    }
    
    /* Header Styles */
    .app-header {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 30px;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }
    
    .app-title {
      font-size: 2rem;
      font-weight: 700;
      color: #1b3c82;
      margin-bottom: 5px;
      cursor: pointer;
      transition: color 0.3s ease;
    }
    
    .app-title:hover {
      color: #4facfe;
    }
    
    .app-subtitle {
      color: #666;
      font-size: 1.1rem;
      margin-bottom: 15px;
    }
    
    /* Banner Styles */
    .app-banner {
      border-radius: 15px;
      padding: 0;
      margin: 15px 0 20px 0;
      overflow: hidden;
      position: relative;
      background: transparent;
    }
    
    .banner-image {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 15px;
    }
    
    /* Animations */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Mode Selection Styles */
    .mode-selector {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }
    
    .mode-card {
      background: rgba(255, 255, 255, 0.9);
      border: 2px solid transparent;
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .mode-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    }
    
    .mode-card.active {
      border-color: #1b3c82;
      background: #1b3c82;
      color: white;
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(27, 60, 130, 0.3);
    }
    
    .mode-icon {
      font-size: 2.5rem;
      margin-bottom: 10px;
      display: block;
    }
    
    .mode-title {
      font-weight: 600;
      font-size: 1.1rem;
      margin-bottom: 5px;
    }
    
    .mode-desc {
      font-size: 0.9rem;
      opacity: 0.8;
    }
    
    /* Card Styles */
    .card {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 25px;
      margin-bottom: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s ease;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
    }
    
    .card-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 2px solid #f0f0f0;
    }
    
    .card-icon {
      font-size: 1.5rem;
      color: #1b3c82;
    }
    
    .card-title {
      font-size: 1.3rem;
      font-weight: 600;
      color: #333;
      margin: 0;
    }
    
    .card-content {
      line-height: 1.6;
    }
    
    /* Form Styles */
    .form-group {
      margin-bottom: 20px;
    }
    
    .form-label {
      display: block;
      font-weight: 600;
      margin-bottom: 8px;
      color: #333;
    }
    
    .form-input, .form-select, .form-textarea {
      width: 100%;
      padding: 15px;
      border: 2px solid #e1e5e9;
      border-radius: 12px;
      font-size: 1rem;
      transition: all 0.3s ease;
      background: rgba(255, 255, 255, 0.8);
    }
    
    .form-input:focus, .form-select:focus, .form-textarea:focus {
      outline: none;
      border-color: #1b3c82;
      box-shadow: 0 0 0 3px rgba(27, 60, 130, 0.1);
      background: white;
    }
    
    .form-textarea {
      resize: vertical;
      min-height: 100px;
    }
    
    /* Button Styles */
    .btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 15px 25px;
      border: none;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      justify-content: center;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
    }
    
    .btn-secondary {
      background: rgba(255, 255, 255, 0.9);
      color: #333;
      border: 2px solid #e1e5e9;
    }
    
    .btn-secondary:hover {
      background: white;
      border-color: #1b3c82;
    }
    
    .btn-success {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      color: white;
    }
    
    .btn-danger {
      background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
      color: white;
    }
    
    .btn-info {
      background: #17a2b8;
      color: white;
      border: none;
    }
    
    .btn-info:hover {
      background: #138496;
    }
    
    .btn-warning {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
    }
    
    .btn-warning:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(245, 87, 108, 0.4);
    }
    
    .btn-full {
      width: 100%;
    }
    
    /* Map Selection Buttons */
    .map-option {
      background: rgba(255, 255, 255, 0.9);
      border: 2px solid #e1e5e9;
      border-radius: 15px;
      padding: 20px 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      font-family: inherit;
    }
    
    .map-option:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      border-color: #1b3c82;
    }
    
    .map-option.selected {
      background: #1b3c82;
      color: white;
      border-color: #1b3c82;
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(27, 60, 130, 0.3);
      position: relative;
    }
    
    .map-option.selected::after {
      content: "âœ“";
      position: absolute;
      top: 8px;
      right: 8px;
      background: #27ae60;
      color: white;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
    }
    
    .map-icon {
      width: 50px;
      height: 50px;
      margin: 0 auto 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      overflow: hidden;
    }
    
    .map-icon img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .map-name {
      font-weight: 600;
      font-size: 0.95rem;
    }
    
    /* Step Indicator */
    .step-indicator {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      margin-bottom: 30px;
    }
    
    .step {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    
    .step.completed {
      background: #4facfe;
      color: white;
    }
    
    .step.active {
      background: #1b3c82;
      color: white;
      transform: scale(1.1);
    }
    
    .step.pending {
      background: #f0f0f0;
      color: #999;
    }
    
    .step-line {
      width: 30px;
      height: 2px;
      background: #f0f0f0;
    }
    
    .step-line.completed {
      background: #4facfe;
    }
    
    /* Address Card Styles */
    .address-card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 15px;
      border-left: 5px solid #e1e5e9;
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    .address-card:hover {
      transform: translateX(5px);
      border-left-color: #1b3c82;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
    }
    
    .address-card.completed {
      border-left-color: #4facfe;
      background: rgba(79, 172, 254, 0.05);
    }
    
    .address-card.pending {
      border-left-color: #fa709a;
      background: rgba(250, 112, 154, 0.05);
    }
    
    .address-title {
      font-weight: 600;
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .address-status {
      font-size: 0.9rem;
      padding: 5px 12px;
      border-radius: 20px;
      font-weight: 500;
    }
    
    .status-completed {
      background: rgba(79, 172, 254, 0.2);
      color: #1b3c82;
    }
    
    .status-pending {
      background: rgba(250, 112, 154, 0.2);
      color: #c62828;
    }
    
    .status-none {
      background: rgba(0, 0, 0, 0.1);
      color: #666;
    }
    
    /* Photo Grid */
    .photo-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 10px;
      margin-top: 15px;
    }
    
    .photo-preview {
      width: 100%;
      height: 80px;
      border-radius: 10px;
      object-fit: cover;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px solid rgba(255, 255, 255, 0.8);
    }
    
    .photo-preview:hover {
      transform: scale(1.05);
      border-color: #1b3c82;
    }
    
    /* Data Management Styles */
    .data-management {
      text-align: center;
      padding: 15px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      backdrop-filter: blur(5px);
    }
    
    .data-status {
      font-size: 1rem;
      color: rgba(27, 60, 130, 0.8);
      font-weight: 500;
    }
    
    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
      z-index: 9999;
      align-items: center;
      justify-content: center;
    }
    
    .modal.show {
      display: flex;
    }
    
    .modal-content {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    
    .modal-header {
      text-align: center;
      margin-bottom: 25px;
    }
    
    .modal-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: #1b3c82;
      margin-bottom: 10px;
    }
    
    .modal-subtitle {
      color: #666;
      font-size: 0.95rem;
    }
    
    .option-grid {
      display: grid;
      gap: 15px;
      margin-bottom: 25px;
    }
    
    .option-card {
      background: rgba(255, 255, 255, 0.8);
      border: 2px solid #e1e5e9;
      border-radius: 12px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }
    
    .option-card:hover {
      border-color: #1b3c82;
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
    }
    
    .option-card.danger:hover {
      border-color: #e74c3c;
      background: rgba(231, 76, 60, 0.05);
    }
    
    .option-card.warning:hover {
      border-color: #f39c12;
      background: rgba(243, 156, 18, 0.05);
    }
    
    .option-icon {
      font-size: 2rem;
      margin-bottom: 10px;
    }
    
    .option-title {
      font-weight: 600;
      margin-bottom: 5px;
    }
    
    .option-desc {
      font-size: 0.9rem;
      color: #666;
    }
    
    /* Hide sections by default */
    .mode-section {
      display: none;
    }
    
    .mode-section.active {
      display: block;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .app-container {
        padding: 15px;
      }
      
      .header-logo {
        max-width: 70px !important;
        height: auto !important;
        width: auto !important;
      }
      
      .mode-selector {
        grid-template-columns: 1fr 1fr 1fr 1fr;
        gap: 8px;
      }
      
      .mode-card {
        padding: 12px 8px;
        text-align: center;
      }
      
      .mode-icon {
        font-size: 1.8rem;
        margin-bottom: 5px;
      }
      
      .mode-title {
        font-size: 0.85rem;
        margin-bottom: 0;
      }
      
      .mode-desc {
        display: none;
      }
      
      .card {
        padding: 20px;
      }
      
      .app-title {
        font-size: 1.7rem;
      }
      
      .btn {
        padding: 12px 20px;
      }
      
      .card-header .btn {
        padding: 6px 10px !important;
        font-size: 0.8rem !important;
      }
      
      .map-button-selector {
        grid-template-columns: 1fr 1fr 1fr !important;
        gap: 10px !important;
      }
      
      .map-option {
        padding: 15px 10px !important;
      }
      
      .map-name {
        font-size: 0.85rem !important;
      }
      
      .modal-content {
        padding: 20px;
        max-height: 85vh;
        width: 95%;
      }
      
      .modal-title {
        font-size: 1.3rem;
      }
      
      .modal-subtitle {
        font-size: 0.9rem;
      }
    }
    
    @media (max-width: 480px) {
      .app-header img {
        height: 35px !important;
        width: 50% !important;
      }
      
      .app-title {
        font-size: 1.4rem !important;
      }
      
      .app-subtitle {
        font-size: 0.8rem !important;
      }
      
      .mode-selector {
        grid-template-columns: 1fr 1fr 1fr 1fr;
        gap: 6px;
      }
      
      .mode-card {
        padding: 10px 6px;
      }
      
      .mode-icon {
        font-size: 1.5rem;
        margin-bottom: 3px;
      }
      
      .mode-title {
        font-size: 0.75rem;
      }
      
      .step-indicator {
        gap: 10px;
      }
      
      .step {
        width: 35px;
      }
      
      .modal-content {
        padding: 15px;
        max-height: 90vh;
        width: 98%;
        margin: 5vh auto;
      }
      
      .modal-title {
        font-size: 1.2rem;
      }
      
      .modal-subtitle {
        font-size: 0.85rem;
      }
      
      .form-group {
        margin-bottom: 15px !important;
      }
      
      .form-input {
        padding: 12px !important;
        font-size: 16px !important; /* Prevents zoom on iOS */
      }
    }
    
    /* Legacy styles for compatibility */
    .dropdown-item.memo-marked::after {
      content: "\1F4DD";
      float: right;
      margin-left: 8px;
      font-size: 1rem;
    }
    
    #customDropdown {
      position: absolute;
      z-index: 1000;
      background-color: white;
      width: calc(100% - 22px);
      border-radius: 12px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }
    header {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 10px;
    }
    header > div {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
    }
    header img {
      height: 36px;
      cursor: pointer;
    }
    header span {
      color: #1b3c82;
    }
    header .sub {
      color: #555;
    }
    #bannerImage {
      width: 100%;
      max-width: 100%;
      display: none;
      margin-top: 8px;
      border-radius: 8px;
    }
  .tabs {
  display: flex;
  justify-content: center;
  flex-wrap: nowrap;
  overflow-x: auto;
  gap: 8px;
  margin-bottom: 10px;
}
.tabs button {
  flex: 0 1 auto; /* ì¤„ì–´ë“¤ê±°ë‚˜ ëŠ˜ì–´ë‚˜ì§€ ì•Šë„ë¡ ì¡°ì • */
  white-space: nowrap;
  padding: 8px 16px;
}
    .tabs button.active {
      background-color: #1b3c82;
      color: #fff;
    }
    .tab-content {
      display: none;
      background: white;
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .tab-content.active {
      display: block;
    }
    .card-ui {
      background-color: #fff;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
      padding: 15px;
      margin-bottom: 15px;

    }
    input[type="text"], input[type="file"], select, button, textarea {
      width: 100%;
      margin-bottom: 8px;
      padding: 10px;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-sizing: border-box;
    }
    #customStatusInput {
      background-color: #fff8dc;
      border-color: #f0c36d;
    }
    textarea {
      resize: vertical;
      height: 100px;
    }
    .dropdown-item {
      padding: 6px;
      font-size: 0.9rem;
      cursor: pointer;
    }
    .dropdown-item.viewed {
      background-color: #e0f7fa;
    }
    .status-marked {
      font-weight: bold;
    }
    canvas {
      width: 100%;
      max-width: 400px;
      height: auto;
      display: block;
      margin: 10px auto;
    }
    #chartTextOutput {
      margin-top: 10px;
      text-align: center;
      font-size: 0.9rem;
    }
tr.status-ì¶œì¥ì™„ë£Œ { background-color: #e8f5e9; }
tr.status-ë¯¸ì¶œì¥ { background-color: #ffebee; }
tr.status-ë¯¸ì„ íƒ { background-color: #eceff1; }

/* ê¸°íƒ€ ì§ì ‘ì…ë ¥ ìƒíƒœ (ì»¤ìŠ¤í…€) */
tr.status-ì§ì ‘ì…ë ¥ {
  background-color: #fff9c4; /* ì—°ë…¸ë‘ */
}
    footer {
      display: flex;
      justify-content: center;
      align-items: center;
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      padding: 12px;
      margin-top: 30px;
      font-size: 0.8rem;
      color: #888;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- App Header -->
    <div class="app-header">
      <div style="position: relative; text-align: center;">
        <img src="https://www.gwangjin.go.kr/editorUpload/images/000196/20221007110449234_IXETSNKL.png" alt="ê´‘ì§„êµ¬ CI" class="header-logo" style="position: absolute; left: 0; top: 50%; transform: translateY(-50%); height: 50px; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));">
        <div class="app-title" onclick="goHome()">ì§„ì¶œë¡œ (é€²å‡ºè·¯)</div>
        <div class="app-subtitle">ê´‘ì§„êµ¬ì²­ ì¶œì¥ê¸¸ ìŠ¤ë§ˆíŠ¸ ë„ìš°ë¯¸</div>
      </div>
      
      <!-- Mode Selection -->
      <div class="mode-selector">
        <div class="mode-card active" data-mode="prepare" onclick="selectMode('prepare')">
          <span class="mode-icon">ğŸ“‹</span>
          <div class="mode-title">ì¤€ë¹„ëª¨ë“œ</div>
          <div class="mode-desc">ì¶œì¥ ì¤€ë¹„</div>
        </div>
        
        <div class="mode-card" data-mode="travel" onclick="selectMode('travel')">
          <span class="mode-icon">ğŸš—</span>
          <div class="mode-title">ì¶œì¥ëª¨ë“œ</div>
          <div class="mode-desc">í˜„ì¥ ì´ë™</div>
        </div>
        
        <div class="mode-card" data-mode="record" onclick="selectMode('record')">
          <span class="mode-icon">ğŸ“</span>
          <div class="mode-title">ê¸°ë¡ëª¨ë“œ</div>
          <div class="mode-desc">ë©”ëª¨ ì‘ì„±</div>
        </div>
        
        <div class="mode-card" data-mode="summary" onclick="selectMode('summary')">
          <span class="mode-icon">ğŸ“ˆ</span>
          <div class="mode-title">ì •ë¦¬ëª¨ë“œ</div>
          <div class="mode-desc">ë°ì´í„° ì •ë¦¬</div>
        </div>
      </div>
    </div>

    <!-- Prepare Mode -->
    <div id="mode-prepare" class="mode-section active">
      <!-- Step Indicator -->
      <div class="step-indicator">
        <div class="step active" data-step="1" onclick="goToStep(1)" style="cursor: pointer;" title="1ë‹¨ê³„: ì§€ë„ ì•± ì„ íƒ">1</div>
        <div class="step-line"></div>
        <div class="step pending" data-step="2" onclick="goToStep(2)" style="cursor: pointer;" title="2ë‹¨ê³„: ì¶œì¥ì§€ ì…ë ¥">2</div>
        <div class="step-line"></div>
        <div class="step pending" data-step="3" onclick="goToStep(3)" style="cursor: pointer;" title="3ë‹¨ê³„: ì¶œì¥ì§€ í™•ì¸">3</div>
      </div>
      
      <!-- Step 1: Map Selection -->
      <div class="card" id="step-map">
        <div class="card-header">
          <span class="card-icon">ğŸ—ºï¸</span>
          <h3 class="card-title">1ë‹¨ê³„: ì§€ë„ ì•± ì„ íƒ</h3>
        </div>
        <div class="card-content">
          <div class="form-group">
            <label class="form-label">ì‚¬ìš©í•  ì§€ë„ ì•±ì„ ì„ íƒí•˜ì„¸ìš”</label>
            
            <!-- Map Selection Buttons -->
            <div class="map-selector map-button-selector" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin-bottom: 20px;">
              <button class="map-option" data-map="naver" onclick="selectMapApp('naver')">
                <div class="map-icon">
                  <img src="https://chrisryugj.github.io/GJRoad/images/nmap.jpg" alt="ë„¤ì´ë²„ì§€ë„">
                </div>
                <div class="map-name">ë„¤ì´ë²„ì§€ë„</div>
              </button>
              
              <button class="map-option" data-map="kakao" onclick="selectMapApp('kakao')">
                <div class="map-icon">
                  <img src="https://chrisryugj.github.io/GJRoad/images/kmap.jpg" alt="ì¹´ì¹´ì˜¤ë§µ">
                </div>
                <div class="map-name">ì¹´ì¹´ì˜¤ë§µ</div>
              </button>
              
              <button class="map-option" data-map="google" onclick="selectMapApp('google')">
                <div class="map-icon">
                  <img src="https://chrisryugj.github.io/GJRoad/images/gmap.jpg" alt="êµ¬ê¸€ì§€ë„">
                </div>
                <div class="map-name">êµ¬ê¸€ì§€ë„</div>
              </button>
            </div>
            
            <!-- Remember Choice Checkbox -->
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px;">
              <input type="checkbox" id="rememberMap" checked style="width: auto; transform: scale(1.2);">
              <label for="rememberMap" style="margin: 0; font-size: 0.95rem; color: #666;">
                ì„ íƒí•œ ì§€ë„ ì•±ì„ ê¸°ì–µí•˜ê¸°
              </label>
            </div>
            
            <!-- Continue Button -->
            <button id="continueStep2" class="btn btn-primary btn-full" onclick="nextStep(2)" style="display: none;">
              â¡ï¸ 2ë‹¨ê³„ë¡œ ê³„ì†
            </button>
            
            <!-- Hidden select for compatibility -->
            <select id="mapSelect" style="display: none;">
              <option value="naver">ë„¤ì´ë²„ì§€ë„</option>
              <option value="kakao">ì¹´ì¹´ì˜¤ë§µ</option>
              <option value="google">êµ¬ê¸€ì§€ë„</option>
            </select>
          </div>
        </div>
      </div>
      
      <!-- Step 2: Address Input -->
      <div class="card" id="step-input" style="display: none;">
        <div class="card-header">
          <span class="card-icon">ğŸ </span>
          <h3 class="card-title">2ë‹¨ê³„: ì¶œì¥ì§€ ì…ë ¥</h3>
        </div>
        <div class="card-content">
          <!-- Default: Single Address Input -->
          <div class="form-group">
            <label class="form-label">ê°œë³„ ì…ë ¥</label>
            <input type="text" id="singleAddress" class="form-input" placeholder="ì£¼ì†Œë¥¼ ì…ë ¥í•˜ì„¸ìš”">
            <button class="btn btn-success btn-full" onclick="addSingleAddress()" style="margin-top: 10px;">
              â• ì¶œì¥ì§€ ì¶”ê°€
            </button>
          </div>
          <div id="added-addresses" class="form-group"></div>
          <button class="btn btn-primary btn-full" onclick="completeAddressInput()" style="display: none;" id="complete-btn">
            âœ“ ì…ë ¥ ì™„ë£Œ
          </button>
          
          <!-- Alternative Methods -->
          <div style="margin-top: 30px; border-top: 2px solid #f0f0f0; padding-top: 20px;">
            <div class="form-label" style="margin-bottom: 15px;">ë‹¤ë¥¸ ì…ë ¥ ë°©ë²•</div>
            <div style="display: grid; gap: 10px;">
              <button class="btn btn-secondary" onclick="toggleInputMethod('file')">
                ğŸ“ íŒŒì¼ ì—…ë¡œë“œ
              </button>
              <button class="btn btn-secondary" onclick="toggleInputMethod('bulk')">
                ğŸ“‹ ì¼ê´„ ë¶™ì—¬ë„£ê¸°
              </button>
            </div>
          </div>
          
          <!-- File Upload (Hidden by default) -->
          <div id="file-input-section" style="display: none; margin-top: 20px; padding: 20px; background: rgba(0,0,0,0.05); border-radius: 12px;">
            <div class="form-group">
              <label class="form-label">TXT ë˜ëŠ” CSV íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”</label>
              <input type="file" id="fileUpload" class="form-input" accept=".txt,.csv" onchange="loadAddressFile(event)">
            </div>
          </div>
          
          <!-- Bulk Paste (Hidden by default) -->
          <div id="bulk-input-section" style="display: none; margin-top: 20px; padding: 20px; background: rgba(0,0,0,0.05); border-radius: 12px;">
            <div class="form-group">
              <label class="form-label">ì£¼ì†Œë¥¼ ì¤„ ë‹¨ìœ„ë¡œ ë¶™ì—¬ë„£ì–´ ì£¼ì„¸ìš”</label>
              <textarea id="bulkPaste" class="form-textarea" placeholder="ì˜ˆ:
ì„œìš¸ì‹œ ê´‘ì§„êµ¬ êµ¬ì˜ë™ 123
ì„œìš¸ì‹œ ê´‘ì§„êµ¬ ìì–‘ë™ 456
..."></textarea>
              <button class="btn btn-success btn-full" onclick="addFromTextarea()" style="margin-top: 10px;">
                ğŸ’¾ ì¶œì¥ì§€ ì €ì¥
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Step 3: Address List Preview -->
      <div class="card" id="step-preview" style="display: none;">
        <div class="card-header">
          <span class="card-icon">ğŸ“‹</span>
          <h3 class="card-title">3ë‹¨ê³„: ì¶œì¥ì§€ ëª©ë¡ í™•ì¸</h3>
        </div>
        <div class="card-content">
          <div id="address-preview-list"></div>
          <div style="margin-top: 20px;">
            <button class="btn btn-primary btn-full" onclick="selectMode('travel')">
              ğŸš— ì¶œì¥ ì‹œì‘
            </button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Travel Mode -->
    <div id="mode-travel" class="mode-section">
      <div class="card">
        <div class="card-header">
          <span class="card-icon">ğŸš—</span>
          <h3 class="card-title">ì¶œì¥ì§€ ëª©ë¡</h3>
          <button class="btn btn-warning" onclick="showOptimalRouteModal()" style="flex: 1; padding: 10px; margin-left: 10px; max-width: 140px;" title="AIê°€ ìµœì  ê²½ë¡œë¥¼ ì¶”ì²œí•©ë‹ˆë‹¤">
            ğŸ¯ ìµœì ê²½ë¡œ ì¶”ì²œ
          </button>
        </div>
        <div class="card-content">
          <div id="travel-address-list"></div>
        </div>
      </div>
    </div>
    
    <!-- Record Mode -->
    <div id="mode-record" class="mode-section">
      <div class="card" id="record-card">
        <div class="card-header">
          <span class="card-icon">ğŸ“</span>
          <h3 class="card-title" id="record-title">ê¸°ë¡ ì‘ì„±</h3>
        </div>
        <div class="card-content">
          <!-- Address selection for record mode -->
          <div id="record-address-selector" class="form-group" style="display: none;">
            <label class="form-label">ê¸°ë¡í•  ì¶œì¥ì§€ ì„ íƒ</label>
            <select id="recordAddressSelect" class="form-select" onchange="selectRecordAddress()">
              <option value="" disabled selected>ì¶œì¥ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>
            </select>
            <div style="font-size: 0.85rem; color: #666; margin-top: 5px;">
              ğŸ’¡ ê¸°ë¡ì„ ì‘ì„±í•  ì¶œì¥ì§€ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”
            </div>
          </div>
          
          <div class="form-group">
            <label class="form-label">ì¶œì¥ ìƒíƒœ ì„ íƒ</label>
            <select id="recordStatusSelect" class="form-select" onchange="handleRecordStatusChange()">
              <option value="" disabled selected>ìƒíƒœ ì„ íƒ</option>
              <option value="ì¶œì¥ì™„ë£Œ">ì¶œì¥ì™„ë£Œ</option>
              <option value="ë¯¸ì¶œì¥">ë¯¸ì¶œì¥</option>
              <option value="ì§ì ‘ì…ë ¥">ì§ì ‘ì…ë ¥</option>
            </select>
            <input type="text" id="customRecordStatus" class="form-input" placeholder="ìƒíƒœ ì§ì ‘ ì…ë ¥" style="display: none; margin-top: 10px;">
          </div>
          
          <div class="form-group">
            <label class="form-label">í˜„ì¥ ë©”ëª¨</label>
            <textarea id="recordMemo" class="form-textarea" placeholder="í˜„ì¥ íŠ¹ì´ì‚¬í•­ì´ë‚˜ ì°¸ê³  ë©”ëª¨ë¥¼ ë‚¨ê¸°ì„¸ìš”"></textarea>
          </div>
          
          <div class="form-group">
            <label class="form-label">í˜„ì¥ ì‚¬ì§„ (ìµœëŒ€ 5ì¥)</label>
            <input type="file" id="recordPhotoInput" class="form-input" accept="image/*" multiple onchange="saveRecordPhoto()">
            <div id="recordPhotoContainer" class="photo-grid"></div>
          </div>
          
          <button class="btn btn-success btn-full" onclick="saveRecord()">
            ğŸ’¾ ê¸°ë¡ ì €ì¥
          </button>
        </div>
      </div>
    </div>
    
    <!-- Summary Mode -->
    <div id="mode-summary" class="mode-section">
      <div class="card">
        <div class="card-header">
          <span class="card-icon">ğŸ“ˆ</span>
          <h3 class="card-title">ì¶œì¥ í†µê³„</h3>
        </div>
        <div class="card-content">
          <div id="statsCount" style="text-align: center; font-weight: bold; margin-bottom: 20px; font-size: 1.2rem;"></div>
          <canvas id="statusChart" width="400" height="300"></canvas>
          <div id="chartTextOutput" style="text-align: center; margin-top: 15px; font-size: 0.95rem;"></div>
        </div>
      </div>
      
      <div class="card">
        <div class="card-header">
          <span class="card-icon">ğŸ“Š</span>
          <h3 class="card-title">ì „ì²´ ëª©ë¡</h3>
        </div>
        <div class="card-content">
          <div id="tableSummary" style="text-align: center; margin-bottom: 20px; font-weight: 600;"></div>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 20px;">
            <button class="btn btn-secondary" onclick="copyTable()">
              ğŸ“„ ë³µì‚¬í•˜ê¸°
            </button>
            <button class="btn btn-secondary" onclick="exportText()">
              ğŸ“ í…ìŠ¤íŠ¸ ë‹¤ìš´ë¡œë“œ
            </button>
            <button class="btn btn-success" onclick="exportExcel()">
              ğŸ“… ì—‘ì…€ë¡œ ë‹¤ìš´ë¡œë“œ
            </button>
          </div>
          <div style="overflow-x: auto;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
              <thead>
                <tr style="background: rgba(27, 60, 130, 0.1); border-bottom: 2px solid #1b3c82;">
                  <th style="padding: 15px; text-align: center; font-weight: 600; width: 60px;">ìˆœì„œ</th>
                  <th style="padding: 15px; text-align: left; font-weight: 600;">ì£¼ì†Œ</th>
                  <th style="padding: 15px; text-align: left; font-weight: 600;">ìƒíƒœ</th>
                  <th style="padding: 15px; text-align: left; font-weight: 600;">ë©”ëª¨</th>
                  <th style="padding: 15px; text-align: left; font-weight: 600;">ì‚¬ì§„</th>
                </tr>
              </thead>
              <tbody id="tableBody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <!-- Data Management Section -->
    <div class="card">
      <div class="card-header">
        <span class="card-icon">ğŸ—‚ï¸</span>
        <h3 class="card-title">ë°ì´í„° ê´€ë¦¬</h3>
      </div>
      <div class="card-content">
        <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: rgba(27, 60, 130, 0.1); border-radius: 10px;">
          <span style="font-size: 1.1rem; font-weight: 600; color: #1b3c82;">
            ğŸ—‚ï¸ <span id="total-addresses-bottom">0</span>ê°œ ì¶œì¥ì§€ ë“±ë¡ë¨
          </span>
        </div>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
          <button class="btn btn-warning" onclick="resetAddressList()">
            ğŸ—‘ï¸ ëª©ë¡ ì´ˆê¸°í™”
          </button>
          <button class="btn btn-secondary" onclick="showDataOptions()">
            ğŸ“Š ë°ì´í„° í˜„í™©
          </button>
        </div>
      </div>
    </div>

    <!-- Copyright Section -->
    <div style="text-align: center; margin-top: 30px; padding: 20px; border-top: 1px solid rgba(255,255,255,0.2); color: rgba(255,255,255,0.7); font-size: 0.9rem;">
      <p style="margin: 0;">Â© 2025 ì§„ì¶œë¡œ - ì¶œì¥ê¸¸ ë„ìš°ë¯¸</p>
      <p style="margin: 5px 0 0 0;">(c) ê´‘ì§„êµ¬ì²­ ê°€ë¡œê²½ê´€ê³¼ ê°œì¹œì ˆí•œ ë¥˜ì£¼ì„</p>
    </div>
  </div>
  
  <!-- Hidden elements for compatibility -->
  <div style="display: none;">
    <!-- Legacy elements for compatibility -->
    <input id="addrInput" name="no_autofill" type="text" style="display: none;">
    <div id="memoSection" style="display: none;">
      <textarea id="memoInput"></textarea>
      <input type="file" id="photoInput" accept="image/*" multiple>
      <div id="photoContainer" class="photo-grid"></div>
    </div>
    <div id="customDropdown" style="display: none;"></div>
    <select id="statusSelect" style="display: none;">
      <option value="">ì„ íƒ</option>
      <option value="ì¶œì¥ì™„ë£Œ">ì¶œì¥ì™„ë£Œ</option>
      <option value="ë¯¸ì¶œì¥">ë¯¸ì¶œì¥</option>
      <option value="ì§ì ‘ì…ë ¥">ì§ì ‘ì…ë ¥</option>
    </select>
    <input id="customStatusInput" type="text" style="display: none;">
</div>

  
  <!-- Data Management Modal -->
  <div id="dataModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">ğŸ“Š ë°ì´í„° ê´€ë¦¬</div>
        <div class="modal-subtitle">ì¶œì¥ ê¸°ë¡ì„ ê´€ë¦¬í•˜ê±°ë‚˜ ì´ˆê¸°í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</div>
      </div>
      
      <div class="option-grid">
        <div class="option-card" onclick="continueWithExistingData()">
          <div class="option-icon">âœ…</div>
          <div class="option-title">ê¸°ì¡´ ë°ì´í„°ë¡œ ê³„ì†í•˜ê¸°</div>
          <div class="option-desc">ì €ì¥ëœ ì¶œì¥ì§€ì™€ ê¸°ë¡ì„ ìœ ì§€í•©ë‹ˆë‹¤</div>
        </div>
        
        <div class="option-card warning" onclick="showResetOptions()">
          <div class="option-icon">ğŸ”„</div>
          <div class="option-title">ë°ì´í„° ì´ˆê¸°í™”</div>
          <div class="option-desc">ì¼ë¶€ ë˜ëŠ” ì „ì²´ ë°ì´í„°ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤</div>
        </div>
      </div>
      
      <div style="text-align: center;">
        <button class="btn btn-secondary" onclick="closeModal()">
          ì·¨ì†Œ
        </button>
      </div>
    </div>
  </div>
  
  <!-- Reset Options Modal -->
  <div id="resetModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">ğŸ”„ ë°ì´í„° ì´ˆê¸°í™” ì˜µì…˜</div>
        <div class="modal-subtitle">ì´ˆê¸°í™”í•  ë°ì´í„° ë²”ìœ„ë¥¼ ì„ íƒí•˜ì„¸ìš”</div>
      </div>
      
      <div class="option-grid">
        <div class="option-card" onclick="showAddressSelector()">
          <div class="option-icon">ğŸ¯</div>
          <div class="option-title">ì„ íƒ ì´ˆê¸°í™”</div>
          <div class="option-desc">íŠ¹ì • ì¶œì¥ì§€ì˜ ê¸°ë¡ë§Œ ì‚­ì œí•©ë‹ˆë‹¤</div>
        </div>
        
        <div class="option-card danger" onclick="confirmFullReset()">
          <div class="option-icon">ğŸ’¥</div>
          <div class="option-title">ì „ì²´ ì´ˆê¸°í™”</div>
          <div class="option-desc">ëª¨ë“  ì¶œì¥ì§€ì™€ ê¸°ë¡ì„ ì™„ì „íˆ ì‚­ì œí•©ë‹ˆë‹¤</div>
        </div>
      </div>
      
      <div style="display: flex; gap: 10px; justify-content: center;">
        <button class="btn btn-secondary" onclick="showResetOptions()">
          â† ë’¤ë¡œ
        </button>
        <button class="btn btn-secondary" onclick="closeModal()">
          ì·¨ì†Œ
        </button>
      </div>
    </div>
  </div>
  
  <!-- Address Selector Modal -->
  <div id="addressSelectorModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">ğŸ¯ ì¶œì¥ì§€ ì„ íƒ</div>
        <div class="modal-subtitle">ì´ˆê¸°í™”í•  ì¶œì¥ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”</div>
      </div>
      
      <div id="address-selector-list" style="max-height: 300px; overflow-y: auto; margin-bottom: 20px;">
        <!-- Address list will be populated here -->
      </div>
      
      <div style="display: flex; gap: 10px; justify-content: center;">
        <button class="btn btn-danger" onclick="resetSelectedAddresses()" id="reset-selected-btn" style="display: none;">
          ğŸ—‘ï¸ ì„ íƒëœ í•­ëª© ì‚­ì œ
        </button>
        <button class="btn btn-secondary" onclick="showResetOptions()">
          â† ë’¤ë¡œ
        </button>
        <button class="btn btn-secondary" onclick="closeModal()">
          ì·¨ì†Œ
        </button>
      </div>
    </div>
  </div>
  
  <!-- Optimal Route Modal -->
  <div id="optimalRouteModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">ğŸ—ºï¸ ìµœì ê²½ë¡œ ì¶”ì²œ</div>
        <div class="modal-subtitle">AIê°€ ê°€ì¥ íš¨ìœ¨ì ì¸ ì¶œì¥ ê²½ë¡œë¥¼ ì¶”ì²œí•´ë“œë¦½ë‹ˆë‹¤</div>
      </div>
      
      <div class="form-group" style="margin-bottom: 25px;">
        <label class="form-label">ì¶œë°œì§€ ê¸°ì¤€</label>
        <input type="text" id="startLocation" class="form-input" placeholder="ì¶œë°œì§€ ì£¼ì†Œë¥¼ ì…ë ¥í•˜ì„¸ìš”" value="ì•„ì°¨ì‚°ë¡œ 400">
        <div style="font-size: 0.85rem; color: #666; margin-top: 5px;">
          ğŸ“ í˜„ì¬ ìœ„ì¹˜ ë˜ëŠ” ìì£¼ ì¶œë°œí•˜ëŠ” ì¥ì†Œë¥¼ ì…ë ¥í•˜ì„¸ìš”
        </div>
      </div>
      
      <div style="background: rgba(79, 172, 254, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 25px;">
        <div style="font-size: 0.9rem; color: #1b3c82;">
          <strong>ğŸ“‹ ë¶„ì„í•  ì¶œì¥ì§€ (ì´ <span id="route-address-count">0</span>ê³³)</strong>
        </div>
        <div id="route-address-preview" style="margin-top: 10px; font-size: 0.85rem; color: #666;">
          <!-- Address list preview will be shown here -->
        </div>
      </div>
      
      <!-- API Key Section for Route Calculation -->
      <div id="route-api-key-section" style="background: #f8f9fa; padding: 15px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #e74c3c;">
        <div style="display: flex; align-items: center; margin-bottom: 10px;">
          <span style="color: #e74c3c; font-weight: bold; margin-right: 10px;">ğŸ” Gemini API í‚¤</span>
          <span id="route-api-status" style="font-size: 12px; padding: 4px 8px; border-radius: 4px;"></span>
        </div>
        <div style="display: flex; gap: 10px; margin-bottom: 8px;">
          <input type="password" id="route-api-key-input" placeholder="Gemini API í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”" 
                 style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
          <button onclick="saveRouteApiKey()" style="background: #27ae60; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">ì €ì¥</button>
          <button onclick="testRouteApiKey()" style="background: #3498db; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">í…ŒìŠ¤íŠ¸</button>
        </div>
        <div style="font-size: 11px; color: #666;">
          â€¢ <a href="https://console.cloud.google.com/apis/credentials" target="_blank" style="color: #3498db;">Google Cloud Console</a>ì—ì„œ ë¬´ë£Œ ë°œê¸‰ â€¢ ë¡œì»¬ ì €ì¥ë˜ë©° ì™¸ë¶€ ì „ì†¡ ì•ˆë¨
        </div>
      </div>
      
      <div style="display: flex; gap: 15px; justify-content: center;">
        <button class="btn btn-success btn-full" onclick="calculateOptimalRoute()" id="calculate-route-btn">
          ğŸ¯ ê³ ê¸‰ ê²½ë¡œ ìµœì í™” (TSP + AI)
        </button>
      </div>
      
      <div style="text-align: center; margin: 10px 0; font-size: 12px; color: #666;">
        ğŸ“Š ì¢Œí‘œ ë³€í™˜ â†’ ê±°ë¦¬ ê³„ì‚° â†’ êµ°ì§‘ ë¶„ì„ â†’ TSP ì•Œê³ ë¦¬ì¦˜ â†’ AI ê²€ì¦
      </div>
      
      <div style="display: flex; gap: 10px; justify-content: center; margin-top: 10px;">
        <button class="btn btn-secondary" onclick="compareRouteAlgorithms()" style="font-size: 0.85rem;">
          ğŸ” ì•Œê³ ë¦¬ì¦˜ ë¹„êµ
        </button>
        <button class="btn btn-secondary" onclick="showManualRouteEditor()" style="font-size: 0.85rem;">
          âœï¸ ìˆ˜ë™ í¸ì§‘
        </button>
      </div>
      
      <div style="display: flex; gap: 10px; justify-content: center; margin-top: 15px;">
        <button class="btn btn-secondary" onclick="clearCoordinateCache()" style="font-size: 0.85rem;">
          ğŸ—‘ï¸ ì¢Œí‘œ ì´ˆê¸°í™”
        </button>
        <button class="btn btn-secondary" onclick="downloadDebugLogs()" style="font-size: 0.85rem;">
          ğŸ“‹ ë¡œê·¸ ë‹¤ìš´ë¡œë“œ
        </button>
        <button class="btn btn-secondary" onclick="closeModal()">
          ì·¨ì†Œ
        </button>
      </div>
      
      <!-- Loading indicator -->
      <div id="route-loading" style="display: none; text-align: center; margin-top: 20px;">
        <div style="font-size: 2rem; animation: spin 1s linear infinite;">âš™ï¸</div>
        <div style="margin-top: 10px; color: #666;">AIê°€ ìµœì ê²½ë¡œë¥¼ ê³„ì‚°ì¤‘ì…ë‹ˆë‹¤...</div>
      </div>
    </div>
  </div>
  
  <footer style="text-align: center; padding: 20px; color: rgba(255, 255, 255, 0.7); font-size: 0.9rem;">
    Â© 2025 ê´‘ì§„êµ¬ì²­ ê°€ë¡œê²½ê´€ê³¼ Â· ì§„ì¶œë¡œ v2.0
  </footer>
  
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script>
// App State Management
const AppState = {
  currentMode: 'prepare',
  currentStep: 1,
  currentAddress: null,
  inputMethod: null
};

// Data Storage
const originalPhotoMap = {};
let preferredMap = localStorage.getItem("preferredMap") || "naver";
let statusMap = JSON.parse(localStorage.getItem("statusMap")) || {};
let memoMap = JSON.parse(localStorage.getItem("memoMap")) || {};
let photoMap = JSON.parse(localStorage.getItem("photoMap")) || {};
let ì£¼ì†Œëª©ë¡ = JSON.parse(localStorage.getItem("addressList")) || [];
let viewedAddresses = new Set(JSON.parse(localStorage.getItem("viewedAddresses")) || []);

// Route optimization data
let coordinatesCache = JSON.parse(localStorage.getItem("coordinatesCache")) || {};
let optimizedRoute = [];

// Route Optimization Functions
// Haversine formula to calculate distance between two points
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Earth's radius in kilometers
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// Geocode address using multiple services
async function geocodeAddress(address) {
  // Check cache first
  if (coordinatesCache[address]) {
    // Validate cached coordinates
    const cached = coordinatesCache[address];
    if (cached && cached.lat && cached.lng && 
        cached.lat >= 37.4 && cached.lat <= 37.7 && 
        cached.lng >= 126.8 && cached.lng <= 127.3) {
      return cached;
    }
    // Invalid cache, remove it
    delete coordinatesCache[address];
  }

  const cleanAddress = address.replace(/\s*\([^)]*\)\s*$/, '').trim();
  addDebugLog('ì£¼ì†Œ ì¢Œí‘œ ë³€í™˜ ì‹œì‘', { original: address, clean: cleanAddress });
  
  try {
    // Try Kakao Maps API first (most accurate for Korean addresses)
    const kakaoResult = await geocodeWithKakao(cleanAddress);
    if (kakaoResult) {
      coordinatesCache[address] = kakaoResult;
      localStorage.setItem("coordinatesCache", JSON.stringify(coordinatesCache));
      addDebugLog('ì¹´ì¹´ì˜¤ API ì¢Œí‘œ ë³€í™˜ ì„±ê³µ', { address, coordinates: kakaoResult });
      return kakaoResult;
    }

    // Fallback to OpenStreetMap Nominatim (free, no API key required)
    const nominatimResult = await geocodeWithNominatim(cleanAddress + ' ì„œìš¸');
    if (nominatimResult) {
      coordinatesCache[address] = nominatimResult;
      localStorage.setItem("coordinatesCache", JSON.stringify(coordinatesCache));
      addDebugLog('Nominatim API ì¢Œí‘œ ë³€í™˜ ì„±ê³µ', { address, coordinates: nominatimResult });
      return nominatimResult;
    }
  } catch (error) {
    addDebugLog('API ì¢Œí‘œ ë³€í™˜ ì‹¤íŒ¨', { error: error.message });
  }

  // Enhanced address-specific coordinate mapping
  const addressCoords = {
    // ì•„ì°¨ì‚°ë¡œ ê¶Œì—­
    'ì•„ì°¨ì‚°ë¡œ': { lat: 37.5385, lng: 127.0823 },
    'ì•„ì°¨ì‚°ë¡œ17ê°€ê¸¸': { lat: 37.5395, lng: 127.0853 },  
    'ì•„ì°¨ì‚°ë¡œ32ê¸¸': { lat: 37.5375, lng: 127.0803 },
    
    // ë™ì¼ë¡œ ê¶Œì—­ (êµ¬ë¦¬ ë°©í–¥)
    'ë™ì¼ë¡œ': { lat: 37.5420, lng: 127.0950 },
    'ë™ì¼ë¡œ322': { lat: 37.5430, lng: 127.0980 },
    
    // êµ¬ì˜ê°•ë³€ ê¶Œì—­
    'êµ¬ì˜ê°•ë³€ë¡œ': { lat: 37.5350, lng: 127.0750 },
    'êµ¬ì˜ê°•ë³€ë¡œ5ê¸¸': { lat: 37.5340, lng: 127.0740 },
    
    // ëšì„¬ë¡œ ê¶Œì—­
    'ëšì„¬ë¡œ': { lat: 37.5300, lng: 127.0700 },
    'ëšì„¬ë¡œ62ê¸¸': { lat: 37.5290, lng: 127.0690 },
    
    // ìš©ë§ˆì‚°ë¡œ ê¶Œì—­ (ìš©ë§ˆì‚° ìª½)
    'ìš©ë§ˆì‚°ë¡œ': { lat: 37.5450, lng: 127.0850 },
    'ìš©ë§ˆì‚°ë¡œ21ê¸¸': { lat: 37.5460, lng: 127.0860 },
    
    // ëŠ¥ë™ë¡œ ê¶Œì—­ (ê±´êµ­ëŒ€ ê·¼ì²˜)
    'ëŠ¥ë™ë¡œ': { lat: 37.5410, lng: 127.0750 },
    'ëŠ¥ë™ë¡œ3ë‹¤ê¸¸': { lat: 37.5400, lng: 127.0740 },
    'ëŠ¥ë™ë¡œ32ê¸¸': { lat: 37.5420, lng: 127.0760 }
  };

  // Find best matching coordinate
  let bestMatch = null;
  let bestScore = 0;

  for (const [pattern, coord] of Object.entries(addressCoords)) {
    if (cleanAddress.includes(pattern)) {
      const score = pattern.length; // Longer match = better
      if (score > bestScore) {
        bestMatch = coord;
        bestScore = score;
      }
    }
  }

  if (bestMatch) {
    // Add deterministic offset based on address hash to avoid identical coordinates
    const hash = address.split('').reduce((a, b) => { a = ((a << 5) - a) + b.charCodeAt(0); return a & a }, 0);
    const offset = {
      lat: bestMatch.lat + ((hash % 1000) / 100000) - 0.005,
      lng: bestMatch.lng + (((hash * 17) % 1000) / 100000) - 0.005
    };
    coordinatesCache[address] = offset;
    localStorage.setItem("coordinatesCache", JSON.stringify(coordinatesCache));
    addDebugLog('ë¡œì»¬ ë§¤í•‘ìœ¼ë¡œ ì¢Œí‘œ ì¶”ì •', { address, coordinates: offset });
    return offset;
  }

  // Final fallback to Gwangjin District Office with deterministic offset
  const hash = address.split('').reduce((a, b) => { a = ((a << 5) - a) + b.charCodeAt(0); return a & a }, 0);
  const defaultCoord = { 
    lat: 37.5385 + ((hash % 2000) / 100000) - 0.01,
    lng: 127.0823 + (((hash * 13) % 2000) / 100000) - 0.01
  };
  coordinatesCache[address] = defaultCoord;
  localStorage.setItem("coordinatesCache", JSON.stringify(coordinatesCache));
  addDebugLog('ê¸°ë³¸ ì¢Œí‘œë¡œ í´ë°±', { address, coordinates: defaultCoord });
  return defaultCoord;
}

// Kakao Maps API geocoding
async function geocodeWithKakao(address) {
  try {
    // Kakao API key for geocoding
    const KAKAO_API_KEY = '2a882357d1de5851b77f3eaf014862dd';
    
    if (KAKAO_API_KEY === 'YOUR_KAKAO_API_KEY') {
      addDebugLog('ì¹´ì¹´ì˜¤ API í‚¤ ë¯¸ì„¤ì • - ê±´ë„ˆëœ€');
      return null;
    }
    
    const response = await fetch(`https://dapi.kakao.com/v2/local/search/address.json?query=${encodeURIComponent(address)}`, {
      headers: { 'Authorization': `KakaoAK ${KAKAO_API_KEY}` }
    });
    
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    
    const data = await response.json();
    if (data.documents && data.documents.length > 0) {
      const result = data.documents[0];
      return {
        lat: parseFloat(result.y || result.address?.y),
        lng: parseFloat(result.x || result.address?.x)
      };
    }
  } catch (error) {
    addDebugLog('ì¹´ì¹´ì˜¤ API ì˜¤ë¥˜', { error: error.message });
  }
  return null;
}

// OpenStreetMap Nominatim geocoding (free, no API key required)
async function geocodeWithNominatim(address) {
  try {
    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`, {
      headers: { 'User-Agent': 'Jinculro/1.0' }
    });
    
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    
    const data = await response.json();
    if (data && data.length > 0) {
      return {
        lat: parseFloat(data[0].lat),
        lng: parseFloat(data[0].lon)
      };
    }
  } catch (error) {
    addDebugLog('Nominatim API ì˜¤ë¥˜', { error: error.message });
  }
  return null;
}

// Improved Nearest neighbor with validation and error handling
function optimizeRouteNearestNeighbor(addresses, startAddress) {
  if (!addresses || addresses.length <= 1) {
    addDebugLog('NN ìµœì í™”: ì£¼ì†Œê°€ ë¶€ì¡±í•¨', { addresses });
    return addresses || [];
  }

  // Validate coordinates exist
  const validAddresses = addresses.filter(addr => {
    const coord = coordinatesCache[addr];
    return coord && coord.lat && coord.lng;
  });

  if (validAddresses.length === 0) {
    addDebugLog('NN ìµœì í™”: ìœ íš¨í•œ ì¢Œí‘œ ì—†ìŒ');
    return addresses;
  }

  addDebugLog('NN ìµœì í™” ì‹œì‘', { 
    total: addresses.length, 
    valid: validAddresses.length,
    start: startAddress 
  });

  const unvisited = [...validAddresses];
  const route = [];
  let current = startAddress;

  // Remove start from unvisited if it exists
  const startIndex = unvisited.indexOf(startAddress);
  if (startIndex !== -1) {
    unvisited.splice(startIndex, 1);
  }

  let iterations = 0;
  const maxIterations = validAddresses.length * 2; // Safety limit

  while (unvisited.length > 0 && iterations < maxIterations) {
    iterations++;
    let nearestIndex = -1;
    let shortestDistance = Infinity;

    const currentCoord = coordinatesCache[current];
    if (!currentCoord) {
      addDebugLog('NN ìµœì í™”: í˜„ì¬ ìœ„ì¹˜ ì¢Œí‘œ ì—†ìŒ', { current });
      // Use first unvisited as fallback
      current = unvisited[0];
      continue;
    }

    for (let i = 0; i < unvisited.length; i++) {
      const nextCoord = coordinatesCache[unvisited[i]];
      if (!nextCoord) continue;

      const distance = calculateDistance(
        currentCoord.lat, currentCoord.lng,
        nextCoord.lat, nextCoord.lng
      );

      if (distance < shortestDistance) {
        shortestDistance = distance;
        nearestIndex = i;
      }
    }

    if (nearestIndex === -1) {
      addDebugLog('NN ìµœì í™”: ë‹¤ìŒ ìœ„ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
      // Add remaining addresses in original order
      route.push(...unvisited);
      break;
    }

    current = unvisited[nearestIndex];
    route.push(current);
    unvisited.splice(nearestIndex, 1);
  }

  addDebugLog('NN ìµœì í™” ì™„ë£Œ', { 
    originalLength: addresses.length,
    optimizedLength: route.length,
    iterations
  });

  return route;
}

// Calculate total route distance
function calculateTotalDistance(route) {
  if (route.length < 2) return 0;

  let total = 0;
  for (let i = 0; i < route.length - 1; i++) {
    const coord1 = coordinatesCache[route[i]];
    const coord2 = coordinatesCache[route[i + 1]];
    if (coord1 && coord2) {
      total += calculateDistance(coord1.lat, coord1.lng, coord2.lat, coord2.lng);
    }
  }
  return total;
}

// Advanced Route Optimization Algorithms

// Enhanced 2-opt optimization with better performance
function optimize2Opt(route, maxIterations = 200) {
  if (!route || route.length < 4) {
    addDebugLog('2-opt: ë£¨íŠ¸ê°€ ë„ˆë¬´ ì§§ìŒ', { length: route?.length });
    return route || [];
  }
  
  addDebugLog('2-opt ìµœì í™” ì‹œì‘', { 
    routeLength: route.length, 
    maxIterations 
  });
  
  let bestRoute = [...route];
  let bestDistance = calculateTotalDistance(bestRoute);
  
  if (bestDistance === 0) {
    addDebugLog('2-opt: ì´ˆê¸° ê±°ë¦¬ ê³„ì‚° ì‹¤íŒ¨');
    return route;
  }
  let improved = true;
  let iteration = 0;
  let improvementsCount = 0;
  const initialDistance = bestDistance;
  
  while (improved && iteration < maxIterations) {
    improved = false;
    
    // Early termination if no significant improvement
    if (iteration > 50 && improvementsCount === 0) break;
    
    for (let i = 1; i < bestRoute.length - 2; i++) {
      for (let j = i + 1; j < bestRoute.length - 1; j++) {
        // Calculate current segment distances
        const currentDist = calculateSegmentDistance(bestRoute, i-1, i, j, j+1);
        
        // Calculate reversed segment distances  
        const reversedDist = calculateReversedSegmentDistance(bestRoute, i-1, i, j, j+1);
        
        if (reversedDist < currentDist) {
          // Apply 2-opt swap
          const newRoute = [...bestRoute];
          const segment = newRoute.slice(i, j + 1).reverse();
          newRoute.splice(i, j - i + 1, ...segment);
          
          bestRoute = newRoute;
          bestDistance = calculateTotalDistance(bestRoute);
          improved = true;
          improvementsCount++;
        }
      }
    }
    iteration++;
  }
  
  const improvement = ((initialDistance - bestDistance) / initialDistance * 100).toFixed(1);
  addDebugLog('2-opt ìµœì í™” ì™„ë£Œ', { 
    iterations: iteration,
    improvements: improvementsCount,
    initialDistance: initialDistance.toFixed(2) + 'km',
    finalDistance: bestDistance.toFixed(2) + 'km',
    improvement: improvement + '%'
  });
  
  return bestRoute;
}

// Helper function for 2-opt segment distance calculation
function calculateSegmentDistance(route, a, b, c, d) {
  const coords = [route[a], route[b], route[c], route[d]].map(addr => coordinatesCache[addr]);
  if (coords.some(coord => !coord)) return Infinity;
  
  return calculateDistance(coords[0].lat, coords[0].lng, coords[1].lat, coords[1].lng) +
         calculateDistance(coords[2].lat, coords[2].lng, coords[3].lat, coords[3].lng);
}

function calculateReversedSegmentDistance(route, a, b, c, d) {
  const coords = [route[a], route[c], route[b], route[d]].map(addr => coordinatesCache[addr]);
  if (coords.some(coord => !coord)) return Infinity;
  
  return calculateDistance(coords[0].lat, coords[0].lng, coords[1].lat, coords[1].lng) +
         calculateDistance(coords[2].lat, coords[2].lng, coords[3].lat, coords[3].lng);
}

// K-means clustering for grouping nearby addresses
function clusterAddresses(addresses, k = 3) {
  if (addresses.length <= k) return addresses.map((addr, i) => ({address: addr, cluster: i}));
  
  // Initialize centroids randomly
  const coords = addresses.map(addr => coordinatesCache[addr]).filter(c => c);
  if (coords.length === 0) return addresses.map((addr, i) => ({address: addr, cluster: 0}));
  
  let centroids = [];
  for (let i = 0; i < k; i++) {
    const randomIndex = Math.floor(Math.random() * coords.length);
    centroids.push({...coords[randomIndex]});
  }
  
  let assignments = new Array(addresses.length);
  let changed = true;
  let iterations = 0;
  
  while (changed && iterations < 50) {
    changed = false;
    
    // Assign each address to nearest centroid
    for (let i = 0; i < addresses.length; i++) {
      const coord = coordinatesCache[addresses[i]];
      if (!coord) continue;
      
      let minDist = Infinity;
      let bestCluster = 0;
      
      for (let c = 0; c < k; c++) {
        const dist = calculateDistance(coord.lat, coord.lng, centroids[c].lat, centroids[c].lng);
        if (dist < minDist) {
          minDist = dist;
          bestCluster = c;
        }
      }
      
      if (assignments[i] !== bestCluster) {
        assignments[i] = bestCluster;
        changed = true;
      }
    }
    
    // Update centroids
    for (let c = 0; c < k; c++) {
      const clusterAddresses = addresses.filter((_, i) => assignments[i] === c);
      if (clusterAddresses.length > 0) {
        const clusterCoords = clusterAddresses.map(addr => coordinatesCache[addr]).filter(coord => coord);
        if (clusterCoords.length > 0) {
          centroids[c] = {
            lat: clusterCoords.reduce((sum, coord) => sum + coord.lat, 0) / clusterCoords.length,
            lng: clusterCoords.reduce((sum, coord) => sum + coord.lng, 0) / clusterCoords.length
          };
        }
      }
    }
    
    iterations++;
  }
  
  return addresses.map((addr, i) => ({
    address: addr,
    cluster: assignments[i] || 0
  }));
}

// Cluster-first route-second strategy
function optimizeClusterFirstRouteSecond(addresses, startAddress) {
  if (addresses.length <= 2) return addresses;
  
  // Step 1: Cluster addresses
  const k = Math.min(3, Math.ceil(addresses.length / 3));
  const clustered = clusterAddresses(addresses, k);
  
  // Step 2: Find order of clusters based on distance from start
  const startCoord = coordinatesCache[startAddress];
  if (!startCoord) return addresses;
  
  const clusters = {};
  clustered.forEach(item => {
    if (!clusters[item.cluster]) clusters[item.cluster] = [];
    clusters[item.cluster].push(item.address);
  });
  
  // Sort clusters by distance from start
  const clusterKeys = Object.keys(clusters);
  const clusterDistances = clusterKeys.map(key => {
    const clusterAddrs = clusters[key];
    const avgDist = clusterAddrs.reduce((sum, addr) => {
      const coord = coordinatesCache[addr];
      return coord ? sum + calculateDistance(startCoord.lat, startCoord.lng, coord.lat, coord.lng) : sum;
    }, 0) / clusterAddrs.length;
    return {cluster: key, distance: avgDist};
  });
  
  clusterDistances.sort((a, b) => a.distance - b.distance);
  
  // Step 3: Optimize route within each cluster and combine
  let optimizedRoute = [];
  clusterDistances.forEach(({cluster}) => {
    const clusterAddresses = clusters[cluster];
    if (clusterAddresses.length === 1) {
      optimizedRoute.push(...clusterAddresses);
    } else {
      // Use nearest neighbor within cluster
      const clusterRoute = optimizeRouteNearestNeighbor(clusterAddresses, optimizedRoute.length > 0 ? optimizedRoute[optimizedRoute.length - 1] : startAddress);
      optimizedRoute.push(...clusterRoute);
    }
  });
  
  return optimizedRoute;
}

// Genetic Algorithm for TSP (simplified version)
function optimizeRouteGenetic(addresses, startAddress, populationSize = 50, generations = 100) {
  if (addresses.length <= 3) return addresses;
  
  // Create initial population
  let population = [];
  for (let i = 0; i < populationSize; i++) {
    const route = [...addresses];
    // Shuffle array
    for (let j = route.length - 1; j > 0; j--) {
      const k = Math.floor(Math.random() * (j + 1));
      [route[j], route[k]] = [route[k], route[j]];
    }
    population.push(route);
  }
  
  // Evolution loop
  for (let gen = 0; gen < generations; gen++) {
    // Calculate fitness (inverse of distance)
    const fitness = population.map(route => {
      const fullRoute = [startAddress, ...route, startAddress];
      const distance = calculateTotalDistance(fullRoute);
      return distance > 0 ? 1 / distance : 1000;
    });
    
    // Selection and crossover
    const newPopulation = [];
    for (let i = 0; i < populationSize; i++) {
      // Tournament selection
      const parent1 = tournamentSelection(population, fitness);
      const parent2 = tournamentSelection(population, fitness);
      const child = crossover(parent1, parent2);
      mutate(child, 0.02); // 2% mutation rate
      newPopulation.push(child);
    }
    
    population = newPopulation;
  }
  
  // Return best route
  const fitness = population.map(route => {
    const fullRoute = [startAddress, ...route, startAddress];
    const distance = calculateTotalDistance(fullRoute);
    return distance > 0 ? 1 / distance : 1000;
  });
  
  const bestIndex = fitness.indexOf(Math.max(...fitness));
  return population[bestIndex];
}

function tournamentSelection(population, fitness, tournamentSize = 3) {
  let best = Math.floor(Math.random() * population.length);
  for (let i = 1; i < tournamentSize; i++) {
    const competitor = Math.floor(Math.random() * population.length);
    if (fitness[competitor] > fitness[best]) {
      best = competitor;
    }
  }
  return population[best];
}

function crossover(parent1, parent2) {
  const start = Math.floor(Math.random() * parent1.length);
  const end = Math.floor(Math.random() * (parent1.length - start)) + start;
  
  const child = new Array(parent1.length);
  const segment = parent1.slice(start, end + 1);
  
  // Copy segment from parent1
  for (let i = start; i <= end; i++) {
    child[i] = parent1[i];
  }
  
  // Fill remaining positions with parent2 order
  let p2Index = 0;
  for (let i = 0; i < parent1.length; i++) {
    if (child[i] === undefined) {
      while (segment.includes(parent2[p2Index])) {
        p2Index++;
      }
      child[i] = parent2[p2Index];
      p2Index++;
    }
  }
  
  return child;
}

function mutate(route, mutationRate) {
  for (let i = 0; i < route.length; i++) {
    if (Math.random() < mutationRate) {
      const j = Math.floor(Math.random() * route.length);
      [route[i], route[j]] = [route[j], route[i]];
    }
  }
}

// Real-world practical route optimizer for Gwangjin District
function optimizeRouteMultiAlgorithm(addresses, startAddress) {
  if (!addresses || addresses.length <= 1) {
    addDebugLog('ë‹¤ì¤‘ì•Œê³ ë¦¬ì¦˜: ì£¼ì†Œ ë¶€ì¡±', { addresses });
    return { method: 'ì£¼ì†Œ ë¶€ì¡±', route: addresses || [], distance: 0 };
  }

  addDebugLog('ë‹¤ì¤‘ ì•Œê³ ë¦¬ì¦˜ ìµœì í™” ì‹œì‘', {
    addressCount: addresses.length,
    startAddress,
    hasValidCoords: addresses.filter(addr => coordinatesCache[addr]).length
  });

  const results = [];
  
  try {
    // Algorithm 1: Enhanced Nearest Neighbor
    const nnResult = optimizeRouteNearestNeighbor(addresses, startAddress);
    const nnOptimized = optimize2Opt(nnResult); // Apply 2-opt improvement
    const nnDistance = calculateTotalDistance([startAddress, ...nnOptimized, startAddress]);
    
    if (nnDistance > 0) {
      results.push({
        method: 'ê°œì„ ëœ Nearest Neighbor + 2-opt',
        route: nnOptimized,
        distance: nnDistance
      });
    }

    // Algorithm 2: Geography-aware Seoul routing  
    const geoResult = optimizeRouteGeographyAware(addresses, startAddress);
    const geoDistance = calculateTotalDistance([startAddress, ...geoResult, startAddress]);
    
    if (geoDistance > 0) {
      results.push({
        method: 'ì§€ë¦¬ ê¸°ë°˜ ìµœì í™” (ì„œìš¸ íŠ¹í™”)',
        route: geoResult,
        distance: geoDistance
      });
    }
    
    // Algorithm 3: Sector-based routing
    const sectorResult = optimizeRouteSectorBased(addresses, startAddress);
    const sectorDistance = calculateTotalDistance([startAddress, ...sectorResult, startAddress]);
    
    if (sectorDistance > 0) {
      results.push({
        method: 'êµ¬ì—­ë³„ ìˆœíšŒ (íƒë°° ë°©ì‹)',
        route: sectorResult,
        distance: sectorDistance
      });
    }

    // Algorithm 4: Traffic-aware routing
    if (addresses.length <= 15) { // Only for smaller sets due to complexity
      const trafficResult = optimizeRouteTrafficAware(addresses, startAddress);
      const trafficDistance = calculateTotalDistance([startAddress, ...trafficResult, startAddress]);
      
      if (trafficDistance > 0) {
        results.push({
          method: 'êµí†µ ê³ ë ¤ ìµœì í™”',
          route: trafficResult,
          distance: trafficDistance
        });
      }
    }

  } catch (error) {
    addDebugLog('ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰ ì˜¤ë¥˜', { error: error.message });
  }

  // Filter out invalid results and ensure we have at least one result
  const validResults = results.filter(r => r.distance > 0 && r.route.length > 0);
  
  if (validResults.length === 0) {
    addDebugLog('ìœ íš¨í•œ ìµœì í™” ê²°ê³¼ ì—†ìŒ - ì›ë³¸ ìˆœì„œ ë°˜í™˜');
    return {
      method: 'ìµœì í™” ì‹¤íŒ¨ (ì›ë³¸ ìˆœì„œ)', 
      route: addresses, 
      distance: calculateTotalDistance([startAddress, ...addresses, startAddress])
    };
  }

  // Return best result
  validResults.sort((a, b) => a.distance - b.distance);
  const bestResult = validResults[0];

  addDebugLog('ë‹¤ì¤‘ ì•Œê³ ë¦¬ì¦˜ ìµœì í™” ê²°ê³¼', {
    totalAlgorithms: results.length,
    validResults: validResults.length,
    bestMethod: bestResult.method,
    bestDistance: bestResult.distance.toFixed(2) + 'km',
    improvement: validResults.length > 1 ? 
      ((validResults[validResults.length-1].distance - bestResult.distance) / validResults[validResults.length-1].distance * 100).toFixed(1) + '%' : 
      'N/A'
  });

  return bestResult;
}

// Geography-aware routing for Seoul metropolitan area
function optimizeRouteGeographyAware(addresses, startAddress) {
  if (addresses.length <= 1) return addresses;
  
  // Seoul geographic sectors based on real geography
  const seoulSectors = {
    // ê°•ë¶ (Han River North)
    gangbuk: {
      priority: 1,
      keywords: ['ì¢…ë¡œêµ¬', 'ì¤‘êµ¬', 'ìš©ì‚°êµ¬', 'ì„±ë™êµ¬', 'ê´‘ì§„êµ¬', 'ë™ëŒ€ë¬¸êµ¬', 'ì¤‘ë‘êµ¬', 'ì„±ë¶êµ¬', 'ê°•ë¶êµ¬', 'ë„ë´‰êµ¬', 'ë…¸ì›êµ¬', 'ì€í‰êµ¬', 'ì„œëŒ€ë¬¸êµ¬', 'ë§ˆí¬êµ¬'],
      center: { lat: 37.5665, lng: 126.9780 }
    },
    // ê°•ë‚¨ (Han River South) 
    gangnam: {
      priority: 2,
      keywords: ['ê°•ë‚¨êµ¬', 'ì„œì´ˆêµ¬', 'ì†¡íŒŒêµ¬', 'ê°•ë™êµ¬'],
      center: { lat: 37.4979, lng: 127.0276 }
    },
    // ê°•ì„œ (Western Seoul)
    gangseo: {
      priority: 3, 
      keywords: ['ì–‘ì²œêµ¬', 'ê°•ì„œêµ¬', 'êµ¬ë¡œêµ¬', 'ê¸ˆì²œêµ¬', 'ì˜ë“±í¬êµ¬', 'ë™ì‘êµ¬', 'ê´€ì•…êµ¬'],
      center: { lat: 37.5172, lng: 126.8506 }
    }
  };
  
  // Categorize addresses by sector
  const sectorizedAddresses = addresses.map(addr => {
    let sector = 'gangbuk'; // Default to gangbuk for Gwangjin area
    let priority = 1;
    
    for (const [sectorName, sectorInfo] of Object.entries(seoulSectors)) {
      if (sectorInfo.keywords.some(keyword => addr.includes(keyword))) {
        sector = sectorName;
        priority = sectorInfo.priority;
        break;
      }
    }
    
    return { address: addr, sector, priority };
  });
  
  // Sort by sector priority, then by distance within sector
  const startCoord = coordinatesCache[startAddress];
  if (!startCoord) return addresses;
  
  sectorizedAddresses.sort((a, b) => {
    // First by sector priority
    if (a.priority !== b.priority) {
      return a.priority - b.priority;
    }
    
    // Then by distance from start within same sector
    const coordA = coordinatesCache[a.address];
    const coordB = coordinatesCache[b.address];
    
    if (!coordA || !coordB) return 0;
    
    const distA = calculateDistance(startCoord.lat, startCoord.lng, coordA.lat, coordA.lng);
    const distB = calculateDistance(startCoord.lat, startCoord.lng, coordB.lat, coordB.lng);
    
    return distA - distB;
  });
  
  return sectorizedAddresses.map(item => item.address);
}

// Sector-based routing like delivery services
function optimizeRouteSectorBased(addresses, startAddress) {
  if (addresses.length <= 1) return addresses;
  
  // Define Gwangjin district micro-sectors
  const microSectors = {
    // êµ¬ì˜ê¶Œ (Gui area)
    gui: {
      keywords: ['êµ¬ì˜', 'ê´‘ì¥ë™', 'ìì–‘ë™'],
      priority: 1,
      description: 'í•œê°•ë³€ ì§€ì—­'
    },
    // ëŠ¥ë™ê¶Œ (Neungdong area) 
    neungdong: {
      keywords: ['ëŠ¥ë™', 'í™”ì–‘ë™'],
      priority: 2,
      description: 'ê±´êµ­ëŒ€ ì£¼ë³€'
    },
    // ì¤‘ê³¡ê¶Œ (Junggok area)
    junggok: {
      keywords: ['ì¤‘ê³¡ë™', 'ìš©ë§ˆì‚°'],
      priority: 3,
      description: 'ìš©ë§ˆì‚° ì¼ëŒ€'
    }
  };
  
  // Group addresses by micro-sector
  const sectorGroups = { gui: [], neungdong: [], junggok: [], others: [] };
  
  addresses.forEach(addr => {
    let assigned = false;
    for (const [sector, info] of Object.entries(microSectors)) {
      if (info.keywords.some(keyword => addr.includes(keyword))) {
        sectorGroups[sector].push(addr);
        assigned = true;
        break;
      }
    }
    if (!assigned) {
      sectorGroups.others.push(addr);
    }
  });
  
  // Optimize within each sector, then combine
  let optimizedRoute = [];
  const sectorOrder = ['gui', 'neungdong', 'junggok', 'others'];
  
  sectorOrder.forEach(sector => {
    if (sectorGroups[sector].length > 0) {
      if (sectorGroups[sector].length === 1) {
        optimizedRoute.push(...sectorGroups[sector]);
      } else {
        const lastPoint = optimizedRoute.length > 0 ? optimizedRoute[optimizedRoute.length - 1] : startAddress;
        const sectorOptimized = optimizeRouteNearestNeighbor(sectorGroups[sector], lastPoint);
        optimizedRoute.push(...sectorOptimized);
      }
    }
  });
  
  return optimizedRoute;
}

// Traffic-aware routing considering Seoul traffic patterns
function optimizeRouteTrafficAware(addresses, startAddress) {
  if (addresses.length <= 1) return addresses;
  
  // Seoul traffic flow patterns
  const trafficPenalties = {
    // Major arterial roads (higher penalty during rush hours)
    arterial: ['ë™ì¼ë¡œ', 'ì²œí˜¸ëŒ€ë¡œ', 'ê´‘ë‚˜ë£¨ë¡œ', 'ê°•ë³€ë¶ë¡œ'],
    // Secondary roads (medium penalty)  
    secondary: ['ì•„ì°¨ì‚°ë¡œ', 'ëšì„¬ë¡œ'],
    // Local roads (low penalty)
    local: ['ëŠ¥ë™ë¡œ', 'êµ¬ì˜ê°•ë³€ë¡œ', 'ìš©ë§ˆì‚°ë¡œ']
  };
  
  // Calculate traffic penalty for each address
  const addressesWithPenalty = addresses.map(addr => {
    let penalty = 1.0; // Base penalty
    
    if (trafficPenalties.arterial.some(road => addr.includes(road))) {
      penalty = 1.5; // 50% penalty for arterial roads
    } else if (trafficPenalties.secondary.some(road => addr.includes(road))) {
      penalty = 1.2; // 20% penalty for secondary roads
    } else if (trafficPenalties.local.some(road => addr.includes(road))) {
      penalty = 1.1; // 10% penalty for local roads
    }
    
    return { address: addr, penalty };
  });
  
  // Sort by traffic penalty (prefer low-penalty roads first)
  const startCoord = coordinatesCache[startAddress];
  if (!startCoord) return addresses.map(item => typeof item === 'object' ? item.address : item);
  
  addressesWithPenalty.sort((a, b) => {
    const coordA = coordinatesCache[a.address];
    const coordB = coordinatesCache[b.address];
    
    if (!coordA || !coordB) return 0;
    
    const distA = calculateDistance(startCoord.lat, startCoord.lng, coordA.lat, coordA.lng) * a.penalty;
    const distB = calculateDistance(startCoord.lat, startCoord.lng, coordB.lat, coordB.lng) * b.penalty;
    
    return distA - distB;
  });
  
  return addressesWithPenalty.map(item => item.address);
}

// Hierarchical routing following road hierarchy (arterial -> collector -> local)
function optimizeRouteHierarchical(addresses, startAddress) {
  if (addresses.length <= 1) return addresses;
  
  // Road hierarchy classification
  const roadHierarchy = {
    arterial: {
      roads: ['ë™ì¼ë¡œ', 'ì²œí˜¸ëŒ€ë¡œ', 'ê´‘ë‚˜ë£¨ë¡œ', 'ê°•ë³€ë¶ë¡œ'],
      priority: 1,
      description: 'ê°„ì„ ë„ë¡œ'
    },
    collector: {
      roads: ['ì•„ì°¨ì‚°ë¡œ', 'ëšì„¬ë¡œ', 'êµ¬ì˜ê°•ë³€ë¡œ'],
      priority: 2, 
      description: 'ì§‘ì‚°ë„ë¡œ'
    },
    local: {
      roads: ['ëŠ¥ë™ë¡œ', 'ìš©ë§ˆì‚°ë¡œ', 'ìì–‘', 'êµ¬ì˜', 'ì¤‘ê³¡'],
      priority: 3,
      description: 'êµ­ì§€ë„ë¡œ'
    }
  };
  
  // Classify addresses by road hierarchy
  const hierarchicalGroups = { arterial: [], collector: [], local: [] };
  
  addresses.forEach(addr => {
    let assigned = false;
    for (const [category, info] of Object.entries(roadHierarchy)) {
      if (info.roads.some(road => addr.includes(road))) {
        hierarchicalGroups[category].push(addr);
        assigned = true;
        break;
      }
    }
    if (!assigned) {
      hierarchicalGroups.local.push(addr); // Default to local
    }
  });
  
  // Route in hierarchical order: arterial -> collector -> local
  let hierarchicalRoute = [];
  const hierarchyOrder = ['arterial', 'collector', 'local'];
  
  hierarchyOrder.forEach(level => {
    if (hierarchicalGroups[level].length > 0) {
      const lastPoint = hierarchicalRoute.length > 0 ? hierarchicalRoute[hierarchicalRoute.length - 1] : startAddress;
      
      if (hierarchicalGroups[level].length === 1) {
        hierarchicalRoute.push(...hierarchicalGroups[level]);
      } else {
        const levelOptimized = optimizeRouteNearestNeighbor(hierarchicalGroups[level], lastPoint);
        hierarchicalRoute.push(...levelOptimized);
      }
    }
  });
  
  return hierarchicalRoute;
}

// Mode Management Functions
function selectMode(mode) {
  try {
    console.log('selectMode í˜¸ì¶œë¨:', mode);
    
    // Update UI
    document.querySelectorAll('.mode-card').forEach(card => {
      card.classList.remove('active');
    });
    
    const modeCard = document.querySelector(`[data-mode="${mode}"]`);
    if (modeCard) {
      modeCard.classList.add('active');
    } else {
      console.error('ëª¨ë“œ ì¹´ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ:', mode);
    }
    
    // Show/Hide sections
    document.querySelectorAll('.mode-section').forEach(section => {
      section.classList.remove('active');
    });
    
    const modeSection = document.getElementById(`mode-${mode}`);
    if (modeSection) {
      modeSection.classList.add('active');
    } else {
      console.error('ëª¨ë“œ ì„¹ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ:', `mode-${mode}`);
    }
    
    AppState.currentMode = mode;
  } catch (error) {
    console.error('selectMode ì˜¤ë¥˜:', error);
    alert('ëª¨ë“œ ë³€ê²½ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
  }
  
  // Initialize mode-specific content
  if (mode === 'travel') {
    updateTravelMode();
  } else if (mode === 'summary') {
    // Add small delay to ensure DOM is ready
    setTimeout(() => {
      updateSummaryMode();
    }, 100);
  } else if (mode === 'prepare') {
    // Show selected map app if exists
    updateMapSelection();
  } else if (mode === 'record') {
    initializeRecordMode();
  }
}

function goHome() {
  try {
    console.log('goHome í˜¸ì¶œë¨');
    
    // Reset to initial prepare mode state
    AppState.currentStep = 1;
    AppState.currentAddress = null;
    
    selectMode('prepare');
    
    // Reset step indicator
    updateStepIndicator();
    
    // Show step 1, hide others
    const stepMap = document.getElementById('step-map');
    const stepInput = document.getElementById('step-input');
    const stepPreview = document.getElementById('step-preview');
    
    if (stepMap) stepMap.style.display = 'block';
    if (stepInput) stepInput.style.display = 'none';
    if (stepPreview) stepPreview.style.display = 'none';
    
    // Hide input sections safely
    const fileSection = document.getElementById('file-input-section');
    const bulkSection = document.getElementById('bulk-input-section');
    if (fileSection) fileSection.style.display = 'none';
    if (bulkSection) bulkSection.style.display = 'none';
    
    console.log('í™ˆìœ¼ë¡œ ì´ë™ ì™„ë£Œ');
  } catch (error) {
    console.error('goHome ì˜¤ë¥˜:', error);
    alert('í™ˆìœ¼ë¡œ ì´ë™ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
  }
}

// Map Selection Functions
function selectMapApp(mapType) {
  try {
    console.log('selectMapApp í˜¸ì¶œë¨:', mapType);
    
    preferredMap = mapType;
    
    // Update UI with clear feedback
    document.querySelectorAll('.map-option').forEach(btn => {
      btn.classList.remove('selected');
    });
    
    const selectedBtn = document.querySelector(`[data-map="${mapType}"]`);
    if (selectedBtn) {
      selectedBtn.classList.add('selected');
      
      // Visual feedback with animation
      selectedBtn.style.transform = 'scale(0.95)';
      setTimeout(() => {
        selectedBtn.style.transform = 'translateY(-3px)';
      }, 100);
    } else {
      console.error('ì§€ë„ ë²„íŠ¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ:', mapType);
    }
    
    // Update hidden select for compatibility
    const mapSelect = document.getElementById('mapSelect');
    if (mapSelect) {
      mapSelect.value = mapType;
    }
    
    // Show continue button with animation
    const continueBtn = document.getElementById('continueStep2');
    if (continueBtn) {
      continueBtn.style.display = 'block';
      continueBtn.style.opacity = '0';
      continueBtn.style.transform = 'translateY(10px)';
      
      setTimeout(() => {
        continueBtn.style.transition = 'all 0.3s ease';
        continueBtn.style.opacity = '1';
        continueBtn.style.transform = 'translateY(0)';
      }, 50);
    } else {
      console.error('ê³„ì†í•˜ê¸° ë²„íŠ¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ');
    }
    
    // Save preference if checkbox is checked
    const rememberCheckbox = document.getElementById('rememberMap');
    if (rememberCheckbox && rememberCheckbox.checked) {
      localStorage.setItem('preferredMap', preferredMap);
    }
  } catch (error) {
    console.error('selectMapApp ì˜¤ë¥˜:', error);
    alert('ì§€ë„ ì•± ì„ íƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
  }
  
  console.log(`ì§€ë„ ì•± ì„ íƒë¨: ${mapType}`); // ë””ë²„ê¹…ìš©
}

function updateMapSelection() {
  // Restore selected map
  if (preferredMap) {
    document.querySelectorAll('.map-option').forEach(btn => {
      btn.classList.remove('selected');
    });
    const selectedBtn = document.querySelector(`[data-map="${preferredMap}"]`);
    if (selectedBtn) {
      selectedBtn.classList.add('selected');
      
      // Show continue button if map is already selected
      const continueBtn = document.getElementById('continueStep2');
      if (continueBtn) {
        continueBtn.style.display = 'block';
      }
    }
  }
}

// Step Management for Prepare Mode
function goToStep(step) {
  // ë‹¨ê³„ë³„ í´ë¦­ìœ¼ë¡œ ì´ë™
  nextStep(step);
}

function nextStep(step) {
  try {
    console.log('nextStep í˜¸ì¶œë¨:', step);
    
    AppState.currentStep = step;
    updateStepIndicator();
    
    // ëª¨ë“  ë‹¨ê³„ ìˆ¨ê¸°ê¸°
    const stepMap = document.getElementById('step-map');
    const stepInput = document.getElementById('step-input');
    const stepPreview = document.getElementById('step-preview');
    
    if (stepMap) stepMap.style.display = 'none';
    if (stepInput) stepInput.style.display = 'none';
    if (stepPreview) stepPreview.style.display = 'none';
    
    // 2ë‹¨ê³„ ë‚´ë¶€ ì„¹ì…˜ë“¤ë„ ìˆ¨ê¸°ê¸°
    const fileSection = document.getElementById('file-input-section');
    const bulkSection = document.getElementById('bulk-input-section');
    if (fileSection) fileSection.style.display = 'none';
    if (bulkSection) bulkSection.style.display = 'none';
    
    if (step === 1 && stepMap) {
      stepMap.style.display = 'block';
    } else if (step === 2 && stepInput) {
      stepInput.style.display = 'block';
    } else if (step === 3 && stepPreview) {
      stepPreview.style.display = 'block';
      updateAddressPreview();
    }
  } catch (error) {
    console.error('nextStep ì˜¤ë¥˜:', error);
    alert('ë‹¨ê³„ ì´ë™ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
  }
}

function updateStepIndicator() {
  document.querySelectorAll('.step').forEach((step, index) => {
    const stepNum = index + 1;
    if (stepNum < AppState.currentStep) {
      step.className = 'step completed';
    } else if (stepNum === AppState.currentStep) {
      step.className = 'step active';
    } else {
      step.className = 'step pending';
    }
  });
  
  document.querySelectorAll('.step-line').forEach((line, index) => {
    if (index + 1 < AppState.currentStep) {
      line.classList.add('completed');
    } else {
      line.classList.remove('completed');
    }
  });
}

// Address Input Methods
function toggleInputMethod(method) {
  const fileSection = document.getElementById('file-input-section');
  const bulkSection = document.getElementById('bulk-input-section');
  
  // Hide all sections first
  fileSection.style.display = 'none';
  bulkSection.style.display = 'none';
  
  // Show selected section
  if (method === 'file') {
    fileSection.style.display = 'block';
  } else if (method === 'bulk') {
    bulkSection.style.display = 'block';
  }
}

function addSingleAddress() {
  try {
    console.log('addSingleAddress í˜¸ì¶œë¨');
    
    const input = document.getElementById('singleAddress');
    if (!input) {
      console.error('singleAddress ì…ë ¥ í•„ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
      alert('ì£¼ì†Œ ì…ë ¥ í•„ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }
    
    const address = input.value.trim();
    
    if (!address) {
      alert('ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
      return;
    }
    
    if (ì£¼ì†Œëª©ë¡.includes(address)) {
      alert('ì´ë¯¸ ì¶”ê°€ëœ ì£¼ì†Œì…ë‹ˆë‹¤.');
      return;
    }
    
    ì£¼ì†Œëª©ë¡.push(address);
    saveAddressList();
    updateDataStatus();
    
    // Update UI
    updateAddedAddresses();
    input.value = '';
    
    // Show complete button
    document.getElementById('complete-btn').style.display = 'block';
    
    console.log('ì£¼ì†Œ ì¶”ê°€ ì™„ë£Œ:', address);
  } catch (error) {
    console.error('addSingleAddress ì˜¤ë¥˜:', error);
    alert('ì£¼ì†Œ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
  }
}

function updateAddedAddresses() {
  const container = document.getElementById('added-addresses');
  if (!container) return;
  
  container.innerHTML = ì£¼ì†Œëª©ë¡.map((addr, index) => `
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: rgba(79, 172, 254, 0.1); border-radius: 8px; margin-bottom: 5px;">
      <span>${addr}</span>
      <button onclick="removeAddress(${index})" style="background: #fa709a; color: white; border: none; border-radius: 5px; padding: 5px 10px; cursor: pointer;">ì‚­ì œ</button>
    </div>
  `).join('');
}

function removeAddress(index) {
  ì£¼ì†Œëª©ë¡.splice(index, 1);
  saveAddressList();
  updateDataStatus();
  updateAddedAddresses();
  
  if (ì£¼ì†Œëª©ë¡.length === 0) {
    document.getElementById('complete-btn').style.display = 'none';
  }
}

function completeAddressInput() {
  if (ì£¼ì†Œëª©ë¡.length === 0) {
    alert('ìµœì†Œ í•˜ë‚˜ì˜ ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
    return;
  }
  nextStep(3);
}

function updateAddressPreview() {
  const container = document.getElementById('address-preview-list');
  if (!container) return;
  
  if (ì£¼ì†Œëª©ë¡.length === 0) {
    container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">ë“±ë¡ëœ ì¶œì¥ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
    return;
  }
  
  container.innerHTML = ì£¼ì†Œëª©ë¡.map((addr, index) => {
    const status = statusMap[addr] || 'ë¯¸ì„ íƒ';
    const statusClass = status === 'ì¶œì¥ì™„ë£Œ' ? 'completed' : status === 'ë¯¸ì¶œì¥' ? 'pending' : 'none';
    
    return `
      <div class="address-card ${status === 'ì¶œì¥ì™„ë£Œ' ? 'completed' : status === 'ë¯¸ì¶œì¥' ? 'pending' : ''}">
        <div class="address-title">
          <span>
            <span style="display: inline-block; width: 25px; height: 25px; background: #1b3c82; color: white; border-radius: 50%; text-align: center; line-height: 25px; font-weight: bold; margin-right: 10px; font-size: 0.8rem;">
              ${index + 1}
            </span>
            ${addr}
          </span>
          <span class="address-status status-${statusClass}">${status}</span>
        </div>
      </div>
    `;
  }).join('');
}

// Travel Mode Functions
function updateTravelMode() {
  const container = document.getElementById('travel-address-list');
  if (!container) return;
  
  if (ì£¼ì†Œëª©ë¡.length === 0) {
    container.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">ë¨¼ì € ì¤€ë¹„ëª¨ë“œì—ì„œ ì¶œì¥ì§€ë¥¼ ë“±ë¡í•´ì£¼ì„¸ìš”.</p>';
    return;
  }

  // Use optimized route if available, otherwise use original order
  const displayOrder = optimizedRoute.length > 0 ? optimizedRoute : ì£¼ì†Œëª©ë¡;
  const isOptimized = optimizedRoute.length > 0;

  let html = '';
  
  // Show optimization status
  if (isOptimized) {
    html += `
      <div style="background: rgba(79, 172, 254, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #4facfe;">
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
          <span style="font-size: 1.1rem;">ğŸ¯</span>
          <span style="font-weight: bold; color: #1b3c82;">ìµœì í™”ëœ ë°©ë¬¸ ìˆœì„œ</span>
          <button onclick="clearOptimizedRoute()" style="background: none; border: 1px solid #ccc; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; cursor: pointer;">ì›ë˜ ìˆœì„œë¡œ</button>
        </div>
        <div style="font-size: 0.9rem; color: #666;">
          íš¨ìœ¨ì ì¸ ê²½ë¡œë¡œ ì¬ì •ë ¬ë˜ì—ˆìŠµë‹ˆë‹¤. ë²ˆí˜¸ ìˆœì„œëŒ€ë¡œ ë°©ë¬¸í•˜ì„¸ìš”.
        </div>
      </div>
    `;
  }
  
  html += displayOrder.map((addr, index) => {
    const status = statusMap[addr] || 'ë¯¸ì„ íƒ';
    const statusClass = status === 'ì¶œì¥ì™„ë£Œ' ? 'completed' : status === 'ë¯¸ì¶œì¥' ? 'pending' : 'none';
    const originalIndex = ì£¼ì†Œëª©ë¡.indexOf(addr);
    
    // Show route optimization indicator
    const orderIndicator = isOptimized ? 
      `<div style="position: absolute; top: -8px; right: -8px; background: #4facfe; color: white; border-radius: 50%; width: 20px; height: 20px; font-size: 0.7rem; display: flex; align-items: center; justify-content: center; font-weight: bold;">
        ${originalIndex + 1}
      </div>` : '';
    
    return `
      <div class="address-card ${status === 'ì¶œì¥ì™„ë£Œ' ? 'completed' : status === 'ë¯¸ì¶œì¥' ? 'pending' : ''}" onclick="openAddressActions('${addr}')" style="position: relative;">
        ${orderIndicator}
        <div class="address-title">
          <span style="font-size: 1.1rem;">
            <span style="display: inline-block; width: 30px; height: 30px; background: ${isOptimized ? '#4facfe' : '#1b3c82'}; color: white; border-radius: 50%; text-align: center; line-height: 30px; font-weight: bold; margin-right: 10px; font-size: 0.9rem;">
              ${index + 1}
            </span>
            ${addr}
          </span>
          <span class="address-status status-${statusClass}">${status}</span>
        </div>
        <div style="margin-top: 10px; display: flex; gap: 10px;">
          <button class="btn btn-primary" onclick="event.stopPropagation(); openMapForAddress('${addr}')" style="flex: 1; padding: 10px;">
            ğŸ—ºï¸ ì§€ë„ ì—´ê¸°
          </button>
          <button class="btn btn-secondary" onclick="event.stopPropagation(); openRecordMode('${addr}')" style="flex: 1; padding: 10px;">
            ğŸ“ ê¸°ë¡í•˜ê¸°
          </button>
        </div>
      </div>
    `;
  }).join('');

  container.innerHTML = html;
}

// Clear optimized route and return to original order
function clearOptimizedRoute() {
  optimizedRoute = [];
  updateTravelMode();
}

// Clear coordinate cache to force re-geocoding
function clearCoordinateCache() {
  coordinatesCache = {};
  localStorage.removeItem("coordinatesCache");
  alert('ì¢Œí‘œ ìºì‹œê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ìµœì í™” ì‹œ ìƒˆë¡œìš´ ì¢Œí‘œë¡œ ê³„ì‚°ë©ë‹ˆë‹¤.');
}

function openMapForAddress(address) {
  const baseAddr = address.replace(/\s*\([^)]*\)\s*$/, '').trim();
  const encodedAddr = encodeURIComponent(baseAddr);
  
  // Mobile device detection
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  const isAndroid = /Android/i.test(navigator.userAgent);
  const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
  
  if (isMobile) {
    // Mobile: Use preferred map directly
    tryOpenPreferredMap(baseAddr, encodedAddr, preferredMap, isAndroid, isIOS);
  } else {
    // Desktop: Direct web link
    openWebMap(baseAddr, encodedAddr);
  }
  
  // Mark as viewed
  viewedAddresses.add(address);
  saveViewedAddresses();
}

function tryOpenPreferredMap(baseAddr, encodedAddr, preferredMap, isAndroid, isIOS) {
  let appUrl = '';
  let webUrl = '';
  
  // Default to naver if no preferred map is set
  const mapToUse = preferredMap || 'naver';
  
  if (mapToUse === 'naver') {
    if (isAndroid) {
      appUrl = `intent://search?query=${encodedAddr}#Intent;scheme=nmap;action=android.intent.action.VIEW;category=android.intent.category.BROWSABLE;package=com.nhn.android.nmap;end`;
    } else if (isIOS) {
      appUrl = `nmap://search?query=${encodedAddr}`;
    }
    webUrl = `https://map.naver.com/v5/search/${encodedAddr}`;
  } else if (mapToUse === 'kakao') {
    if (isAndroid) {
      appUrl = `intent://search?q=${encodedAddr}#Intent;scheme=kakaomap;action=android.intent.action.VIEW;category=android.intent.category.BROWSABLE;package=net.daum.android.map;end`;
    } else if (isIOS) {
      appUrl = `kakaomap://search?q=${encodedAddr}`;
    }
    webUrl = `https://map.kakao.com/?q=${encodedAddr}`;
  } else if (mapToUse === 'google') {
    if (isAndroid) {
      appUrl = `geo:0,0?q=${encodedAddr}`;
    } else if (isIOS) {
      appUrl = `comgooglemaps://?q=${encodedAddr}`;
    }
    webUrl = `https://www.google.com/maps/search/?api=1&query=${encodedAddr}`;
  }

  if (appUrl) {
    tryOpenMapApp(appUrl, webUrl, '');
  } else {
    window.open(webUrl, '_blank');
  }
}

function showMapAppModal(address, baseAddr, encodedAddr, isAndroid, isIOS) {
  const modalHtml = `
    <div id="mapAppModal" class="modal show">
      <div class="modal-content" style="max-width: 400px;">
        <div class="modal-header">
          <div class="modal-title">ğŸ—ºï¸ ì§€ë„ ì•± ì„ íƒ</div>
          <div class="modal-subtitle">${baseAddr}</div>
        </div>
        
        <div style="display: grid; gap: 12px; margin-bottom: 20px;">
          ${createMapAppButton('naver', 'ë„¤ì´ë²„ ì§€ë„', '#00C73C', baseAddr, encodedAddr, isAndroid, isIOS)}
          ${createMapAppButton('kakao', 'ì¹´ì¹´ì˜¤ë§µ', '#FEE500', baseAddr, encodedAddr, isAndroid, isIOS)}
          ${createMapAppButton('google', 'êµ¬ê¸€ ì§€ë„', '#4285F4', baseAddr, encodedAddr, isAndroid, isIOS)}
          
          <button onclick="openWebMap('${baseAddr}', '${encodedAddr}'); closeMapAppModal();" 
                  style="background: #666; color: white; border: none; padding: 12px; border-radius: 8px; cursor: pointer; font-size: 0.9rem;">
            ğŸŒ ì›¹ì—ì„œ ì—´ê¸° (ê¸°ë³¸: ${preferredMap === 'naver' ? 'ë„¤ì´ë²„' : preferredMap === 'kakao' ? 'ì¹´ì¹´ì˜¤' : preferredMap === 'google' ? 'êµ¬ê¸€' : 'ë„¤ì´ë²„'})
          </button>
        </div>
        
        <div style="background: rgba(255,193,7,0.1); padding: 12px; border-radius: 6px; font-size: 0.8rem; color: #856404; margin-bottom: 15px;">
          ğŸ’¡ ì•±ì´ ì„¤ì¹˜ë˜ì§€ ì•Šì€ ê²½ìš° ìë™ìœ¼ë¡œ ì›¹ìœ¼ë¡œ ì—°ê²°ë©ë‹ˆë‹¤.
        </div>
        
        <div style="text-align: center;">
          <button class="btn btn-secondary" onclick="closeMapAppModal()">
            ì·¨ì†Œ
          </button>
        </div>
      </div>
    </div>
  `;

  // Remove existing modal if any
  const existingModal = document.getElementById('mapAppModal');
  if (existingModal) {
    document.body.removeChild(existingModal);
  }

  // Add new modal to body
  document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function createMapAppButton(mapType, mapName, color, baseAddr, encodedAddr, isAndroid, isIOS) {
  let appUrl = '';
  let webUrl = '';
  let storeUrl = '';
  
  if (mapType === 'naver') {
    // ë„¤ì´ë²„ ì§€ë„ ì•± URL ê°œì„ 
    if (isAndroid) {
      appUrl = `intent://search?query=${encodedAddr}#Intent;scheme=nmap;action=android.intent.action.VIEW;category=android.intent.category.BROWSABLE;package=com.nhn.android.nmap;end`;
      storeUrl = 'https://play.google.com/store/apps/details?id=com.nhn.android.nmap';
    } else if (isIOS) {
      appUrl = `nmap://search?query=${encodedAddr}`;
      storeUrl = 'https://apps.apple.com/kr/app/naver-map-navigation/id311867728';
    }
    webUrl = `https://map.naver.com/v5/search/${encodedAddr}`;
  } else if (mapType === 'kakao') {
    if (isAndroid) {
      appUrl = `intent://search?q=${encodedAddr}#Intent;scheme=kakaomap;action=android.intent.action.VIEW;category=android.intent.category.BROWSABLE;package=net.daum.android.map;end`;
      storeUrl = 'https://play.google.com/store/apps/details?id=net.daum.android.map';
    } else if (isIOS) {
      appUrl = `kakaomap://search?q=${encodedAddr}`;
      storeUrl = 'https://apps.apple.com/kr/app/kakao-map/id304608425';
    }
    webUrl = `https://map.kakao.com/?q=${encodedAddr}`;
  } else if (mapType === 'google') {
    if (isAndroid) {
      appUrl = `geo:0,0?q=${encodedAddr}`;
      storeUrl = 'https://play.google.com/store/apps/details?id=com.google.android.apps.maps';
    } else if (isIOS) {
      appUrl = `comgooglemaps://?q=${encodedAddr}`;
      storeUrl = 'https://apps.apple.com/us/app/google-maps/id585027354';
    }
    webUrl = `https://www.google.com/maps/search/?api=1&query=${encodedAddr}`;
  }

  return `
    <button onclick="tryOpenMapApp('${appUrl}', '${webUrl}', '${storeUrl}'); closeMapAppModal();" 
            style="background: ${color}; color: ${mapType === 'kakao' ? 'black' : 'white'}; border: none; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 0.9rem;">
      ğŸ“± ${mapName} ì•±ìœ¼ë¡œ ì—´ê¸°
    </button>
  `;
}

function tryOpenMapApp(appUrl, webUrl, storeUrl) {
  if (!appUrl) {
    window.open(webUrl, '_blank');
    return;
  }

  // Try to open app
  const startTime = Date.now();
  const timeout = 2000;
  
  // Create a hidden iframe to trigger app
  const iframe = document.createElement('iframe');
  iframe.style.display = 'none';
  iframe.src = appUrl;
  document.body.appendChild(iframe);
  
  // Set up fallback timer
  const timer = setTimeout(() => {
    document.body.removeChild(iframe);
    // App didn't open, fallback to web
    window.open(webUrl, '_blank');
  }, timeout);
  
  // Check if user switched to app (page becomes hidden)
  const handleVisibilityChange = () => {
    if (document.hidden) {
      clearTimeout(timer);
      document.body.removeChild(iframe);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    }
  };
  
  document.addEventListener('visibilitychange', handleVisibilityChange);
  
  // For iOS, also try window.location as fallback
  if (appUrl.startsWith('nmap://') || appUrl.startsWith('kakaomap://') || appUrl.startsWith('comgooglemaps://')) {
    setTimeout(() => {
      try {
        window.location.href = appUrl;
      } catch (e) {
        // Silent fail
      }
    }, 500);
  }
}

function openWebMap(baseAddr, encodedAddr) {
  let webUrl = '';
  
  if (preferredMap === 'naver' || !preferredMap) {
    webUrl = `https://map.naver.com/v5/search/${encodedAddr}`;
  } else if (preferredMap === 'kakao') {
    webUrl = `https://map.kakao.com/?q=${encodedAddr}`;
  } else if (preferredMap === 'google') {
    webUrl = `https://www.google.com/maps/search/?api=1&query=${encodedAddr}`;
  }
  
  window.open(webUrl, '_blank');
}

function closeMapAppModal() {
  const modal = document.getElementById('mapAppModal');
  if (modal) {
    document.body.removeChild(modal);
  }
}

function openRecordMode(address) {
  AppState.currentAddress = address;
  selectMode('record');
  
  // Hide address selector when coming from specific address
  document.getElementById('record-address-selector').style.display = 'none';
  
  // Pre-fill record form
  document.getElementById('record-title').textContent = `${address} - ê¸°ë¡ ì‘ì„±`;
  document.getElementById('recordStatusSelect').value = statusMap[address] || '';
  document.getElementById('recordMemo').value = memoMap[address] || '';
  
  // Handle custom status
  const status = statusMap[address] || '';
  if (!['ì¶œì¥ì™„ë£Œ', 'ë¯¸ì¶œì¥', ''].includes(status)) {
    document.getElementById('recordStatusSelect').value = 'ì§ì ‘ì…ë ¥';
    document.getElementById('customRecordStatus').style.display = 'block';
    document.getElementById('customRecordStatus').value = status;
  }
  
  renderRecordPhotos();
}

// Initialize record mode when accessed directly
function initializeRecordMode() {
  // Check if we have a current address
  if (!AppState.currentAddress) {
    // Show address selector
    document.getElementById('record-address-selector').style.display = 'block';
    document.getElementById('record-title').textContent = 'ê¸°ë¡ ì‘ì„±';
    
    // Populate address dropdown
    const addressSelect = document.getElementById('recordAddressSelect');
    addressSelect.innerHTML = '<option value="" disabled selected>ì¶œì¥ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>';
    
    ì£¼ì†Œëª©ë¡.forEach(address => {
      const option = document.createElement('option');
      option.value = address;
      option.textContent = address;
      addressSelect.appendChild(option);
    });
    
    // Clear form
    document.getElementById('recordStatusSelect').value = '';
    document.getElementById('recordMemo').value = '';
    document.getElementById('customRecordStatus').style.display = 'none';
    document.getElementById('recordPhotoContainer').innerHTML = '';
  } else {
    // Address already selected, hide selector
    document.getElementById('record-address-selector').style.display = 'none';
  }
}

// Handle address selection in record mode
function selectRecordAddress() {
  const selectedAddress = document.getElementById('recordAddressSelect').value;
  if (selectedAddress) {
    AppState.currentAddress = selectedAddress;
    
    // Hide address selector
    document.getElementById('record-address-selector').style.display = 'none';
    
    // Update title and pre-fill form
    document.getElementById('record-title').textContent = `${selectedAddress} - ê¸°ë¡ ì‘ì„±`;
    document.getElementById('recordStatusSelect').value = statusMap[selectedAddress] || '';
    document.getElementById('recordMemo').value = memoMap[selectedAddress] || '';
    
    // Handle custom status
    const status = statusMap[selectedAddress] || '';
    if (!['ì¶œì¥ì™„ë£Œ', 'ë¯¸ì¶œì¥', ''].includes(status)) {
      document.getElementById('recordStatusSelect').value = 'ì§ì ‘ì…ë ¥';
      document.getElementById('customRecordStatus').style.display = 'block';
      document.getElementById('customRecordStatus').value = status;
    } else {
      document.getElementById('customRecordStatus').style.display = 'none';
    }
    
    renderRecordPhotos();
  }
}

// Record Mode Functions
function handleRecordStatusChange() {
  const select = document.getElementById('recordStatusSelect');
  const customInput = document.getElementById('customRecordStatus');
  
  if (select.value === 'ì§ì ‘ì…ë ¥') {
    customInput.style.display = 'block';
  } else {
    customInput.style.display = 'none';
  }
}

function saveRecord() {
  if (!AppState.currentAddress) return;
  
  const statusSelect = document.getElementById('recordStatusSelect');
  const customStatus = document.getElementById('customRecordStatus');
  const memo = document.getElementById('recordMemo').value.trim();
  
  let status = statusSelect.value;
  if (status === 'ì§ì ‘ì…ë ¥') {
    status = customStatus.value.trim().substring(0, 100);
  }
  
  // Save status
  if (status) {
    statusMap[AppState.currentAddress] = status;
  } else {
    delete statusMap[AppState.currentAddress];
  }
  
  // Save memo with timestamp
  if (memo) {
    const now = new Date();
    const datePrefix = now.toISOString().slice(0, 10);
    const timePrefix = now.toTimeString().slice(0, 5);
    memoMap[AppState.currentAddress] = `${datePrefix} ${timePrefix} - ${memo}`;
  } else {
    delete memoMap[AppState.currentAddress];
  }
  
  // Save to localStorage
  localStorage.setItem('statusMap', JSON.stringify(statusMap));
  localStorage.setItem('memoMap', JSON.stringify(memoMap));
  localStorage.setItem('photoMap', JSON.stringify(photoMap));
  
  alert('ê¸°ë¡ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
  
  // Return to travel mode
  selectMode('travel');
}

// Photo handling for record mode
function saveRecordPhoto() {
  const input = document.getElementById('recordPhotoInput');
  const files = input.files;
  if (!files || !AppState.currentAddress) return;
  
  if (!Array.isArray(photoMap[AppState.currentAddress])) {
    photoMap[AppState.currentAddress] = [];
  }
  if (!Array.isArray(originalPhotoMap[AppState.currentAddress])) {
    originalPhotoMap[AppState.currentAddress] = [];
  }
  
  const urls = photoMap[AppState.currentAddress];
  if (urls.length >= 5) {
    alert('ì‚¬ì§„ì€ ìµœëŒ€ 5ì¥ê¹Œì§€ ë“±ë¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
    return;
  }
  
  Array.from(files).forEach(file => {
    if (!file.type.startsWith('image/')) return;
    const reader = new FileReader();
    reader.onload = async e => {
      const img = new Image();
      img.onload = async () => {
        const canvas = document.createElement('canvas');
        const maxW = 800;
        const scale = maxW / img.width;
        canvas.width = maxW;
        canvas.height = img.height * scale;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        const resized = canvas.toDataURL('image/jpeg', 0.8);
        
        try {
          const uploaded = await uploadToImgur(resized);
          if (uploaded) {
            photoMap[AppState.currentAddress].push(uploaded);
            originalPhotoMap[AppState.currentAddress].push(uploaded);
            localStorage.setItem('photoMap', JSON.stringify(photoMap));
            renderRecordPhotos();
          }
        } catch (error) {
          alert('ì‚¬ì§„ ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });
  
  setTimeout(() => {
    input.value = '';
  }, 500);
}

function renderRecordPhotos() {
  const container = document.getElementById('recordPhotoContainer');
  if (!container || !AppState.currentAddress) return;
  
  container.innerHTML = '';
  const photos = Array.isArray(photoMap[AppState.currentAddress]) ? photoMap[AppState.currentAddress] : [];
  
  photos.forEach((url, i) => {
    const img = document.createElement('img');
    img.src = url;
    img.className = 'photo-preview';
    img.onclick = () => handleRecordPhotoClick(i);
    container.appendChild(img);
  });
}

function handleRecordPhotoClick(index) {
  const imgUrl = originalPhotoMap[AppState.currentAddress]?.[index];
  if (!imgUrl) return;
  
  const dialog = document.createElement('div');
  dialog.style.cssText = `
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: white; padding: 20px; border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3); z-index: 9999;
  `;
  dialog.innerHTML = `
    <p style="margin-bottom: 15px; text-align: center; font-weight: 600;">ì‚¬ì§„ ì˜µì…˜ì„ ì„ íƒí•˜ì„¸ìš”</p>
    <div style="display: flex; gap: 10px; justify-content: center;">
      <button id="viewBtn" class="btn btn-primary">ğŸ“· í¬ê²Œ ë³´ê¸°</button>
      <button id="deleteBtn" class="btn btn-danger">âŒ ì‚­ì œ</button>
      <button id="cancelBtn" class="btn btn-secondary">ì·¨ì†Œ</button>
    </div>
  `;
  document.body.appendChild(dialog);
  
  document.getElementById('viewBtn').onclick = () => {
    const popup = window.open('', '_blank');
    popup.document.write(`<img src='${imgUrl}' style='max-width:100%; height:auto;'>`);
    document.body.removeChild(dialog);
  };
  document.getElementById('deleteBtn').onclick = () => {
    deleteRecordPhoto(index);
    document.body.removeChild(dialog);
  };
  document.getElementById('cancelBtn').onclick = () => {
    document.body.removeChild(dialog);
  };
}

function deleteRecordPhoto(index) {
  if (!AppState.currentAddress || !photoMap[AppState.currentAddress]) return;
  photoMap[AppState.currentAddress].splice(index, 1);
  localStorage.setItem('photoMap', JSON.stringify(photoMap));
  renderRecordPhotos();
}
  
// Summary Mode Functions
function updateSummaryMode() {
  updateTable();
  drawChart();
}

function updateTable() {
  const tbody = document.getElementById('tableBody');
  if (!tbody) return;
  
  tbody.innerHTML = '';
  ì£¼ì†Œëª©ë¡.forEach((addr, index) => {
    const rawStatus = statusMap[addr] || 'ë¯¸ì„ íƒ';
    const classStatus = ['ì¶œì¥ì™„ë£Œ', 'ë¯¸ì¶œì¥', 'ë¯¸ì„ íƒ'].includes(rawStatus) ? rawStatus : 'ì§ì ‘ì…ë ¥';
    const memo = memoMap[addr] || '-';
    const photos = Array.isArray(photoMap[addr]) ? photoMap[addr] : [];
    const photoCount = photos.length > 0 ? (photos.length + 'ì¥') : '-';
    
    const row = document.createElement('tr');
    row.style.cssText = getStatusRowStyle(classStatus);
    row.innerHTML = `
      <td style="padding: 15px; border-bottom: 1px solid #e1e5e9; text-align: center;">
        <span style="display: inline-block; width: 25px; height: 25px; background: #1b3c82; color: white; border-radius: 50%; text-align: center; line-height: 25px; font-weight: bold; font-size: 0.8rem;">
          ${index + 1}
        </span>
      </td>
      <td style="padding: 15px; border-bottom: 1px solid #e1e5e9;">${addr}</td>
      <td style="padding: 15px; border-bottom: 1px solid #e1e5e9;">${rawStatus}</td>
      <td style="padding: 15px; border-bottom: 1px solid #e1e5e9; max-width: 200px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${memo}">${memo}</td>
      <td style="padding: 15px; border-bottom: 1px solid #e1e5e9;">${photoCount}</td>
    `;
    tbody.appendChild(row);
  });
  
  // Update summary
  const summary = document.getElementById('tableSummary');
  if (summary) {
    summary.textContent = `ì´ ${ì£¼ì†Œëª©ë¡.length}ê±´`;
  }
}

function getStatusRowStyle(status) {
  switch(status) {
    case 'ì¶œì¥ì™„ë£Œ': return 'background-color: rgba(76, 175, 80, 0.1);';
    case 'ë¯¸ì¶œì¥': return 'background-color: rgba(244, 67, 54, 0.1);';
    case 'ë¯¸ì„ íƒ': return 'background-color: rgba(158, 158, 158, 0.1);';
    default: return 'background-color: rgba(255, 193, 7, 0.1);';
  }
}

function drawChart() {
  const ctx = document.getElementById('statusChart');
  if (!ctx) return;
  
  const count = { ì¶œì¥ì™„ë£Œ: 0, ë¯¸ì¶œì¥: 0, ë¯¸ì„ íƒ: 0, ì§ì ‘ì…ë ¥: 0 };
  ì£¼ì†Œëª©ë¡.forEach(addr => {
    const status = statusMap[addr] || 'ë¯¸ì„ íƒ';
    const key = ['ì¶œì¥ì™„ë£Œ', 'ë¯¸ì¶œì¥', 'ë¯¸ì„ íƒ'].includes(status) ? status : 'ì§ì ‘ì…ë ¥';
    count[key]++;
  });
  
  const data = {
    labels: Object.keys(count),
    datasets: [{
      label: 'ìƒíƒœë³„ ê°œìˆ˜',
      data: Object.values(count),
      backgroundColor: ['#4caf50', '#f44336', '#90a4ae', '#ffcc80'],
      borderRadius: 8,
      borderWidth: 0
    }]
  };
  
  if (window.myChart) window.myChart.destroy();
  window.myChart = new Chart(ctx.getContext('2d'), {
    type: 'bar',
    data: data,
    options: { 
      responsive: true, 
      plugins: { 
        legend: { display: false },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          titleColor: 'white',
          bodyColor: 'white',
          borderColor: 'rgba(255, 255, 255, 0.2)',
          borderWidth: 1,
          cornerRadius: 8
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          grid: {
            color: 'rgba(0, 0, 0, 0.1)'
          }
        },
        x: {
          grid: {
            display: false
          }
        }
      }
    }
  });
  
  const total = Object.values(count).reduce((a, b) => a + b, 0);
  const statsCount = document.getElementById('statsCount');
  const chartText = document.getElementById('chartTextOutput');
  
  if (statsCount) {
    statsCount.textContent = `ì´ í•­ëª© ìˆ˜: ${total}ê±´`;
  }
  if (chartText) {
    chartText.textContent = Object.entries(count).map(([k,v]) => `${k}: ${v}ê±´`).join(' / ');
  }
}

function copyTable() {
  let text = 'ìˆœì„œ\tì£¼ì†Œ\tìƒíƒœ\të©”ëª¨\tì‚¬ì§„ê°œìˆ˜\n';
  ì£¼ì†Œëª©ë¡.forEach((addr, index) => {
    const status = statusMap[addr] || 'ë¯¸ì„ íƒ';
    const memo = (memoMap[addr] || '').replace(/\n/g, ' ');
    const photoCount = Array.isArray(photoMap[addr]) ? photoMap[addr].length : 0;
    text += (index + 1) + '\t' + addr + '\t' + status + '\t' + memo + '\t' + photoCount + '\n';
  });
  navigator.clipboard.writeText(text).then(() => alert('ë³µì‚¬ ì™„ë£Œ'));
}

function exportText() {
  let content = 'ì¶œì¥ ê¸°ë¡ - í…ìŠ¤íŠ¸ ë²„ì „\n';
  content += '='.repeat(50) + '\n\n';
  
  ì£¼ì†Œëª©ë¡.forEach((addr, index) => {
    const status = statusMap[addr] || 'ë¯¸ì„ íƒ';
    const memo = memoMap[addr] || 'ê¸°ë¡ ì—†ìŒ';
    const photoCount = Array.isArray(photoMap[addr]) ? photoMap[addr].length : 0;
    
    content += `${index + 1}. ${addr}\n`;
    content += `   ìƒíƒœ: ${status}\n`;
    content += `   ë©”ëª¨: ${memo}\n`;
    content += `   ì‚¬ì§„: ${photoCount}ì¥\n`;
    content += '-'.repeat(30) + '\n';
  });
  
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'ì¶œì¥ê¸°ë¡.txt';
  link.click();
}

function exportExcel() {
  const wb = XLSX.utils.book_new();
  const data = [['ìˆœì„œ', 'ì£¼ì†Œ', 'ìƒíƒœ', 'ë©”ëª¨', 'ì‚¬ì§„1', 'ì‚¬ì§„2', 'ì‚¬ì§„3', 'ì‚¬ì§„4', 'ì‚¬ì§„5']];
  ì£¼ì†Œëª©ë¡.forEach((addr, index) => {
    const status = statusMap[addr] || 'ë¯¸ì„ íƒ';
    const memo = memoMap[addr] || '';
    const photos = Array.isArray(photoMap[addr]) ? photoMap[addr] : [];
    const limitedMemo = memo.length > 10000 ? memo.slice(0, 10000) + '...' : memo;
    const row = [index + 1, addr, status, limitedMemo, ...photos.slice(0, 5)];
    while (row.length < 9) row.push('');
    data.push(row);
  });
  const ws = XLSX.utils.aoa_to_sheet(data);
  
  // ì‚¬ì§„ ë§í¬ ì…€ì— í•˜ì´í¼ë§í¬ ì¶”ê°€
  data.forEach((row, rowIndex) => {
    if (rowIndex === 0) return;
    for (let i = 4; i <= 8; i++) {
      const cellAddr = XLSX.utils.encode_cell({ r: rowIndex, c: i });
      const val = row[i];
      if (val && typeof val === 'string') {
        ws[cellAddr].l = { Target: val };
      }
    }
  });
  
  XLSX.utils.book_append_sheet(wb, ws, 'ì¶œì¥ê¸°ë¡');
  XLSX.writeFile(wb, 'ì¶œì¥ê¸°ë¡.xlsx');
}

  
  // Utility Functions
function saveMapPreference() {
  preferredMap = document.getElementById('mapSelect').value;
  if (document.getElementById('rememberMap') && document.getElementById('rememberMap').checked) {
    localStorage.setItem('preferredMap', preferredMap);
  }
}

function saveAddressList() {
  localStorage.setItem('addressList', JSON.stringify(ì£¼ì†Œëª©ë¡));
}

function loadAddressList() {
  const saved = localStorage.getItem('addressList');
  if (saved) {
    ì£¼ì†Œëª©ë¡ = JSON.parse(saved);
  }
}

function loadStatusData() {
  const saved = localStorage.getItem('statusMap');
  if (saved) {
    statusMap = JSON.parse(saved);
  }
}

function loadMemoData() {
  const saved = localStorage.getItem('memoMap');
  if (saved) {
    memoMap = JSON.parse(saved);
  }
}

function loadPhotoData() {
  const saved = localStorage.getItem('photoMap');
  if (saved) {
    photoMap = JSON.parse(saved);
  }
}

function loadViewedAddresses() {
  const saved = localStorage.getItem('viewedAddresses');
  if (saved) {
    const viewedArray = JSON.parse(saved);
    viewedAddresses = new Set(viewedArray);
  }
}

function saveViewedAddresses() {
  localStorage.setItem('viewedAddresses', JSON.stringify([...viewedAddresses]));
}

function resetAddressList() {
  if (!confirm('ëª¨ë“  ì£¼ì†Œ ëª©ë¡ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
  
  ì£¼ì†Œëª©ë¡ = [];
  AppState.currentAddress = null;
  saveAddressList();
  updateAddressPreview();
  updateTravelMode();
  alert('ì£¼ì†Œ ëª©ë¡ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
}

function resetStatusMap() {
  if (!confirm('ëª¨ë“  ìƒíƒœ ì •ë³´ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
  
  statusMap = {};
  localStorage.removeItem('statusMap');
  alert('ìƒíƒœ ì •ë³´ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
}

// File handling functions
function loadAddressFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const lines = e.target.result.split(/\r?\n/).filter(line => line.trim());
    const newList = [];
    let added = 0;
    
    lines.forEach(line => {
      const [addr, status] = line.split('\t');
      const trimmedAddr = addr?.trim();
      if (trimmedAddr && !ì£¼ì†Œëª©ë¡.includes(trimmedAddr)) {
        newList.push(trimmedAddr);
        if (status) statusMap[trimmedAddr] = status.trim();
        added++;
      } else if (trimmedAddr && status) {
        statusMap[trimmedAddr] = status.trim();
      }
    });
    
    ì£¼ì†Œëª©ë¡ = [...ì£¼ì†Œëª©ë¡, ...newList];
    alert(`ì£¼ì†Œ íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ: ${lines.length}ê±´ ì¤‘ ${added}ê±´ ì¶”ê°€ë¨ (ì´ ${ì£¼ì†Œëª©ë¡.length}ê±´)`);
    
    saveAddressList();
    localStorage.setItem('statusMap', JSON.stringify(statusMap));
    nextStep(3);
  };
  
  reader.readAsText(file, 'UTF-8');
}

function addFromTextarea() {
  const input = document.getElementById('bulkPaste').value;
  if (!input) {
    alert('ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
    return;
  }
  
  const lines = input.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  const newList = lines.filter(l => !ì£¼ì†Œëª©ë¡.includes(l));
  ì£¼ì†Œëª©ë¡ = [...ì£¼ì†Œëª©ë¡, ...newList];
  saveAddressList();
  
  alert(`${newList.length}ê°œì˜ ì£¼ì†Œê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`);
  document.getElementById('bulkPaste').value = '';
  nextStep(3);
}

// Imgur upload function
function uploadToImgur(base64Image) {
  return fetch('https://api.imgur.com/3/image', {
    method: 'POST',
    headers: {
      Authorization: 'Client-ID a0058fd0a6e3657',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      image: base64Image.split(',')[1],
      type: 'base64'
    })
  })
  .then(res => res.json())
  .then(data => {
    if (data.success && data.data && data.data.link) {
      return data.data.link;
    } else {
      throw new Error('Imgur ì—…ë¡œë“œ ì‹¤íŒ¨');
    }
  });
}

// Optimal Route Variables
// API í‚¤ëŠ” ì‚¬ìš©ìê°€ ì§ì ‘ ì…ë ¥í•˜ì—¬ ì‚¬ìš© (ë³´ì•ˆìƒ í•˜ë“œì½”ë”© ê¸ˆì§€)
let GEMINI_API_KEY = localStorage.getItem('gemini-api-key') || '';
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent';

// Debug Log System
let debugLogs = [];
function addDebugLog(message, data = null) {
  const timestamp = new Date().toISOString();
  const logEntry = {
    timestamp,
    message,
    data: data ? JSON.stringify(data, null, 2) : null
  };
  debugLogs.push(logEntry);
  console.log(`[DEBUG ${timestamp}] ${message}`, data);
  
  // Keep only last 100 logs
  if (debugLogs.length > 100) {
    debugLogs = debugLogs.slice(-100);
  }
}

function downloadDebugLogs() {
  const logContent = debugLogs.map(log => {
    let entry = `[${log.timestamp}] ${log.message}`;
    if (log.data) {
      entry += `\n${log.data}`;
    }
    return entry;
  }).join('\n\n' + '='.repeat(50) + '\n\n');
  
  const blob = new Blob([logContent], { type: 'text/plain;charset=utf-8' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = `debug_log_${new Date().toISOString().slice(0,19).replace(/[:.]/g, '-')}.txt`;
  link.click();
}

// Optimal Route Functions
function showOptimalRouteModal() {
  if (ì£¼ì†Œëª©ë¡.length < 2) {
    alert('ìµœì ê²½ë¡œ ì¶”ì²œì„ ìœ„í•´ì„œëŠ” ìµœì†Œ 2ê³³ ì´ìƒì˜ ì¶œì¥ì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤.');
    return;
  }
  
  // Update address count and preview
  document.getElementById('route-address-count').textContent = ì£¼ì†Œëª©ë¡.length;
  const preview = document.getElementById('route-address-preview');
  preview.innerHTML = ì£¼ì†Œëª©ë¡.slice(0, 5).map(addr => `â€¢ ${addr}`).join('<br>') + 
    (ì£¼ì†Œëª©ë¡.length > 5 ? `<br>â€¢ ... ì™¸ ${ì£¼ì†Œëª©ë¡.length - 5}ê³³` : '');
  
  document.getElementById('optimalRouteModal').classList.add('show');
  
  // Initialize route API key status
  initializeRouteApiKey();
}

// Route Modal API Key Management Functions
function saveRouteApiKey() {
  const apiKeyInput = document.getElementById('route-api-key-input');
  const newKey = apiKeyInput.value.trim();
  
  if (!newKey) {
    updateRouteApiStatus('API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”', 'error');
    return;
  }
  
  if (!newKey.startsWith('AIzaSy') || newKey.length < 30) {
    updateRouteApiStatus('ì˜¬ë°”ë¥¸ Gemini API í‚¤ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤', 'error');
    return;
  }
  
  GEMINI_API_KEY = newKey;
  localStorage.setItem('gemini-api-key', newKey);
  updateRouteApiStatus('ì €ì¥ì™„ë£Œ', 'success');
  
  // 1ë‹¨ê³„ì˜ API í‚¤ ì…ë ¥ì°½ë„ ë™ê¸°í™”
  const mainApiInput = document.getElementById('api-key-input');
  if (mainApiInput) {
    mainApiInput.value = newKey;
    updateApiStatus('ì €ì¥ëœ API í‚¤ ë¡œë“œë¨', 'success');
  }
}

async function testRouteApiKey() {
  const apiKeyInput = document.getElementById('route-api-key-input');
  const testKey = apiKeyInput.value.trim();
  
  if (!testKey) {
    updateRouteApiStatus('API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”', 'error');
    return;
  }
  
  updateRouteApiStatus('í…ŒìŠ¤íŠ¸ì¤‘...', 'loading');
  
  try {
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${testKey}`);
    
    if (response.ok) {
      updateRouteApiStatus('ì •ìƒì‘ë™', 'success');
    } else {
      updateRouteApiStatus('í‚¤ ë¬´íš¨', 'error');
    }
  } catch (error) {
    updateRouteApiStatus('ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜', 'error');
  }
}

function updateRouteApiStatus(message, type) {
  const statusEl = document.getElementById('route-api-status');
  statusEl.textContent = message;
  
  const styles = {
    success: 'background: #d4edda; color: #155724;',
    error: 'background: #f8d7da; color: #721c24;',
    loading: 'background: #d1ecf1; color: #0c5460;'
  };
  
  statusEl.style.cssText = styles[type] || '';
}

function initializeRouteApiKey() {
  const apiKeyInput = document.getElementById('route-api-key-input');
  if (apiKeyInput) {
    apiKeyInput.value = GEMINI_API_KEY || '';
    if (GEMINI_API_KEY) {
      updateRouteApiStatus('ë¡œë“œë¨', 'success');
    } else {
      updateRouteApiStatus('API í‚¤ í•„ìš”', 'error');
    }
  }
}

async function calculateOptimalRoute() {
  addDebugLog('=== ìµœì ê²½ë¡œ ê³„ì‚° ì‹œì‘ ===');
  
  const startLocation = document.getElementById('startLocation').value.trim() || 'ì•„ì°¨ì‚°ë¡œ 400';
  addDebugLog('ì¶œë°œì§€ ì…ë ¥ê°’', { startLocation });
  addDebugLog('í˜„ì¬ ì£¼ì†Œëª©ë¡', { addresses: ì£¼ì†Œëª©ë¡, count: ì£¼ì†Œëª©ë¡.length });
  
  // ë‹¤ì¤‘ ìµœì í™” ì „ëµ ì‹¤í–‰
  document.getElementById('calculate-route-btn').disabled = true;
  document.getElementById('calculate-route-btn').textContent = 'ğŸ§  ê³ ê¸‰ ë¶„ì„ ì¤‘...';
  
  try {
    // 1. ê³ ê¸‰ ë¶„ì„ ì‹œë„ (ì¢Œí‘œ ê¸°ë°˜ TSP)
    addDebugLog('1ë‹¨ê³„: ê³ ê¸‰ ë¶„ì„ ì‹œë„');
    const advancedResult = await performAdvancedOptimization(startLocation, ì£¼ì†Œëª©ë¡);
    
    let primaryResult = null;
    let fallbackResult = null;
    
    if (advancedResult.success) {
      primaryResult = {
        order: advancedResult.addresses, // Use the actual optimized addresses
        method: advancedResult.method || 'ê³ ê¸‰ TSP ì•Œê³ ë¦¬ì¦˜',
        distance: advancedResult.totalDistance,
        coordinates: advancedResult.coordinates
      };
      addDebugLog('ê³ ê¸‰ ë¶„ì„ ì„±ê³µ', primaryResult);
    }
    
    // 2. Gemini AI ë¶„ì„ ì‹œë„ (API í‚¤ê°€ ìˆëŠ” ê²½ìš°)
    if (GEMINI_API_KEY && GEMINI_API_KEY.startsWith('AIzaSy')) {
      addDebugLog('2ë‹¨ê³„: Gemini AI ë¶„ì„ ì‹œë„');
      document.getElementById('calculate-route-btn').textContent = 'ğŸ¤– AI ë¶„ì„ ì¤‘...';
      
      try {
        const geminiOrder = await getOptimalRouteFromGemini(startLocation, ì£¼ì†Œëª©ë¡);
        // Convert Gemini indices to addresses
        const geminiAddresses = geminiOrder.map(index => ì£¼ì†Œëª©ë¡[index]).filter(addr => addr);
        const geminiResult = {
          order: geminiAddresses,
          method: 'Gemini AI ì¶”ë¡ ',
          distance: null // GeminiëŠ” ê±°ë¦¬ ê³„ì‚° ì•ˆí•¨
        };
        
        // ê³ ê¸‰ ë¶„ì„ ê²°ê³¼ê°€ ìˆìœ¼ë©´ ë³´ì¡°ë¡œ, ì—†ìœ¼ë©´ ì£¼ ê²°ê³¼ë¡œ ì‚¬ìš©
        if (primaryResult) {
          fallbackResult = geminiResult;
        } else {
          primaryResult = geminiResult;
        }
        addDebugLog('Gemini AI ë¶„ì„ ì„±ê³µ', geminiResult);
      } catch (geminiError) {
        addDebugLog('Gemini AI ë¶„ì„ ì‹¤íŒ¨', { error: geminiError.message });
      }
    }
    
    // 3. ì§€ì—­ ê¸°ë°˜ ë°±ì—… ì•Œê³ ë¦¬ì¦˜
    if (!primaryResult) {
      addDebugLog('3ë‹¨ê³„: ë°±ì—… ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰');
      const backupOrder = getSimpleFallbackOrder(ì£¼ì†Œëª©ë¡);
      primaryResult = {
        order: backupOrder,
        method: 'ì§€ì—­ ê¸°ë°˜ ì•Œê³ ë¦¬ì¦˜',
        distance: null
      };
      addDebugLog('ë°±ì—… ì•Œê³ ë¦¬ì¦˜ ì™„ë£Œ', primaryResult);
    }
    
    // ê²°ê³¼ ì ìš©
    reorderAddressList(primaryResult.order);
    
    // ì„±ê³µ ë©”ì‹œì§€ êµ¬ì„±
    let successMessage = 'ê²½ë¡œ ìµœì í™” ì™„ë£Œ!\n\nì‚¬ìš©ëœ ë¶„ì„ ë°©ë²•: ' + primaryResult.method;
    
    if (primaryResult.distance) {
      const distance = typeof primaryResult.distance === 'string' ? 
        parseFloat(primaryResult.distance) : primaryResult.distance;
      if (!isNaN(distance)) {
        successMessage += '\nì˜ˆìƒ ì´ ê±°ë¦¬: ' + distance + 'km';
      }
    }
    
    if (primaryResult.coordinates) {
      successMessage += '\nì‹¤ì œ ì¢Œí‘œ ê¸°ë°˜ ë¶„ì„ ì™„ë£Œ';
    }
    
    if (primaryResult.clusters) {
      const clusterCount = Object.keys(primaryResult.clusters).length;
      successMessage += `\nğŸ¯ ${clusterCount}ê°œ ì§€ì—­ êµ°ì§‘ ë¶„ì„ ì™„ë£Œ`;
    }
    
    if (fallbackResult) {
      successMessage += `\n\nğŸ’¡ ì¶”ê°€ë¡œ ${fallbackResult.method} ê²°ê³¼ë„ í™•ì¸ë˜ì—ˆìŠµë‹ˆë‹¤.`;
    }
    
    alert(successMessage);
    addDebugLog('=== ìµœì ê²½ë¡œ ê³„ì‚° ì„±ê³µ ì™„ë£Œ ===');
    
    // Close modal and switch to travel mode
    closeModal();
    selectMode('travel');
    
  } catch (error) {
    addDebugLog('ìµœì ê²½ë¡œ ê³„ì‚° ì¤‘ ì˜¤ë¥˜ ë°œìƒ', { 
      error: error.message,
      stack: error.stack,
      addresses: ì£¼ì†Œëª©ë¡
    });
    
    // ìµœì¢… ë°±ì—…: ë‹¨ìˆœ ìˆœì„œ ìœ ì§€
    alert('âš ï¸ ëª¨ë“  ìµœì í™” ì•Œê³ ë¦¬ì¦˜ì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ê¸°ë³¸ ìˆœì„œë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.\nì½˜ì†”(F12)ì—ì„œ ìì„¸í•œ ì˜¤ë¥˜ ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
    
  } finally {
    // UI ë³µêµ¬
    document.getElementById('calculate-route-btn').disabled = false;
    document.getElementById('calculate-route-btn').textContent = 'ğŸ¯ ê³ ê¸‰ ê²½ë¡œ ìµœì í™” (TSP + AI)';
  }
}

// ì£¼ì†Œ ëª©ë¡ ì¬ì •ë ¬ í•¨ìˆ˜
function reorderAddressList(newOrderAddresses) {
  if (!newOrderAddresses || newOrderAddresses.length === 0) {
    addDebugLog('ì¬ì •ë ¬í•  ìˆœì„œê°€ ì—†ìŒ');
    return;
  }
  
  addDebugLog('ì£¼ì†Œ ëª©ë¡ ì¬ì •ë ¬ ì‹œì‘', { 
    originalOrder: ì£¼ì†Œëª©ë¡, 
    newOrderAddresses 
  });
  
  // Store optimized route for display purposes (don't modify original ì£¼ì†Œëª©ë¡)
  optimizedRoute = [...newOrderAddresses];
  
  addDebugLog('ìµœì í™”ëœ ê²½ë¡œ ì €ì¥ ì™„ë£Œ', { optimizedRoute });
  
  // Update only Travel mode UI to show optimized order
  if (AppState.currentMode === 'travel') {
    updateTravelMode();
  }
  
  addDebugLog('ì£¼ì†Œëª©ë¡ ì¬ì •ë ¬ ì™„ë£Œ');
}

async function getOptimalRouteFromGemini(startLocation, destinations) {
  addDebugLog('Gemini API í•¨ìˆ˜ ì‹œì‘', { startLocation, destinations });
  
  // API í‚¤ ë³´ì•ˆ ì²´í¬
  if (!GEMINI_API_KEY || !GEMINI_API_KEY.startsWith('AIzaSy')) {
    addDebugLog('API í‚¤ ì—†ìŒ - fallback ì‚¬ìš©');
    throw new Error('API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. 1ë‹¨ê³„ì—ì„œ API í‚¤ë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”.');
  }
  
  const prompt = `ê²½ë¡œ ìµœì í™” - ìˆ«ìë§Œ ì‘ë‹µ

ì¶œë°œ: ${startLocation}
ëª©ì ì§€: ${destinations.map((addr, i) => `${i}.${addr}`).join(' / ')}

ê·œì¹™: ê±°ë¦¬ìˆœâ†’ê¶Œì—­ë¬¶ìŒâ†’ê°„ì„ ë„ë¡œâ†’ì¢ŒíšŒì „ìµœì†Œâ†’ë³µê·€íš¨ìœ¨

ì‘ë‹µí˜•ì‹: [0,1,2,3,4,5,6]
ì£¼ì˜: ì„¤ëª…ê¸ˆì§€, ìˆ«ìë°°ì—´ë§Œ ì¶œë ¥`;

  addDebugLog('ìƒì„±ëœ í”„ë¡¬í”„íŠ¸', { prompt });

  const requestBody = {
    contents: [{
      parts: [{
        text: prompt
      }]
    }]
  };

  addDebugLog('API ìš”ì²­ ë°”ë””', { requestBody });

  try {
    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    addDebugLog('API ì‘ë‹µ ìƒíƒœ', { 
      status: response.status, 
      statusText: response.statusText 
    });

    if (!response.ok) {
      const errorText = await response.text();
      addDebugLog('API ì˜¤ë¥˜ ì‘ë‹µ', { errorText });
      throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
    }

    const data = await response.json();
    addDebugLog('ì›ë³¸ API ì‘ë‹µ', { data });

    if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
      throw new Error('API ì‘ë‹µì— ìœ íš¨í•œ contentê°€ ì—†ìŠµë‹ˆë‹¤.');
    }

    const text = data.candidates[0].content.parts[0].text;
    addDebugLog('ì¶”ì¶œëœ í…ìŠ¤íŠ¸', { text });

    return parseOptimalOrderResponse(text);

  } catch (error) {
    addDebugLog('Gemini API í˜¸ì¶œ ì‹¤íŒ¨', { error: error.message });
    throw error;
  }
}

// Gemini ì‘ë‹µ íŒŒì‹± í•¨ìˆ˜
function parseOptimalOrderResponse(text) {
  try {
    // ì‘ë‹µì—ì„œ ì„¤ëª… í…ìŠ¤íŠ¸ ì œê±°í•˜ê³  ìˆ«ì ë°°ì—´ë§Œ ì¶”ì¶œ
    let cleanText = text
      .replace(/```json\n?/g, '')
      .replace(/```\n?/g, '')
      .replace(/\*\*.*?\*\*/g, '')  // **êµµì€ í…ìŠ¤íŠ¸** ì œê±°
      .replace(/ì£¼ì–´ì§„.*?ë•Œë¬¸ì…ë‹ˆë‹¤\./gs, '')  // ë¶ˆí•„ìš”í•œ ì„¤ëª… ì œê±°
      .replace(/í•˜ì§€ë§Œ.*?ì œì‹œí•´.*?ë³´ê² ìŠµë‹ˆë‹¤\./gs, '')  // ë¶ˆí•„ìš”í•œ ì„¤ëª… ì œê±°
      .replace(/ì¶”ì •.*?ê³¼ì •.*?ì„¤ëª…ì…ë‹ˆë‹¤\./gs, '')  // ë¶ˆí•„ìš”í•œ ì„¤ëª… ì œê±°
      .replace(/ì •í™•í•œ.*?ë°”ëë‹ˆë‹¤\./gs, '')  // ë¶ˆí•„ìš”í•œ ì„¤ëª… ì œê±°
      .trim();
    
    addDebugLog('ì •ë¦¬ëœ í…ìŠ¤íŠ¸', { cleanText });
    
    // ìˆ«ì ë°°ì—´ íŒ¨í„´ ì°¾ê¸° (ë” ìœ ì—°í•œ íŒ¨í„´)
    const arrayPatterns = [
      /\[[\d,\s]+\]/,           // ê¸°ë³¸ íŒ¨í„´: [0,1,2,3]
      /\[[\d\s,]+\]/,           // ê³µë°± í¬í•¨: [0, 1, 2, 3]
      /\[[\d\s,\n]+\]/,         // ì¤„ë°”ê¿ˆ í¬í•¨
      /\[\s*\d+(?:\s*,\s*\d+)*\s*\]/  // ë” ìœ ì—°í•œ íŒ¨í„´
    ];
    
    let match = null;
    for (const pattern of arrayPatterns) {
      match = cleanText.match(pattern);
      if (match) break;
    }
    
    addDebugLog('ì •ê·œì‹ ë§¤ì¹­ ê²°ê³¼', { match, originalText: text.substring(0, 200) + '...', cleanText });
    
    if (match) {
      const optimalOrder = JSON.parse(match[0]);
      addDebugLog('íŒŒì‹±ëœ ìµœì  ìˆœì„œ', { optimalOrder });
      
      // Validate the result
      if (!Array.isArray(optimalOrder)) {
        throw new Error('Result is not an array');
      }
      
      if (optimalOrder.length === 0) {
        throw new Error('Empty result array');
      }
      
      // Validate each index
      const validOrder = optimalOrder.filter(index => 
        typeof index === 'number' && index >= 0
      );
      
      addDebugLog('ê²€ì¦ëœ ìˆœì„œ', { validOrder });
      return validOrder;
      
    } else {
      addDebugLog('ë°°ì—´ íŒ¨í„´ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ');
      throw new Error('Could not find valid array pattern in response');
    }
    
  } catch (error) {
    addDebugLog('ì‘ë‹µ íŒŒì‹± ì˜¤ë¥˜', { error: error.message, text });
    throw new Error(`Failed to parse optimal order: ${error.message}`);
  }
}


// ===== ê³ ê¸‰ ê²½ë¡œ ìµœì í™” ì‹œìŠ¤í…œ =====

// 2ë‹¨ê³„: ê±°ë¦¬ ë§¤íŠ¸ë¦­ìŠ¤ ê³„ì‚°
function calculateDistanceMatrix(coordinates) {
  addDebugLog('2ë‹¨ê³„: ê±°ë¦¬ ë§¤íŠ¸ë¦­ìŠ¤ ê³„ì‚° ì‹œì‘');
  
  const addresses = Object.keys(coordinates);
  const size = addresses.length;
  const matrix = Array(size).fill().map(() => Array(size).fill(0));
  
  for (let i = 0; i < size; i++) {
    for (let j = i; j < size; j++) {
      const dist = haversineDistance(
        coordinates[addresses[i]],
        coordinates[addresses[j]]
      );
      matrix[i][j] = matrix[j][i] = Math.round(dist * 100) / 100; // ì†Œìˆ˜ì  2ìë¦¬
    }
  }
  
  addDebugLog('ê±°ë¦¬ ë§¤íŠ¸ë¦­ìŠ¤ ì™„ë£Œ', { matrix, addresses });
  return { matrix, addresses };
}

// Haversine ê³µì‹ìœ¼ë¡œ ë‘ ì¢Œí‘œ ê°„ ê±°ë¦¬ ê³„ì‚° (km)
function haversineDistance(coord1, coord2) {
  const R = 6371; // ì§€êµ¬ ë°˜ì§€ë¦„ (km)
  const dLat = toRad(coord2.lat - coord1.lat);
  const dLng = toRad(coord2.lng - coord1.lng);
  
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(toRad(coord1.lat)) * Math.cos(toRad(coord2.lat)) *
    Math.sin(dLng/2) * Math.sin(dLng/2);
  
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

function toRad(deg) {
  return deg * (Math.PI / 180);
}

// 3ë‹¨ê³„: K-means êµ°ì§‘ ë¶„ì„
function performClustering(coordinates, numClusters = 3) {
  addDebugLog('3ë‹¨ê³„: êµ°ì§‘ ë¶„ì„ ì‹œì‘', { numClusters });
  
  const addresses = Object.keys(coordinates);
  const points = addresses.map(addr => [coordinates[addr].lat, coordinates[addr].lng]);
  
  if (points.length <= numClusters) {
    // ì§€ì ì´ ì ìœ¼ë©´ ê°ê°ì„ ë³„ë„ êµ°ì§‘ìœ¼ë¡œ
    const clusters = addresses.reduce((acc, addr, i) => {
      acc[addr] = i;
      return acc;
    }, {});
    addDebugLog('êµ°ì§‘ ë¶„ì„ ì™„ë£Œ (ê°œë³„ êµ°ì§‘)', { clusters });
    return clusters;
  }
  
  // ê°„ë‹¨í•œ K-means êµ¬í˜„
  const clusters = simpleKMeans(points, numClusters);
  const clusterMap = addresses.reduce((acc, addr, i) => {
    acc[addr] = clusters[i];
    return acc;
  }, {});
  
  addDebugLog('êµ°ì§‘ ë¶„ì„ ì™„ë£Œ', { clusterMap });
  return clusterMap;
}

// ê°„ë‹¨í•œ K-means ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
function simpleKMeans(points, k, maxIterations = 10) {
  // ì´ˆê¸° ì¤‘ì‹¬ì  ëœë¤ ì„ íƒ
  let centroids = [];
  for (let i = 0; i < k; i++) {
    centroids.push([...points[Math.floor(Math.random() * points.length)]]);
  }
  
  let clusters = new Array(points.length);
  
  for (let iter = 0; iter < maxIterations; iter++) {
    // ê° ì ì„ ê°€ì¥ ê°€ê¹Œìš´ ì¤‘ì‹¬ì ì— í• ë‹¹
    for (let i = 0; i < points.length; i++) {
      let minDist = Infinity;
      let minCluster = 0;
      
      for (let j = 0; j < k; j++) {
        const dist = Math.sqrt(
          Math.pow(points[i][0] - centroids[j][0], 2) +
          Math.pow(points[i][1] - centroids[j][1], 2)
        );
        if (dist < minDist) {
          minDist = dist;
          minCluster = j;
        }
      }
      clusters[i] = minCluster;
    }
    
    // ìƒˆë¡œìš´ ì¤‘ì‹¬ì  ê³„ì‚°
    const newCentroids = Array(k).fill().map(() => [0, 0]);
    const counts = Array(k).fill(0);
    
    for (let i = 0; i < points.length; i++) {
      const cluster = clusters[i];
      newCentroids[cluster][0] += points[i][0];
      newCentroids[cluster][1] += points[i][1];
      counts[cluster]++;
    }
    
    for (let j = 0; j < k; j++) {
      if (counts[j] > 0) {
        newCentroids[j][0] /= counts[j];
        newCentroids[j][1] /= counts[j];
      }
    }
    
    centroids = newCentroids;
  }
  
  return clusters;
}

// 4ë‹¨ê³„: TSP ìµœì í™” (ì‘ì€ ê·œëª¨ìš©)
function solveTSP(distanceMatrix, startIndex = 0) {
  addDebugLog('4ë‹¨ê³„: TSP ìµœì í™” ì‹œì‘');
  
  const n = distanceMatrix.length;
  if (n <= 1) return [0];
  if (n === 2) return [0, 1];
  
  // ì‘ì€ ê·œëª¨(<=8)ë©´ ì™„ì „ íƒìƒ‰, í° ê·œëª¨ë©´ íœ´ë¦¬ìŠ¤í‹±
  if (n <= 8) {
    return bruteForceTSP(distanceMatrix, startIndex);
  } else {
    return nearestNeighborTSP(distanceMatrix, startIndex);
  }
}

// ì™„ì „ íƒìƒ‰ TSP (ì‘ì€ ê·œëª¨ìš©)
function bruteForceTSP(matrix, start) {
  const n = matrix.length;
  const others = [];
  for (let i = 0; i < n; i++) {
    if (i !== start) others.push(i);
  }
  
  let bestPath = null;
  let bestDistance = Infinity;
  
  const permutations = getPermutations(others);
  
  for (const perm of permutations) {
    const path = [start, ...perm];
    const distance = calculatePathDistance(matrix, path, true); // ë³µê·€ í¬í•¨
    
    if (distance < bestDistance) {
      bestDistance = distance;
      bestPath = [...path];
    }
  }
  
  addDebugLog('ì™„ì „ íƒìƒ‰ TSP ì™„ë£Œ', { bestPath, bestDistance });
  return bestPath;
}

// ìµœê·¼ì ‘ ì´ì›ƒ TSP (í° ê·œëª¨ìš©)
function nearestNeighborTSP(matrix, start) {
  const n = matrix.length;
  const visited = new Array(n).fill(false);
  const path = [start];
  visited[start] = true;
  
  let current = start;
  
  for (let i = 1; i < n; i++) {
    let nearest = -1;
    let minDist = Infinity;
    
    for (let j = 0; j < n; j++) {
      if (!visited[j] && matrix[current][j] < minDist) {
        minDist = matrix[current][j];
        nearest = j;
      }
    }
    
    if (nearest !== -1) {
      path.push(nearest);
      visited[nearest] = true;
      current = nearest;
    }
  }
  
  const totalDistance = calculatePathDistance(matrix, path, true);
  addDebugLog('ìµœê·¼ì ‘ ì´ì›ƒ TSP ì™„ë£Œ', { path, totalDistance });
  return path;
}

// ê²½ë¡œì˜ ì´ ê±°ë¦¬ ê³„ì‚°
function calculatePathDistance(matrix, path, includeReturn = false) {
  let total = 0;
  for (let i = 0; i < path.length - 1; i++) {
    total += matrix[path[i]][path[i + 1]];
  }
  if (includeReturn && path.length > 1) {
    total += matrix[path[path.length - 1]][path[0]]; // ì¶œë°œì§€ë¡œ ë³µê·€
  }
  return total;
}

// ìˆœì—´ ìƒì„± (ì™„ì „ íƒìƒ‰ìš©)
function getPermutations(arr) {
  if (arr.length <= 1) return [arr];
  
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];
    const perms = getPermutations(rest);
    for (const perm of perms) {
      result.push([arr[i], ...perm]);
    }
  }
  return result;
}

// í†µí•© ê³ ê¸‰ ê²½ë¡œ ìµœì í™” í•¨ìˆ˜
async function performAdvancedOptimization(startAddress, destinations) {
  try {
    addDebugLog('=== ê³ ê¸‰ ê²½ë¡œ ìµœì í™” ì‹œì‘ ===');
    
    // 1ë‹¨ê³„: ì¢Œí‘œ ë³€í™˜ - ëª¨ë“  ì£¼ì†Œë¥¼ ë³‘ë ¬ë¡œ ì²˜ë¦¬
    const allAddresses = [startAddress, ...destinations];
    addDebugLog('ì¢Œí‘œ ë³€í™˜ ì‹œì‘', { addresses: allAddresses });
    
    // Force clear cache if all coordinates are identical (old cache issue)
    const existingCoords = Object.values(coordinatesCache);
    if (existingCoords.length > 1) {
      const firstCoord = existingCoords[0];
      const allSame = existingCoords.every(coord => 
        coord && firstCoord && 
        Math.abs(coord.lat - firstCoord.lat) < 0.0001 && 
        Math.abs(coord.lng - firstCoord.lng) < 0.0001
      );
      if (allSame) {
        addDebugLog('ë™ì¼ ì¢Œí‘œ ê°ì§€ - ìºì‹œ ê°•ì œ ì´ˆê¸°í™”');
        coordinatesCache = {};
        localStorage.removeItem("coordinatesCache");
      }
    }
    
    for (const address of allAddresses) {
      await geocodeAddress(address);
    }
    
    addDebugLog('ì¢Œí‘œ ìºì‹œ ìƒíƒœ', { coordinatesCache });
    
    // 2ë‹¨ê³„: ìµœì í™” ì „ ì¢Œí‘œ ê²€ì¦
    const validCoordCount = allAddresses.filter(addr => {
      const coord = coordinatesCache[addr];
      return coord && coord.lat && coord.lng;
    }).length;

    if (validCoordCount < allAddresses.length) {
      addDebugLog('ì¢Œí‘œ ë³€í™˜ ë¶ˆì™„ì „', { 
        total: allAddresses.length, 
        valid: validCoordCount 
      });
      
      // fallback ì „ëµ ì‹¤í–‰
      if (validCoordCount === 0) {
        addDebugLog('ëª¨ë“  ì¢Œí‘œ ë³€í™˜ ì‹¤íŒ¨ - ì§€ë¦¬ì  fallback ì‚¬ìš©');
        return getGeographicFallback(destinations, startAddress);
      }
    }

    // 3ë‹¨ê³„: ë‹¤ì¤‘ ì•Œê³ ë¦¬ì¦˜ ìµœì  ê²½ë¡œ ê³„ì‚°
    const optimizationResult = optimizeRouteMultiAlgorithm(destinations, startAddress);
    
    if (!optimizationResult || !optimizationResult.route) {
      addDebugLog('ë‹¤ì¤‘ ì•Œê³ ë¦¬ì¦˜ ì‹¤íŒ¨ - ì§€ë¦¬ì  fallback ì‚¬ìš©');
      return getGeographicFallback(destinations, startAddress);
    }
    
    addDebugLog('ë‹¤ì¤‘ ì•Œê³ ë¦¬ì¦˜ TSP ìµœì í™” ì™„ë£Œ', {
      originalOrder: destinations,
      bestMethod: optimizationResult.method,
      optimizedRoute: optimizationResult.route,
      totalDistance: `${optimizationResult.distance.toFixed(2)}km`,
      coordinatesFilled: validCoordCount + '/' + allAddresses.length
    });
    
    // 4ë‹¨ê³„: ê²°ê³¼ ê²€ì¦
    const optimizationQuality = validateOptimization(destinations, optimizationResult.route, startAddress);
    
    // ê²°ê³¼ ë°˜í™˜
    return {
      success: true,
      coordinates: coordinatesCache,
      optimalOrder: optimizationResult.route,
      totalDistance: optimizationResult.distance.toFixed(2),
      addresses: optimizationResult.route,
      method: optimizationResult.method,
      quality: optimizationQuality,
      coordsAvailable: validCoordCount + '/' + allAddresses.length
    };
    
  } catch (error) {
    addDebugLog('ê³ ê¸‰ ìµœì í™” ì˜¤ë¥˜', { error: error.message });
    
    // Complete fallback
    try {
      return getGeographicFallback(destinations, startAddress);
    } catch (fallbackError) {
      addDebugLog('Fallback ì‹¤íŒ¨', { error: fallbackError.message });
      return { 
        success: false, 
        error: error.message,
        fallbackError: fallbackError.message,
        route: destinations // Return original order as last resort
      };
    }
  }
}

// Geographic fallback strategy when APIs fail
function getGeographicFallback(destinations, startAddress) {
  addDebugLog('ì§€ë¦¬ì  fallback ì „ëµ ì‹¤í–‰');
  
  if (!destinations || destinations.length === 0) {
    return { 
      success: false, 
      error: 'No destinations provided',
      route: []
    };
  }

  // Simple geographic sorting based on address patterns
  const sortedDest = [...destinations].sort((a, b) => {
    const aScore = getGeographicScore(a);
    const bScore = getGeographicScore(b);
    return aScore - bScore;
  });

  const fallbackDistance = calculateApproximateDistance(sortedDest);

  return {
    success: true,
    coordinates: {},
    optimalOrder: sortedDest,
    totalDistance: fallbackDistance.toFixed(2),
    addresses: sortedDest,
    method: 'ì§€ë¦¬ì  Fallback (API ì—†ìŒ)',
    quality: 'Estimated'
  };
}

function getGeographicScore(address) {
  // Priority scoring based on typical Seoul/Gwangjin geography
  const scores = {
    'êµ¬ì˜ê°•ë³€ë¡œ': 1,
    'ëŠ¥ë™ë¡œ': 2, 
    'ëšì„¬ë¡œ': 3,
    'ì•„ì°¨ì‚°ë¡œ': 4,
    'ìš©ë§ˆì‚°ë¡œ': 5,
    'ë™ì¼ë¡œ': 6
  };

  for (const [pattern, score] of Object.entries(scores)) {
    if (address.includes(pattern)) return score;
  }
  return 50; // Default middle score
}

function calculateApproximateDistance(addresses) {
  // Rough estimation based on address count and patterns
  return addresses.length * 1.2; // ~1.2km average between locations
}

// Validate optimization quality
function validateOptimization(original, optimized, startAddress) {
  if (!optimized || optimized.length !== original.length) {
    return 'Invalid - length mismatch';
  }

  const originalSet = new Set(original);
  const optimizedSet = new Set(optimized);
  
  if (originalSet.size !== optimizedSet.size) {
    return 'Invalid - address mismatch';
  }

  for (const addr of original) {
    if (!optimizedSet.has(addr)) {
      return 'Invalid - missing address';
    }
  }

  return 'Valid';
}

// Simple fallback route optimization algorithm
function getSimpleFallbackOrder(destinations) {
  addDebugLog('ê°„ë‹¨í•œ fallback ì•Œê³ ë¦¬ì¦˜ ì‹œì‘', { destinations });
  
  if (!destinations || destinations.length === 0) {
    return [];
  }
  
  if (destinations.length === 1) {
    return [0];
  }
  
  // ì•„ì°¨ì‚°ë¡œ 400 ê¸°ì¤€ ì‹¤ì œ ì§€ë¦¬ì  ìµœì í™” ì „ëµ
  const result = [];
  
  // ê°•ë³€(êµ¬ì˜ê°•ë³€ë¡œ) â†’ ì¤‘ê°„ì§€ì—­ â†’ ì™¸ê³½(ë™ì¼ë¡œ) ìˆœì„œë¡œ ìµœì í™”
  const priorities = {
    'êµ¬ì˜ê°•ë³€ë¡œ': 1,     // ê°•ë³€ ìš°ì„  ë°©ë¬¸
    'ëŠ¥ë™ë¡œ3ë‹¤ê¸¸': 2,    // ì¤‘ê°„ ì§€ì—­
    'ëŠ¥ë™ë¡œ32ê¸¸': 3,     // ì¤‘ê°„ ì§€ì—­  
    'ëšì„¬ë¡œ': 4,         // ì¤‘ê°„ ì§€ì—­
    'ì•„ì°¨ì‚°ë¡œ17ê°€ê¸¸': 5, // ì‚°ê¸°ìŠ­
    'ë™ì¼ë¡œ322': 6       // ê°€ì¥ ì™¸ê³½, ë§ˆì§€ë§‰ ë°©ë¬¸
  };
  
  const sortedIndices = destinations
    .map((addr, index) => ({ 
      address: addr, 
      index, 
      priority: getPriority(addr) 
    }))
    .sort((a, b) => a.priority - b.priority)
    .map(item => item.index);
    
  function getPriority(address) {
    for (const [key, priority] of Object.entries(priorities)) {
      if (address.includes(key)) return priority;
    }
    return 999; // ê¸°ë³¸ê°’
  }
  
  addDebugLog('Fallback ì•Œê³ ë¦¬ì¦˜ ì™„ë£Œ', { sortedIndices });
  
  return sortedIndices;
}

function calculateAddressSimilarity(addr1, addr2) {
  // Enhanced similarity for Gwangjin-gu addresses
  const words1 = addr1.replace(/\d+/g, '').split(/\s+/).filter(w => w.length > 0);
  const words2 = addr2.replace(/\d+/g, '').split(/\s+/).filter(w => w.length > 0);
  
  let commonWords = 0;
  let regionScore = 0;
  let roadScore = 0;
  
  // Basic word matching
  for (const word1 of words1) {
    if (words2.some(word2 => word2.includes(word1) || word1.includes(word2))) {
      commonWords++;
    }
  }
  
  // ê´‘ì§„êµ¬ ì§€ì—­ë³„ í´ëŸ¬ìŠ¤í„°ë§ (ì•„ì°¨ì‚°ë¡œ 400 ê¸°ì¤€)
  const regions = {
    western: ['êµ¬ì˜', 'ìì–‘', 'ë™ì¼ë¡œ'],     // ì„œì¸¡ (ì•„ì°¨ì‚°ë¡œ 400ê³¼ ê°€ê¹Œì›€)
    northern: ['ëŠ¥ë™ë¡œ', 'ì¤‘ê³¡'],           // ë¶ì¸¡ ëŠ¥ë™ë¡œ ê¶Œì—­
    riverside: ['ëšì„¬ë¡œ', 'í•œê°•', 'ê°•ë³€'],  // í•œê°•ë³€
    central: ['ì•„ì°¨ì‚°ë¡œ', 'ìš©ë§ˆì‚°ë¡œ']       // ì¤‘ì•™ ì•„ì°¨ì‚°ë¡œ ê¶Œì—­
  };
  
  const getRegion = (addr) => {
    for (const [region, keywords] of Object.entries(regions)) {
      if (keywords.some(keyword => addr.includes(keyword))) {
        return region;
      }
    }
    return 'unknown';
  };
  
  const region1 = getRegion(addr1);
  const region2 = getRegion(addr2);
  
  // ê°™ì€ ì§€ì—­ì´ë©´ ë†’ì€ ì ìˆ˜
  if (region1 === region2 && region1 !== 'unknown') {
    regionScore = 3;
  } else if (region1 !== 'unknown' && region2 !== 'unknown') {
    // ì¸ì ‘ ì§€ì—­ë“¤ì€ ì¤‘ê°„ ì ìˆ˜
    const adjacency = {
      western: ['northern', 'central'],     // ì„œì¸¡-ë¶ì¸¡, ì„œì¸¡-ì¤‘ì•™ ì—°ê²°
      northern: ['western', 'central'],     // ë¶ì¸¡-ì„œì¸¡, ë¶ì¸¡-ì¤‘ì•™ ì—°ê²°  
      riverside: ['western', 'central'],    // í•œê°•ë³€-ì„œì¸¡, í•œê°•ë³€-ì¤‘ì•™ ì—°ê²°
      central: ['western', 'northern', 'riverside'] // ì¤‘ì•™ì€ ëª¨ë“  ì§€ì—­ê³¼ ì—°ê²°
    };
    if (adjacency[region1]?.includes(region2)) {
      regionScore = 1.5;
    }
  }
  
  // ë„ë¡œëª… ìœ ì‚¬ì„± ì¶”ê°€ ì ìˆ˜
  const roads1 = ['ëŠ¥ë™ë¡œ', 'ëšì„¬ë¡œ', 'ë™ì¼ë¡œ', 'ì•„ì°¨ì‚°ë¡œ', 'ìš©ë§ˆì‚°ë¡œ'].filter(road => addr1.includes(road));
  const roads2 = ['ëŠ¥ë™ë¡œ', 'ëšì„¬ë¡œ', 'ë™ì¼ë¡œ', 'ì•„ì°¨ì‚°ë¡œ', 'ìš©ë§ˆì‚°ë¡œ'].filter(road => addr2.includes(road));
  
  if (roads1.length > 0 && roads2.length > 0) {
    if (roads1.some(r1 => roads2.includes(r1))) {
      roadScore = 2; // ê°™ì€ ë„ë¡œë©´ ë†’ì€ ì ìˆ˜
    }
  }
  
  // ì•„ì°¨ì‚°ë¡œ 400(ì¶œë°œì§€) ê¸°ì¤€ìœ¼ë¡œ ì„œì¸¡ ì§€ì—­ ìš°ì„ ìˆœìœ„ ë¶€ì—¬
  let proximityScore = 0;
  if (addr1.includes('ë™ì¼ë¡œ') || addr1.includes('êµ¬ì˜') || addr1.includes('ìì–‘')) {
    proximityScore += 1;
  }
  if (addr2.includes('ë™ì¼ë¡œ') || addr2.includes('êµ¬ì˜') || addr2.includes('ìì–‘')) {
    proximityScore += 1;
  }
  
  const totalScore = (commonWords + regionScore + roadScore + proximityScore);
  const maxPossible = Math.max(words1.length, words2.length, 5);
  
  return totalScore / maxPossible;
}

// Route Algorithm Comparison
async function compareRouteAlgorithms() {
  if (ì£¼ì†Œëª©ë¡.length < 2) {
    alert('ê²½ë¡œ ë¹„êµë¥¼ ìœ„í•´ì„œëŠ” ìµœì†Œ 2ê³³ ì´ìƒì˜ ì¶œì¥ì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤.');
    return;
  }

  const startLocation = document.getElementById('startLocation').value.trim() || 'ì•„ì°¨ì‚°ë¡œ 400';
  
  addDebugLog('=== ì•Œê³ ë¦¬ì¦˜ ë¹„êµ ì‹œì‘ ===', { startLocation, addresses: ì£¼ì†Œëª©ë¡ });

  // Show loading
  document.getElementById('route-loading').style.display = 'block';
  
  // Ensure coordinates are cached
  for (const address of [startLocation, ...ì£¼ì†Œëª©ë¡]) {
    await geocodeAddress(address);
  }
  
  const results = [];
  
  try {
    // 1. Original order
    const originalDistance = calculateTotalDistance([startLocation, ...ì£¼ì†Œëª©ë¡, startLocation]);
    results.push({
      method: 'ì›ë˜ ìˆœì„œ',
      route: ì£¼ì†Œëª©ë¡,
      distance: originalDistance,
      color: '#999'
    });

    // 2. Geography-aware Seoul routing
    const geoRoute = optimizeRouteGeographyAware(ì£¼ì†Œëª©ë¡, startLocation);
    const geoDistance = calculateTotalDistance([startLocation, ...geoRoute, startLocation]);
    results.push({
      method: 'ì§€ë¦¬ ê¸°ë°˜ ìµœì í™” (ì„œìš¸ íŠ¹í™”)',
      route: geoRoute,
      distance: geoDistance,
      color: '#2ecc71'
    });

    // 3. Sector-based routing
    const sectorRoute = optimizeRouteSectorBased(ì£¼ì†Œëª©ë¡, startLocation);
    const sectorDistance = calculateTotalDistance([startLocation, ...sectorRoute, startLocation]);
    results.push({
      method: 'êµ¬ì—­ë³„ ìˆœíšŒ (íƒë°° ë°©ì‹)',
      route: sectorRoute,
      distance: sectorDistance,
      color: '#3498db'
    });

    // 4. Traffic-aware routing
    const trafficRoute = optimizeRouteTrafficAware(ì£¼ì†Œëª©ë¡, startLocation);
    const trafficDistance = calculateTotalDistance([startLocation, ...trafficRoute, startLocation]);
    results.push({
      method: 'êµí†µ ê³ ë ¤ ìµœì í™”',
      route: trafficRoute,
      distance: trafficDistance,
      color: '#e74c3c'
    });

    // 5. Hierarchical road routing
    const hierarchicalRoute = optimizeRouteHierarchical(ì£¼ì†Œëª©ë¡, startLocation);
    const hierarchicalDistance = calculateTotalDistance([startLocation, ...hierarchicalRoute, startLocation]);
    results.push({
      method: 'ë„ë¡œ ìœ„ê³„ ê¸°ë°˜ (ê°„ì„ â†’ì§€ì„ )',
      route: hierarchicalRoute,
      distance: hierarchicalDistance,
      color: '#9b59b6'
    });

    // 6. Traditional Nearest Neighbor for comparison
    const nnRoute = optimizeRouteNearestNeighbor(ì£¼ì†Œëª©ë¡, startLocation);
    const nnDistance = calculateTotalDistance([startLocation, ...nnRoute, startLocation]);
    results.push({
      method: 'Nearest Neighbor (ê¸°ì¡´)',
      route: nnRoute,
      distance: nnDistance,
      color: '#95a5a6'
    });

    // 6. AI ìµœì í™” ê²°ê³¼ (if available)
    if (GEMINI_API_KEY && GEMINI_API_KEY.startsWith('AIzaSy')) {
      try {
        const aiIndices = await getOptimalRouteFromGemini(startLocation, ì£¼ì†Œëª©ë¡);
        const aiRoute = aiIndices.map(index => ì£¼ì†Œëª©ë¡[index]).filter(addr => addr);
        const aiDistance = calculateTotalDistance([startLocation, ...aiRoute, startLocation]);
        results.push({
          method: 'Gemini AI',
          route: aiRoute,
          distance: aiDistance,
          color: '#f39c12'
        });
      } catch (error) {
        addDebugLog('AI ì•Œê³ ë¦¬ì¦˜ ì‹¤íŒ¨', { error: error.message });
      }
    }

    // Sort by distance (best first)
    results.sort((a, b) => a.distance - b.distance);

    // ê²°ê³¼ í‘œì‹œ
    showRouteComparison(results, startLocation);

  } catch (error) {
    addDebugLog('ì•Œê³ ë¦¬ì¦˜ ë¹„êµ ì¤‘ ì˜¤ë¥˜', { error: error.message });
    alert('ì•Œê³ ë¦¬ì¦˜ ë¹„êµ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
  } finally {
    document.getElementById('route-loading').style.display = 'none';
  }
}

function showRouteComparison(results, startLocation) {
  // Create modal HTML
  const modalHtml = `
    <div id="comparisonModal" class="modal show">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <div class="modal-header">
          <div class="modal-title">ğŸ” ì•Œê³ ë¦¬ì¦˜ ì„±ëŠ¥ ë¹„êµ</div>
          <div class="modal-subtitle">ì¶œë°œì§€: ${startLocation}</div>
        </div>
        
        <div style="margin-bottom: 20px;">
          <h4 style="color: #1b3c82; margin-bottom: 15px;">ğŸ“Š ì„±ëŠ¥ ìˆœìœ„</h4>
          ${results.map((result, index) => `
            <div style="background: ${index === 0 ? 'rgba(46, 204, 113, 0.1)' : 'rgba(255,255,255,0.8)'}; 
                        border: 1px solid ${result.color}; border-radius: 8px; padding: 12px; margin-bottom: 10px;
                        ${index === 0 ? 'border-left: 4px solid #27ae60;' : ''}">
              <div style="display: flex; justify-content: between; align-items: center;">
                <div>
                  <strong style="color: ${result.color};">
                    ${index + 1}. ${result.method}
                    ${index === 0 ? ' ğŸ†' : ''}
                  </strong>
                  <div style="font-size: 0.9rem; color: #666; margin-top: 5px;">
                    ì´ ê±°ë¦¬: <strong>${result.distance.toFixed(2)}km</strong>
                    ${index > 0 ? `(+${(result.distance - results[0].distance).toFixed(2)}km)` : ''}
                  </div>
                </div>
                <button onclick="applyRoute('${result.method}', ${JSON.stringify(result.route).replace(/"/g, '&quot;')})" 
                        style="background: ${result.color}; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                  ì ìš©
                </button>
              </div>
              <div style="font-size: 0.8rem; color: #888; margin-top: 8px; line-height: 1.4;">
                ${result.route.slice(0, 3).join(' â†’ ')}${result.route.length > 3 ? ` â†’ ... (${result.route.length}ê³³)` : ''}
              </div>
            </div>
          `).join('')}
        </div>

        <div style="background: rgba(79, 172, 254, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
          <h4 style="color: #1b3c82; margin-bottom: 10px;">ğŸ’¡ ì‹¤ìš©ì  ê²½ë¡œ ìµœì í™” ì•Œê³ ë¦¬ì¦˜</h4>
          <div style="font-size: 0.85rem; line-height: 1.5;">
            â€¢ <strong>ì§€ë¦¬ ê¸°ë°˜ ìµœì í™”</strong>: ì„œìš¸ ì§€ì—­ íŠ¹ì„± ë°˜ì˜, ê°•ë¶/ê°•ë‚¨/ê°•ì„œ ìš°ì„ ìˆœìœ„<br>
            â€¢ <strong>êµ¬ì—­ë³„ ìˆœíšŒ</strong>: íƒë°°/ë°°ë‹¬ ë°©ì‹, ê´‘ì§„êµ¬ ë¯¸ì„¸ê¶Œì—­ ê·¸ë£¹í™”<br>
            â€¢ <strong>êµí†µ ê³ ë ¤</strong>: ê°„ì„ ë„ë¡œ í˜¼ì¡ë„ ë°˜ì˜, ì§€ì„ ë„ë¡œ ìš°ì„ <br>
            â€¢ <strong>ë„ë¡œ ìœ„ê³„ ê¸°ë°˜</strong>: ê°„ì„ â†’ì§‘ì‚°â†’êµ­ì§€ë„ë¡œ ìˆœì„œ<br>
            â€¢ <strong>Gemini AI</strong>: ì§€ë¦¬ì  ì§€ì‹ ê¸°ë°˜ ì¶”ë¡ <br>
            â€¢ <strong>ê¸°ì¡´ ë°©ì‹</strong>: Nearest Neighbor (ë¹„êµìš©)
          </div>
        </div>
        
        <div style="text-align: center;">
          <button class="btn btn-primary" onclick="applyBestRoute(${JSON.stringify(results[0].route).replace(/"/g, '&quot;')})">
            ğŸ† ìµœì  ê²½ë¡œ ì ìš©
          </button>
          <button class="btn btn-secondary" onclick="closeComparisonModal()" style="margin-left: 10px;">
            ë‹«ê¸°
          </button>
        </div>
      </div>
    </div>
  `;

  // Remove existing modal if any
  const existingModal = document.getElementById('comparisonModal');
  if (existingModal) {
    document.body.removeChild(existingModal);
  }

  // Add new modal to body
  document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function applyRoute(method, route) {
  optimizedRoute = route;
  alert(`${method} ê²½ë¡œê°€ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤!`);
  closeComparisonModal();
  closeModal(); // Close main route modal
  selectMode('travel');
}

function applyBestRoute(route) {
  optimizedRoute = route;
  alert('ìµœì  ê²½ë¡œê°€ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤!');
  closeComparisonModal();
  closeModal(); // Close main route modal
  selectMode('travel');
}

function closeComparisonModal() {
  const modal = document.getElementById('comparisonModal');
  if (modal) {
    document.body.removeChild(modal);
  }
}

// ===== ê³ ê¸‰ ê²½ë¡œ ìµœì í™” ì•Œê³ ë¦¬ì¦˜ ì™„ë£Œ =====

// Data Management Functions
let selectedAddressesForReset = new Set();

function updateDataStatus() {
  const totalAddresses = document.getElementById('total-addresses');
  const totalAddressesBottom = document.getElementById('total-addresses-bottom');
  
  if (totalAddresses) {
    totalAddresses.textContent = ì£¼ì†Œëª©ë¡.length;
  }
  if (totalAddressesBottom) {
    totalAddressesBottom.textContent = ì£¼ì†Œëª©ë¡.length;
  }
}

function showDataOptions() {
  document.getElementById('dataModal').classList.add('show');
}

// ===== ë©”ì¸ ì•± ì´ˆê¸°í™” =====
// í˜ì´ì§€ ë¡œë“œì‹œ ì´ˆê¸°í™”
document.addEventListener('DOMContentLoaded', function() {
  try {
    console.log('DOM ë¡œë“œ ì™„ë£Œ - ì´ˆê¸°í™” ì‹œì‘');
    
    loadAddressList();
    loadStatusData();
    loadMemoData(); 
    loadPhotoData();
    loadViewedAddresses();
    updateDataStatus();
    updateAddressPreview();
    updateTravelMode();
    
    // Initialize map selection UI
    updateMapSelection();
    
    console.log('ì´ˆê¸°í™” ì™„ë£Œ');
  } catch (error) {
    console.error('ì´ˆê¸°í™” ì˜¤ë¥˜:', error);
    alert('ì•± ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
  }
});

// Legacy compatibility functions (empty implementations)
function showTab() {} // No longer used
function saveMemo() {} // Replaced by saveRecord
function showDropdown() {} // No longer used
function handleStatusChange() {} // Replaced by handleRecordStatusChange
function saveStatus() {} // Replaced by saveRecord
function openMapInNewTab() {} // Replaced by openMapForAddress

function resetSelectedAddresses() {
  if (selectedAddressesForReset.size === 0) return;
  
  const confirmMsg = 'ì„ íƒëœ ' + selectedAddressesForReset.size + 'ê°œ ì¶œì¥ì§€ì˜ ëª¨ë“  ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì‚­ì œë  í•­ëª©:\n' + Array.from(selectedAddressesForReset).join('\n') + '\n\nì´ ì‘ì—…ì€ ì·¨ì†Œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
  
  if (!confirm(confirmMsg)) return;
  
  // Remove selected addresses from all data structures
  selectedAddressesForReset.forEach(addr => {
    const index = ì£¼ì†Œëª©ë¡.indexOf(addr);
    if (index > -1) {
      ì£¼ì†Œëª©ë¡.splice(index, 1);
    }
    delete statusMap[addr];
    delete memoMap[addr];
    delete photoMap[addr];
    delete originalPhotoMap[addr];
    viewedAddresses.delete(addr);
  });
  
  // Save to localStorage
  saveAddressList();
  localStorage.setItem('statusMap', JSON.stringify(statusMap));
  localStorage.setItem('memoMap', JSON.stringify(memoMap));
  localStorage.setItem('photoMap', JSON.stringify(photoMap));
  saveViewedAddresses();
  
  // Reset selection
  selectedAddressesForReset.clear();
  
  // Update UI
  updateDataStatus();
  updateAddressPreview();
  updateTravelMode();
  
  alert('ì„ íƒëœ ì¶œì¥ì§€ ë°ì´í„°ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
  closeModal();
}

function confirmFullReset() {
  const confirmMsg = 'ëª¨ë“  ì¶œì¥ì§€ì™€ ê¸°ë¡ì„ ì™„ì „íˆ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\në‹¤ìŒ ë°ì´í„°ê°€ ëª¨ë‘ ì‚­ì œë©ë‹ˆë‹¤:\n- ëª¨ë“  ì¶œì¥ì§€ ëª©ë¡\n- ëª¨ë“  ì¶œì¥ ìƒíƒœ\n- ëª¨ë“  ë©”ëª¨\n- ëª¨ë“  ì‚¬ì§„\n\nì´ ì‘ì—…ì€ ì·¨ì†Œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
  
  if (!confirm(confirmMsg)) return;
  
  // Clear all data
  ì£¼ì†Œëª©ë¡ = [];
  statusMap = {};
  memoMap = {};
  photoMap = {};
  viewedAddresses.clear();
  AppState.currentAddress = null;
  
  // Clear localStorage
  localStorage.removeItem('addressList');
  localStorage.removeItem('statusMap');
  localStorage.removeItem('memoMap');
  localStorage.removeItem('photoMap');
  localStorage.removeItem('viewedAddresses');
  
  // Update UI
  updateDataStatus();
  updateAddressPreview();
  updateTravelMode();
  
  alert('ëª¨ë“  ë°ì´í„°ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
  closeModal();
}

function continueWithExistingData() {
  closeModal();
}

function closeModal() {
  document.querySelectorAll('.modal').forEach(modal => {
    modal.classList.remove('show');
  });
}


</script>
</body>
</html>

